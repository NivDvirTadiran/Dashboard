/* soapStub.h
   Generated by gSOAP 2.8.52 for emisweb.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"urn:EMISweb"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20852
# error "GSOAP VERSION 20852 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class ns1__RequestInfoHeaderType;	/* emisweb.h:146 */
class ns1__GenInfoRequestType;	/* emisweb.h:149 */
class ns1__ACDMultiRequestType;	/* emisweb.h:152 */
class ns1__ACDRequestType;	/* emisweb.h:155 */
class ns1__TFRequestType;	/* emisweb.h:158 */
class ns1__ChatResponseType;	/* emisweb.h:161 */
class ns1__ResponseInfoHeaderType;	/* emisweb.h:164 */
class ns1__ResponseSaveReportType;	/* emisweb.h:167 */
class ns1__DataItemType;	/* emisweb.h:170 */
class ns1__DataItemRow;	/* emisweb.h:173 */
class ns1__BlockItemType;	/* emisweb.h:176 */
class ns1__ReturnArrayDataType;	/* emisweb.h:179 */
class ns1__returnDataRowsPerGroup;	/* emisweb.h:182 */
class ns1__ReturnMatrixDataTypePerGroup;	/* emisweb.h:185 */
class ns1__returnDataRowsPerSuperGroup;	/* emisweb.h:188 */
class ns1__ReturnMatrixDataTypePerSuperGroup;	/* emisweb.h:191 */
class ns1__ReturnMatrixDataTypeBG;	/* emisweb.h:194 */
class ns1__LoginRequestType;	/* emisweb.h:197 */
class ns1__LoginReturnType;	/* emisweb.h:200 */
class ns1__GenRequestType;	/* emisweb.h:203 */
class ns1__GroupListDataItemType;	/* emisweb.h:206 */
class ns1__GroupListReturnType;	/* emisweb.h:209 */
class ns1__GenListDataItemType;	/* emisweb.h:212 */
class ns1__GenListReturnType;	/* emisweb.h:215 */
class ns1__AgentsListDataItemType;	/* emisweb.h:218 */
class ns1__AgentsListReturnType;	/* emisweb.h:221 */
class ns1__BriefInfoRequestType;	/* emisweb.h:224 */
class ns1__DefaultWorkspaceRequestType;	/* emisweb.h:227 */
class ns1__DefaultWorkspaceItemType;	/* emisweb.h:230 */
class ns1__DefaultWorkspaceReturnType;	/* emisweb.h:233 */
class ns1__ReportListDataRequestType;	/* emisweb.h:236 */
class ns1__ReportListDataItemType;	/* emisweb.h:239 */
class ns1__ReportListDataReturnType;	/* emisweb.h:242 */
class ns1__DNISListDataItemType;	/* emisweb.h:245 */
class ns1__DNISListReturnType;	/* emisweb.h:248 */
class ns1__BriefDNISInfoRequestType;	/* emisweb.h:251 */
class ns1__SuperGroupListDataItemType;	/* emisweb.h:254 */
class ns1__SuperGroupListReturnType;	/* emisweb.h:257 */
class ns1__SaveWorkspaseRequestType;	/* emisweb.h:260 */
class ns1__RequestSaveReportType;	/* emisweb.h:263 */
class ns1__RequestDeleteReportType;	/* emisweb.h:266 */
class ns1__LoginManagerRequestType;	/* emisweb.h:269 */
class ns1__ApplicationRegisterRequestType;	/* emisweb.h:272 */
class ns1__ApplicationKeepAliveRequestType;	/* emisweb.h:275 */
class ns1__ApplicationReturnType;	/* emisweb.h:278 */
class ns1__StatRequestType;	/* emisweb.h:281 */
class ns1__StatItemType;	/* emisweb.h:284 */
class ns1__StatReturnType;	/* emisweb.h:287 */
struct __ns1__GroupDetailFullInfo;	/* emisweb.h:1954 */
struct __ns1__GroupQueInfo;	/* emisweb.h:2024 */
struct __ns1__GroupAgentsInfo;	/* emisweb.h:2094 */
struct __ns1__GroupAbndInfo;	/* emisweb.h:2164 */
struct __ns1__GroupIntOvfInfo;	/* emisweb.h:2234 */
struct __ns1__GroupShiftInfo;	/* emisweb.h:2304 */
struct __ns1__GroupGeneralInfo;	/* emisweb.h:2374 */
struct __ns1__GroupPeriodInfo;	/* emisweb.h:2444 */
struct __ns1__IvrApplInfo;	/* emisweb.h:2514 */
struct __ns1__IvrPortInfo;	/* emisweb.h:2584 */
struct __ns1__IvrGrpInfo;	/* emisweb.h:2654 */
struct __ns1__MailboxInfo;	/* emisweb.h:2724 */
struct __ns1__SuperGroupInfo;	/* emisweb.h:2794 */
struct __ns1__SuperGroupList;	/* emisweb.h:2864 */
struct __ns1__UserLogin;	/* emisweb.h:2934 */
struct __ns1__UserLogout;	/* emisweb.h:3004 */
struct __ns1__GroupList;	/* emisweb.h:3074 */
struct __ns1__IvrPortGroupList;	/* emisweb.h:3144 */
struct __ns1__IvrAppList;	/* emisweb.h:3214 */
struct __ns1__MailAccList;	/* emisweb.h:3284 */
struct __ns1__AgentsPerGroupInfo;	/* emisweb.h:3354 */
struct __ns1__AgentsList;	/* emisweb.h:3424 */
struct __ns1__BriefAgents;	/* emisweb.h:3494 */
struct __ns1__DefaultWorkspace;	/* emisweb.h:3564 */
struct __ns1__ReportListData;	/* emisweb.h:3634 */
struct __ns1__VoiceDNISList;	/* emisweb.h:3704 */
struct __ns1__EmailDNISList;	/* emisweb.h:3774 */
struct __ns1__BriefVoiceDNIS;	/* emisweb.h:3844 */
struct __ns1__BriefEmailDNIS;	/* emisweb.h:3914 */
struct __ns1__CommandAgentLoginLogout;	/* emisweb.h:3984 */
struct __ns1__CommandAgentReleaseResume;	/* emisweb.h:4054 */
struct __ns1__CommandAgentStartChat;	/* emisweb.h:4124 */
struct __ns1__CommandAgentStartRecord;	/* emisweb.h:4194 */
struct __ns1__CommandAgentTelephonyFeatures;	/* emisweb.h:4264 */
struct __ns1__SaveWorkspase;	/* emisweb.h:4334 */
struct __ns1__SaveReport;	/* emisweb.h:4404 */
struct __ns1__DeleteReport;	/* emisweb.h:4474 */
struct __ns1__LoginManagerAgentsPerGroup;	/* emisweb.h:4544 */
struct __ns1__LoginManagerGroupsPerAgent;	/* emisweb.h:4614 */
struct __ns1__LoginManagerOneAgentToMultiGroups;	/* emisweb.h:4684 */
struct __ns1__LoginManagerMultiAgentsToOneGroup;	/* emisweb.h:4754 */
struct __ns1__LoginManagerAvailableAgentsForGroup;	/* emisweb.h:4824 */
struct __ns1__LoginManagerAvailableGroupsForAgent;	/* emisweb.h:4894 */
struct __ns1__ApplicationRegister;	/* emisweb.h:4964 */
struct __ns1__ApplicationKeepAlive;	/* emisweb.h:5034 */
struct __ns1__TraceInternalStat;	/* emisweb.h:5104 */
struct __ns1__AgentNeedHelp;	/* emisweb.h:5174 */
struct __ns1__GroupHourlyInfo;	/* emisweb.h:5244 */
struct __ns1__GroupDailyBriefInfo;	/* emisweb.h:5314 */
struct __ns1__GroupDailyDetailedInfo;	/* emisweb.h:5384 */
struct __ns1__SuperGroupHourlyInfo;	/* emisweb.h:5454 */
struct __ns1__SuperGroupDailyBriefInfo;	/* emisweb.h:5524 */

/* emisweb.h:146 */
#ifndef SOAP_TYPE_ns1__RequestInfoHeaderType
#define SOAP_TYPE_ns1__RequestInfoHeaderType (8)
/* complex XSD type 'ns1:RequestInfoHeaderType': */
class SOAP_CMAC ns1__RequestInfoHeaderType {
      public:
        /// Required element 'serviceReqId' of XSD type 'xsd:unsignedInt'
        unsigned int serviceReqId;
        /// Required element 'ticket' of XSD type 'xsd:string'
        std::string ticket;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RequestInfoHeaderType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__RequestInfoHeaderType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RequestInfoHeaderType, default initialized and not managed by a soap context
        virtual ns1__RequestInfoHeaderType *soap_alloc(void) const { return SOAP_NEW(ns1__RequestInfoHeaderType); }
      public:
        /// Constructor with initializations
        ns1__RequestInfoHeaderType() : serviceReqId(), ticket(), soap() { }
        virtual ~ns1__RequestInfoHeaderType() { }
        /// Friend allocator used by soap_new_ns1__RequestInfoHeaderType(struct soap*, int)
        friend SOAP_FMAC1 ns1__RequestInfoHeaderType * SOAP_FMAC2 soap_instantiate_ns1__RequestInfoHeaderType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:149 */
#ifndef SOAP_TYPE_ns1__GenInfoRequestType
#define SOAP_TYPE_ns1__GenInfoRequestType (9)
/* complex XSD type 'ns1:GenInfoRequestType': */
class SOAP_CMAC ns1__GenInfoRequestType {
      public:
        /// Required element 'requestInfoHeader' of XSD type 'ns1:RequestInfoHeaderType'
        ns1__RequestInfoHeaderType *requestInfoHeader;
        /// Required element 'Id' of XSD type 'xsd:unsignedInt'
        std::vector<unsigned int> Id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GenInfoRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GenInfoRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GenInfoRequestType, default initialized and not managed by a soap context
        virtual ns1__GenInfoRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__GenInfoRequestType); }
      public:
        /// Constructor with initializations
        ns1__GenInfoRequestType() : requestInfoHeader(), Id(), soap() { }
        virtual ~ns1__GenInfoRequestType() { }
        /// Friend allocator used by soap_new_ns1__GenInfoRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GenInfoRequestType * SOAP_FMAC2 soap_instantiate_ns1__GenInfoRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:152 */
#ifndef SOAP_TYPE_ns1__ACDMultiRequestType
#define SOAP_TYPE_ns1__ACDMultiRequestType (10)
/* complex XSD type 'ns1:ACDMultiRequestType': */
class SOAP_CMAC ns1__ACDMultiRequestType {
      public:
        /// Required element 'requestInfoHeader' of XSD type 'ns1:RequestInfoHeaderType'
        ns1__RequestInfoHeaderType *requestInfoHeader;
        /// Required element 'Id' of XSD type 'xsd:unsignedInt'
        unsigned int Id;
        /// Required element 'multiId' of XSD type 'xsd:unsignedInt'
        std::vector<unsigned int> multiId;
        /// Required element 'Operation' of XSD type 'xsd:string'
        std::string Operation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ACDMultiRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ACDMultiRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ACDMultiRequestType, default initialized and not managed by a soap context
        virtual ns1__ACDMultiRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__ACDMultiRequestType); }
      public:
        /// Constructor with initializations
        ns1__ACDMultiRequestType() : requestInfoHeader(), Id(), multiId(), Operation(), soap() { }
        virtual ~ns1__ACDMultiRequestType() { }
        /// Friend allocator used by soap_new_ns1__ACDMultiRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ACDMultiRequestType * SOAP_FMAC2 soap_instantiate_ns1__ACDMultiRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:155 */
#ifndef SOAP_TYPE_ns1__ACDRequestType
#define SOAP_TYPE_ns1__ACDRequestType (11)
/* complex XSD type 'ns1:ACDRequestType': */
class SOAP_CMAC ns1__ACDRequestType {
      public:
        /// Required element 'requestInfoHeader' of XSD type 'ns1:RequestInfoHeaderType'
        ns1__RequestInfoHeaderType *requestInfoHeader;
        /// Required element 'AgentId' of XSD type 'xsd:unsignedInt'
        unsigned int AgentId;
        /// Required element 'GroupId' of XSD type 'xsd:unsignedInt'
        unsigned int GroupId;
        /// Required element 'Operation' of XSD type 'xsd:string'
        std::string Operation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ACDRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ACDRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ACDRequestType, default initialized and not managed by a soap context
        virtual ns1__ACDRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__ACDRequestType); }
      public:
        /// Constructor with initializations
        ns1__ACDRequestType() : requestInfoHeader(), AgentId(), GroupId(), Operation(), soap() { }
        virtual ~ns1__ACDRequestType() { }
        /// Friend allocator used by soap_new_ns1__ACDRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ACDRequestType * SOAP_FMAC2 soap_instantiate_ns1__ACDRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:158 */
#ifndef SOAP_TYPE_ns1__TFRequestType
#define SOAP_TYPE_ns1__TFRequestType (12)
/* complex XSD type 'ns1:TFRequestType': */
class SOAP_CMAC ns1__TFRequestType {
      public:
        /// Required element 'requestInfoHeader' of XSD type 'ns1:RequestInfoHeaderType'
        ns1__RequestInfoHeaderType *requestInfoHeader;
        /// Required element 'AgentId' of XSD type 'xsd:unsignedInt'
        unsigned int AgentId;
        /// Required element 'Operation' of XSD type 'xsd:string'
        std::string Operation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TFRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__TFRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TFRequestType, default initialized and not managed by a soap context
        virtual ns1__TFRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__TFRequestType); }
      public:
        /// Constructor with initializations
        ns1__TFRequestType() : requestInfoHeader(), AgentId(), Operation(), soap() { }
        virtual ~ns1__TFRequestType() { }
        /// Friend allocator used by soap_new_ns1__TFRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__TFRequestType * SOAP_FMAC2 soap_instantiate_ns1__TFRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:161 */
#ifndef SOAP_TYPE_ns1__ChatResponseType
#define SOAP_TYPE_ns1__ChatResponseType (13)
/* complex XSD type 'ns1:ChatResponseType': */
class SOAP_CMAC ns1__ChatResponseType {
      public:
        /// Required element 'sessionId' of XSD type 'xsd:string'
        std::string sessionId;
        /// Required element 'serviceReqId' of XSD type 'xsd:unsignedInt'
        unsigned int serviceReqId;
        /// Required element 'errorCause' of XSD type 'xsd:unsignedInt'
        unsigned int errorCause;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ChatResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ChatResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ChatResponseType, default initialized and not managed by a soap context
        virtual ns1__ChatResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__ChatResponseType); }
      public:
        /// Constructor with initializations
        ns1__ChatResponseType() : sessionId(), serviceReqId(), errorCause(), soap() { }
        virtual ~ns1__ChatResponseType() { }
        /// Friend allocator used by soap_new_ns1__ChatResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ChatResponseType * SOAP_FMAC2 soap_instantiate_ns1__ChatResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:164 */
#ifndef SOAP_TYPE_ns1__ResponseInfoHeaderType
#define SOAP_TYPE_ns1__ResponseInfoHeaderType (14)
/* complex XSD type 'ns1:ResponseInfoHeaderType': */
class SOAP_CMAC ns1__ResponseInfoHeaderType {
      public:
        /// Required element 'serviceReqId' of XSD type 'xsd:unsignedInt'
        unsigned int serviceReqId;
        /// Required element 'errorCause' of XSD type 'xsd:unsignedInt'
        unsigned int errorCause;
        /// Required element 'serversInfo' of XSD type 'xsd:string'
        std::string serversInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ResponseInfoHeaderType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ResponseInfoHeaderType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ResponseInfoHeaderType, default initialized and not managed by a soap context
        virtual ns1__ResponseInfoHeaderType *soap_alloc(void) const { return SOAP_NEW(ns1__ResponseInfoHeaderType); }
      public:
        /// Constructor with initializations
        ns1__ResponseInfoHeaderType() : serviceReqId(), errorCause(), serversInfo(), soap() { }
        virtual ~ns1__ResponseInfoHeaderType() { }
        /// Friend allocator used by soap_new_ns1__ResponseInfoHeaderType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ResponseInfoHeaderType * SOAP_FMAC2 soap_instantiate_ns1__ResponseInfoHeaderType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:167 */
#ifndef SOAP_TYPE_ns1__ResponseSaveReportType
#define SOAP_TYPE_ns1__ResponseSaveReportType (15)
/* complex XSD type 'ns1:ResponseSaveReportType': */
class SOAP_CMAC ns1__ResponseSaveReportType {
      public:
        /// Required element 'reportId' of XSD type 'xsd:unsignedInt'
        unsigned int reportId;
        /// Required element 'serviceReqId' of XSD type 'xsd:unsignedInt'
        unsigned int serviceReqId;
        /// Required element 'errorCause' of XSD type 'xsd:unsignedInt'
        unsigned int errorCause;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ResponseSaveReportType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ResponseSaveReportType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ResponseSaveReportType, default initialized and not managed by a soap context
        virtual ns1__ResponseSaveReportType *soap_alloc(void) const { return SOAP_NEW(ns1__ResponseSaveReportType); }
      public:
        /// Constructor with initializations
        ns1__ResponseSaveReportType() : reportId(), serviceReqId(), errorCause(), soap() { }
        virtual ~ns1__ResponseSaveReportType() { }
        /// Friend allocator used by soap_new_ns1__ResponseSaveReportType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ResponseSaveReportType * SOAP_FMAC2 soap_instantiate_ns1__ResponseSaveReportType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:170 */
#ifndef SOAP_TYPE_ns1__DataItemType
#define SOAP_TYPE_ns1__DataItemType (16)
/* complex XSD type 'ns1:DataItemType': */
class SOAP_CMAC ns1__DataItemType {
      public:
        /// Required element 'ersid' of XSD type 'xsd:string'
        std::string ersid;
        /// Required element 'value' of XSD type 'xsd:string'
        std::string value;
        /// Required element 'ersname' of XSD type 'xsd:string'
        std::string ersname;
        /// Optional element 'bgcolor' of XSD type 'xsd:unsignedInt'
        unsigned int *bgcolor;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DataItemType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DataItemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DataItemType, default initialized and not managed by a soap context
        virtual ns1__DataItemType *soap_alloc(void) const { return SOAP_NEW(ns1__DataItemType); }
      public:
        /// Constructor with initializations
        ns1__DataItemType();
        //ns1__DataItemType() : ersid(), value(), ersname(), bgcolor(), soap() { }
        virtual ~ns1__DataItemType();
        //virtual ~ns1__DataItemType() { }
        /// Friend allocator used by soap_new_ns1__DataItemType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DataItemType * SOAP_FMAC2 soap_instantiate_ns1__DataItemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:173 */
#ifndef SOAP_TYPE_ns1__DataItemRow
#define SOAP_TYPE_ns1__DataItemRow (17)
/* complex XSD type 'ns1:DataItemRow': */
class SOAP_CMAC ns1__DataItemRow {
      public:
        /// Required element 'returnArray' of XSD type 'ns1:DataItemType'
        std::vector<ns1__DataItemType *> returnArray;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DataItemRow
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DataItemRow; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DataItemRow, default initialized and not managed by a soap context
        virtual ns1__DataItemRow *soap_alloc(void) const { return SOAP_NEW(ns1__DataItemRow); }
        /// Dealocate all vectors
        virtual void soap_dealloc(void);
      public:
        /// Constructor with initializations
        ns1__DataItemRow();
        virtual ~ns1__DataItemRow();
        /// Friend allocator used by soap_new_ns1__DataItemRow(struct soap*, int)
        friend SOAP_FMAC1 ns1__DataItemRow * SOAP_FMAC2 soap_instantiate_ns1__DataItemRow(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:176 */
#ifndef SOAP_TYPE_ns1__BlockItemType
#define SOAP_TYPE_ns1__BlockItemType (18)
/* complex XSD type 'ns1:BlockItemType': */
class SOAP_CMAC ns1__BlockItemType {
      public:
        /// Required element 'Id' of XSD type 'xsd:unsignedInt'
        unsigned int Id;
        /// Required element 'Name' of XSD type 'xsd:string'
        std::string Name;
        /// Required element 'returnArray' of XSD type 'ns1:DataItemType'
        std::vector<ns1__DataItemType *> returnArray;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BlockItemType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BlockItemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BlockItemType, default initialized and not managed by a soap context
        virtual ns1__BlockItemType *soap_alloc(void) const { return SOAP_NEW(ns1__BlockItemType); }
        /// Dealocate all vectors
        virtual void soap_dealloc(void);
      public:
        /// Constructor with initializations
        ns1__BlockItemType();
        //ns1__BlockItemType() : Id(), Name(), returnArray(), soap() { }
        virtual ~ns1__BlockItemType();
        //virtual ~ns1__BlockItemType() { }
        /// Friend allocator used by soap_new_ns1__BlockItemType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BlockItemType * SOAP_FMAC2 soap_instantiate_ns1__BlockItemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:179 */
#ifndef SOAP_TYPE_ns1__ReturnArrayDataType
#define SOAP_TYPE_ns1__ReturnArrayDataType (19)
/* complex XSD type 'ns1:ReturnArrayDataType': */
class SOAP_CMAC ns1__ReturnArrayDataType {
      public:
        /// Required element 'responseInfoHeader' of XSD type 'ns1:ResponseInfoHeaderType'
        ns1__ResponseInfoHeaderType *responseInfoHeader;
        /// Required element 'returnArrayOfBlocks' of XSD type 'ns1:BlockItemType'
        std::vector<ns1__BlockItemType *> returnArrayOfBlocks;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ReturnArrayDataType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ReturnArrayDataType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ReturnArrayDataType, default initialized and not managed by a soap context
        virtual ns1__ReturnArrayDataType *soap_alloc(void) const { return SOAP_NEW(ns1__ReturnArrayDataType); }
        /// Dealocate all vectors
        virtual void soap_dealloc(void);
      public:
        /// Constructor with initializations
        ns1__ReturnArrayDataType();
        virtual ~ns1__ReturnArrayDataType();
        /// Friend allocator used by soap_new_ns1__ReturnArrayDataType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ReturnArrayDataType * SOAP_FMAC2 soap_instantiate_ns1__ReturnArrayDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:182 */
#ifndef SOAP_TYPE_ns1__returnDataRowsPerGroup
#define SOAP_TYPE_ns1__returnDataRowsPerGroup (20)
/* complex XSD type 'ns1:returnDataRowsPerGroup': */
class SOAP_CMAC ns1__returnDataRowsPerGroup {
      public:
        /// Required element 'Id' of XSD type 'xsd:unsignedInt'
        unsigned int Id;
        /// Required element 'Name' of XSD type 'xsd:string'
        std::string Name;
        /// Optional element 'returnMatrix' of XSD type 'ns1:DataItemRow'
        std::vector<ns1__DataItemRow *> returnMatrix;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__returnDataRowsPerGroup
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__returnDataRowsPerGroup; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__returnDataRowsPerGroup, default initialized and not managed by a soap context
        virtual ns1__returnDataRowsPerGroup *soap_alloc(void) const { return SOAP_NEW(ns1__returnDataRowsPerGroup); }
        /// Dealocate all vectors
        virtual void soap_dealloc(void);
      public:
        /// Constructor with initializations
        ns1__returnDataRowsPerGroup();
        virtual ~ns1__returnDataRowsPerGroup();
        /// Friend allocator used by soap_new_ns1__returnDataRowsPerGroup(struct soap*, int)
        friend SOAP_FMAC1 ns1__returnDataRowsPerGroup * SOAP_FMAC2 soap_instantiate_ns1__returnDataRowsPerGroup(struct soap*, int, const char*, const char*, size_t*);

        //14-Jan-2019 YR BZ#28452
        void ClearAllAllocated();
        void clearItemRowData(ns1__DataItemRow *returnMatrix);
};
#endif

/* emisweb.h:185 */
#ifndef SOAP_TYPE_ns1__ReturnMatrixDataTypePerGroup
#define SOAP_TYPE_ns1__ReturnMatrixDataTypePerGroup (21)
/* complex XSD type 'ns1:ReturnMatrixDataTypePerGroup': */
class SOAP_CMAC ns1__ReturnMatrixDataTypePerGroup {
      public:
        /// Required element 'responseInfoHeader' of XSD type 'ns1:ResponseInfoHeaderType'
        ns1__ResponseInfoHeaderType *responseInfoHeader;
        /// Required element 'returnDataRowsPerGroup' of XSD type 'ns1:returnDataRowsPerGroup'
        std::vector<ns1__returnDataRowsPerGroup *> returnDataRowsPerGroup;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ReturnMatrixDataTypePerGroup
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ReturnMatrixDataTypePerGroup; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ReturnMatrixDataTypePerGroup, default initialized and not managed by a soap context
        virtual ns1__ReturnMatrixDataTypePerGroup *soap_alloc(void) const { return SOAP_NEW(ns1__ReturnMatrixDataTypePerGroup); }
        /// Dealocate all vectors
        virtual void soap_dealloc(void);
      public:
        /// Constructor with initializations
        ns1__ReturnMatrixDataTypePerGroup();
        virtual ~ns1__ReturnMatrixDataTypePerGroup();
        /// Friend allocator used by soap_new_ns1__ReturnMatrixDataTypePerGroup(struct soap*, int)
        friend SOAP_FMAC1 ns1__ReturnMatrixDataTypePerGroup * SOAP_FMAC2 soap_instantiate_ns1__ReturnMatrixDataTypePerGroup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:188 */
#ifndef SOAP_TYPE_ns1__returnDataRowsPerSuperGroup
#define SOAP_TYPE_ns1__returnDataRowsPerSuperGroup (22)
/* complex XSD type 'ns1:returnDataRowsPerSuperGroup': */
class SOAP_CMAC ns1__returnDataRowsPerSuperGroup {
      public:
        /// Required element 'Id' of XSD type 'xsd:unsignedInt'
        unsigned int Id;
        /// Required element 'Name' of XSD type 'xsd:string'
        std::string Name;
        /// Optional element 'returnMatrix' of XSD type 'ns1:DataItemRow'
        std::vector<ns1__DataItemRow *> returnMatrix;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__returnDataRowsPerSuperGroup
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__returnDataRowsPerSuperGroup; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__returnDataRowsPerSuperGroup, default initialized and not managed by a soap context
        virtual ns1__returnDataRowsPerSuperGroup *soap_alloc(void) const { return SOAP_NEW(ns1__returnDataRowsPerSuperGroup); }
        /// Dealocate all vectors
        virtual void soap_dealloc(void);
      public:
        /// Constructor with initializations
        ns1__returnDataRowsPerSuperGroup() : Id(), Name(), returnMatrix(), soap() { }
        virtual ~ns1__returnDataRowsPerSuperGroup() { }
        /// Friend allocator used by soap_new_ns1__returnDataRowsPerSuperGroup(struct soap*, int)
        friend SOAP_FMAC1 ns1__returnDataRowsPerSuperGroup * SOAP_FMAC2 soap_instantiate_ns1__returnDataRowsPerSuperGroup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:191 */
#ifndef SOAP_TYPE_ns1__ReturnMatrixDataTypePerSuperGroup
#define SOAP_TYPE_ns1__ReturnMatrixDataTypePerSuperGroup (23)
/* complex XSD type 'ns1:ReturnMatrixDataTypePerSuperGroup': */
class SOAP_CMAC ns1__ReturnMatrixDataTypePerSuperGroup {
      public:
        /// Required element 'responseInfoHeader' of XSD type 'ns1:ResponseInfoHeaderType'
        ns1__ResponseInfoHeaderType *responseInfoHeader;
        /// Required element 'returnDataRowsPerSuperGroup' of XSD type 'ns1:returnDataRowsPerSuperGroup'
        std::vector<ns1__returnDataRowsPerSuperGroup *> returnDataRowsPerSuperGroup;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ReturnMatrixDataTypePerSuperGroup
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ReturnMatrixDataTypePerSuperGroup; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ReturnMatrixDataTypePerSuperGroup, default initialized and not managed by a soap context
        virtual ns1__ReturnMatrixDataTypePerSuperGroup *soap_alloc(void) const { return SOAP_NEW(ns1__ReturnMatrixDataTypePerSuperGroup); }
        /// Dealocate all vectors
        virtual void soap_dealloc(void);
      public:
        /// Constructor with initializations
        ns1__ReturnMatrixDataTypePerSuperGroup() : responseInfoHeader(), returnDataRowsPerSuperGroup(), soap() { }
        virtual ~ns1__ReturnMatrixDataTypePerSuperGroup() { }
        /// Friend allocator used by soap_new_ns1__ReturnMatrixDataTypePerSuperGroup(struct soap*, int)
        friend SOAP_FMAC1 ns1__ReturnMatrixDataTypePerSuperGroup * SOAP_FMAC2 soap_instantiate_ns1__ReturnMatrixDataTypePerSuperGroup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:194 */
#ifndef SOAP_TYPE_ns1__ReturnMatrixDataTypeBG
#define SOAP_TYPE_ns1__ReturnMatrixDataTypeBG (24)
/* complex XSD type 'ns1:ReturnMatrixDataTypeBG': */
class SOAP_CMAC ns1__ReturnMatrixDataTypeBG {
      public:
        /// Required element 'responseInfoHeader' of XSD type 'ns1:ResponseInfoHeaderType'
        ns1__ResponseInfoHeaderType *responseInfoHeader;
        /// Optional element 'returnMatrix' of XSD type 'ns1:DataItemRow'
        std::vector<ns1__DataItemRow *> returnMatrix;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ReturnMatrixDataTypeBG
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ReturnMatrixDataTypeBG; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ReturnMatrixDataTypeBG, default initialized and not managed by a soap context
        virtual ns1__ReturnMatrixDataTypeBG *soap_alloc(void) const { return SOAP_NEW(ns1__ReturnMatrixDataTypeBG); }
        /// Dealocate all vectors
        virtual void soap_dealloc(void);
      public:
        /// Constructor with initializations
        ns1__ReturnMatrixDataTypeBG();
        virtual ~ns1__ReturnMatrixDataTypeBG();
        /// Friend allocator used by soap_new_ns1__ReturnMatrixDataTypeBG(struct soap*, int)
        friend SOAP_FMAC1 ns1__ReturnMatrixDataTypeBG * SOAP_FMAC2 soap_instantiate_ns1__ReturnMatrixDataTypeBG(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:197 */
#ifndef SOAP_TYPE_ns1__LoginRequestType
#define SOAP_TYPE_ns1__LoginRequestType (25)
/* complex XSD type 'ns1:LoginRequestType': */
class SOAP_CMAC ns1__LoginRequestType {
      public:
        /// Required element 'serviceReqId' of XSD type 'xsd:unsignedInt'
        unsigned int serviceReqId;
        /// Required element 'applicationId' of XSD type 'xsd:string'
        std::string applicationId;
        /// Required element 'name' of XSD type 'xsd:string'
        std::string name;
        /// Required element 'pass' of XSD type 'xsd:string'
        std::string pass;
        /// Required element 'session_id' of XSD type 'xsd:string'
        std::string session_id;
        /// Required element 'ip_address' of XSD type 'xsd:string'
        std::string ip_address;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__LoginRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__LoginRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__LoginRequestType, default initialized and not managed by a soap context
        virtual ns1__LoginRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__LoginRequestType); }
      public:
        /// Constructor with initializations
        ns1__LoginRequestType() : serviceReqId(), applicationId(), name(), pass(), session_id(), ip_address(), soap() { }
        virtual ~ns1__LoginRequestType() { }
        /// Friend allocator used by soap_new_ns1__LoginRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__LoginRequestType * SOAP_FMAC2 soap_instantiate_ns1__LoginRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:200 */
#ifndef SOAP_TYPE_ns1__LoginReturnType
#define SOAP_TYPE_ns1__LoginReturnType (26)
/* complex XSD type 'ns1:LoginReturnType': */
class SOAP_CMAC ns1__LoginReturnType {
      public:
        /// Required element 'responseInfoHeader' of XSD type 'ns1:ResponseInfoHeaderType'
        ns1__ResponseInfoHeaderType *responseInfoHeader;
        /// Required element 'ticket' of XSD type 'xsd:string'
        std::string ticket;
        /// Required element 'loginEnable' of XSD type 'xsd:unsignedInt'
        unsigned int loginEnable;
        /// Required element 'supLevel' of XSD type 'xsd:unsignedInt'
        unsigned int supLevel;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__LoginReturnType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__LoginReturnType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__LoginReturnType, default initialized and not managed by a soap context
        virtual ns1__LoginReturnType *soap_alloc(void) const { return SOAP_NEW(ns1__LoginReturnType); }
      public:
        /// Constructor with initializations
        ns1__LoginReturnType() : responseInfoHeader(), ticket(), loginEnable(), supLevel(), soap() { }
        virtual ~ns1__LoginReturnType() { }
        /// Friend allocator used by soap_new_ns1__LoginReturnType(struct soap*, int)
        friend SOAP_FMAC1 ns1__LoginReturnType * SOAP_FMAC2 soap_instantiate_ns1__LoginReturnType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:203 */
#ifndef SOAP_TYPE_ns1__GenRequestType
#define SOAP_TYPE_ns1__GenRequestType (27)
/* complex XSD type 'ns1:GenRequestType': */
class SOAP_CMAC ns1__GenRequestType {
      public:
        /// Required element 'requestInfoHeader' of XSD type 'ns1:RequestInfoHeaderType'
        ns1__RequestInfoHeaderType *requestInfoHeader;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GenRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GenRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GenRequestType, default initialized and not managed by a soap context
        virtual ns1__GenRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__GenRequestType); }
      public:
        /// Constructor with initializations
        ns1__GenRequestType() : requestInfoHeader(), soap() { }
        virtual ~ns1__GenRequestType() { }
        /// Friend allocator used by soap_new_ns1__GenRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GenRequestType * SOAP_FMAC2 soap_instantiate_ns1__GenRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:206 */
#ifndef SOAP_TYPE_ns1__GroupListDataItemType
#define SOAP_TYPE_ns1__GroupListDataItemType (28)
/* complex XSD type 'ns1:GroupListDataItemType': */
class SOAP_CMAC ns1__GroupListDataItemType {
      public:
        /// Required element 'grpId' of XSD type 'xsd:unsignedInt'
        unsigned int grpId;
        /// Required element 'grpName' of XSD type 'xsd:string'
        std::string grpName;
        /// Required element 'grpNumber' of XSD type 'xsd:string'
        std::string grpNumber;
        /// Required element 'grpEmailEnable' of XSD type 'xsd:unsignedInt'
        unsigned int grpEmailEnable;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GroupListDataItemType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GroupListDataItemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GroupListDataItemType, default initialized and not managed by a soap context
        virtual ns1__GroupListDataItemType *soap_alloc(void) const { return SOAP_NEW(ns1__GroupListDataItemType); }
      public:
        /// Constructor with initializations
        ns1__GroupListDataItemType() : grpId(), grpName(), grpNumber(), grpEmailEnable(), soap() { }
        virtual ~ns1__GroupListDataItemType() { }
        /// Friend allocator used by soap_new_ns1__GroupListDataItemType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GroupListDataItemType * SOAP_FMAC2 soap_instantiate_ns1__GroupListDataItemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:209 */
#ifndef SOAP_TYPE_ns1__GroupListReturnType
#define SOAP_TYPE_ns1__GroupListReturnType (29)
/* complex XSD type 'ns1:GroupListReturnType': */
class SOAP_CMAC ns1__GroupListReturnType {
      public:
        /// Required element 'responseInfoHeader' of XSD type 'ns1:ResponseInfoHeaderType'
        ns1__ResponseInfoHeaderType *responseInfoHeader;
        /// Required element 'returnArray' of XSD type 'ns1:GroupListDataItemType'
        std::vector<ns1__GroupListDataItemType *> returnArray;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GroupListReturnType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GroupListReturnType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GroupListReturnType, default initialized and not managed by a soap context
        virtual ns1__GroupListReturnType *soap_alloc(void) const { return SOAP_NEW(ns1__GroupListReturnType); }
        /// Dealocate all vectors
        virtual void soap_dealloc(void);
      public:
        /// Constructor with initializations
        ns1__GroupListReturnType();
        virtual ~ns1__GroupListReturnType();
        /// Friend allocator used by soap_new_ns1__GroupListReturnType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GroupListReturnType * SOAP_FMAC2 soap_instantiate_ns1__GroupListReturnType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:212 */
#ifndef SOAP_TYPE_ns1__GenListDataItemType
#define SOAP_TYPE_ns1__GenListDataItemType (30)
/* complex XSD type 'ns1:GenListDataItemType': */
class SOAP_CMAC ns1__GenListDataItemType {
      public:
        /// Required element 'Id' of XSD type 'xsd:unsignedInt'
        unsigned int Id;
        /// Required element 'Name' of XSD type 'xsd:string'
        std::string Name;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GenListDataItemType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GenListDataItemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GenListDataItemType, default initialized and not managed by a soap context
        virtual ns1__GenListDataItemType *soap_alloc(void) const { return SOAP_NEW(ns1__GenListDataItemType); }
      public:
        /// Constructor with initializations
        ns1__GenListDataItemType() : Id(), Name(), soap() { }
        virtual ~ns1__GenListDataItemType() { }
        /// Friend allocator used by soap_new_ns1__GenListDataItemType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GenListDataItemType * SOAP_FMAC2 soap_instantiate_ns1__GenListDataItemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:215 */
#ifndef SOAP_TYPE_ns1__GenListReturnType
#define SOAP_TYPE_ns1__GenListReturnType (31)
/* complex XSD type 'ns1:GenListReturnType': */
class SOAP_CMAC ns1__GenListReturnType {
      public:
        /// Required element 'responseInfoHeader' of XSD type 'ns1:ResponseInfoHeaderType'
        ns1__ResponseInfoHeaderType *responseInfoHeader;
        /// Optional element 'returnArray' of XSD type 'ns1:GenListDataItemType'
        std::vector<ns1__GenListDataItemType *> returnArray;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GenListReturnType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GenListReturnType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GenListReturnType, default initialized and not managed by a soap context
        virtual ns1__GenListReturnType *soap_alloc(void) const { return SOAP_NEW(ns1__GenListReturnType); }
        /// Dealocate all vectors
        virtual void soap_dealloc(void);
      public:
        /// Constructor with initializations
        ns1__GenListReturnType();
        virtual ~ns1__GenListReturnType();
        /// Friend allocator used by soap_new_ns1__GenListReturnType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GenListReturnType * SOAP_FMAC2 soap_instantiate_ns1__GenListReturnType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:218 */
#ifndef SOAP_TYPE_ns1__AgentsListDataItemType
#define SOAP_TYPE_ns1__AgentsListDataItemType (32)
/* complex XSD type 'ns1:AgentsListDataItemType': */
class SOAP_CMAC ns1__AgentsListDataItemType {
      public:
        /// Required element 'agentId' of XSD type 'xsd:unsignedInt'
        unsigned int agentId;
        /// Required element 'agentName' of XSD type 'xsd:string'
        std::string agentName;
        /// Required element 'agentNumber' of XSD type 'xsd:string'
        std::string agentNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AgentsListDataItemType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AgentsListDataItemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AgentsListDataItemType, default initialized and not managed by a soap context
        virtual ns1__AgentsListDataItemType *soap_alloc(void) const { return SOAP_NEW(ns1__AgentsListDataItemType); }
      public:
        /// Constructor with initializations
        ns1__AgentsListDataItemType() : agentId(), agentName(), agentNumber(), soap() { }
        virtual ~ns1__AgentsListDataItemType() { }
        /// Friend allocator used by soap_new_ns1__AgentsListDataItemType(struct soap*, int)
        friend SOAP_FMAC1 ns1__AgentsListDataItemType * SOAP_FMAC2 soap_instantiate_ns1__AgentsListDataItemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:221 */
#ifndef SOAP_TYPE_ns1__AgentsListReturnType
#define SOAP_TYPE_ns1__AgentsListReturnType (33)
/* complex XSD type 'ns1:AgentsListReturnType': */
class SOAP_CMAC ns1__AgentsListReturnType {
      public:
        /// Required element 'responseInfoHeader' of XSD type 'ns1:ResponseInfoHeaderType'
        ns1__ResponseInfoHeaderType *responseInfoHeader;
        /// Required element 'returnArray' of XSD type 'ns1:AgentsListDataItemType'
        std::vector<ns1__AgentsListDataItemType *> returnArray;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AgentsListReturnType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AgentsListReturnType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AgentsListReturnType, default initialized and not managed by a soap context
        virtual ns1__AgentsListReturnType *soap_alloc(void) const { return SOAP_NEW(ns1__AgentsListReturnType); }
        /// Dealocate all vectors
        virtual void soap_dealloc(void);
      public:
        /// Constructor with initializations
        ns1__AgentsListReturnType();
        virtual ~ns1__AgentsListReturnType();
        /// Friend allocator used by soap_new_ns1__AgentsListReturnType(struct soap*, int)
        friend SOAP_FMAC1 ns1__AgentsListReturnType * SOAP_FMAC2 soap_instantiate_ns1__AgentsListReturnType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:224 */
#ifndef SOAP_TYPE_ns1__BriefInfoRequestType
#define SOAP_TYPE_ns1__BriefInfoRequestType (34)
/* complex XSD type 'ns1:BriefInfoRequestType': */
class SOAP_CMAC ns1__BriefInfoRequestType {
      public:
        /// Required element 'requestInfoHeader' of XSD type 'ns1:RequestInfoHeaderType'
        ns1__RequestInfoHeaderType *requestInfoHeader;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BriefInfoRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BriefInfoRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BriefInfoRequestType, default initialized and not managed by a soap context
        virtual ns1__BriefInfoRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__BriefInfoRequestType); }
      public:
        /// Constructor with initializations
        ns1__BriefInfoRequestType() : requestInfoHeader(), soap() { }
        virtual ~ns1__BriefInfoRequestType() { }
        /// Friend allocator used by soap_new_ns1__BriefInfoRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BriefInfoRequestType * SOAP_FMAC2 soap_instantiate_ns1__BriefInfoRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:227 */
#ifndef SOAP_TYPE_ns1__DefaultWorkspaceRequestType
#define SOAP_TYPE_ns1__DefaultWorkspaceRequestType (35)
/* complex XSD type 'ns1:DefaultWorkspaceRequestType': */
class SOAP_CMAC ns1__DefaultWorkspaceRequestType {
      public:
        /// Required element 'requestInfoHeader' of XSD type 'ns1:RequestInfoHeaderType'
        ns1__RequestInfoHeaderType *requestInfoHeader;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DefaultWorkspaceRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DefaultWorkspaceRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DefaultWorkspaceRequestType, default initialized and not managed by a soap context
        virtual ns1__DefaultWorkspaceRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__DefaultWorkspaceRequestType); }
      public:
        /// Constructor with initializations
        ns1__DefaultWorkspaceRequestType() : requestInfoHeader(), soap() { }
        virtual ~ns1__DefaultWorkspaceRequestType() { }
        /// Friend allocator used by soap_new_ns1__DefaultWorkspaceRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DefaultWorkspaceRequestType * SOAP_FMAC2 soap_instantiate_ns1__DefaultWorkspaceRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:230 */
#ifndef SOAP_TYPE_ns1__DefaultWorkspaceItemType
#define SOAP_TYPE_ns1__DefaultWorkspaceItemType (36)
/* complex XSD type 'ns1:DefaultWorkspaceItemType': */
class SOAP_CMAC ns1__DefaultWorkspaceItemType {
      public:
        /// Required element 'reportId' of XSD type 'xsd:unsignedInt'
        unsigned int reportId;
        /// Required element 'x' of XSD type 'xsd:short'
        short x;
        /// Required element 'y' of XSD type 'xsd:short'
        short y;
        /// Required element 'width' of XSD type 'xsd:unsignedInt'
        unsigned int width;
        /// Required element 'height' of XSD type 'xsd:unsignedInt'
        unsigned int height;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DefaultWorkspaceItemType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DefaultWorkspaceItemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DefaultWorkspaceItemType, default initialized and not managed by a soap context
        virtual ns1__DefaultWorkspaceItemType *soap_alloc(void) const { return SOAP_NEW(ns1__DefaultWorkspaceItemType); }
      public:
        /// Constructor with initializations
        ns1__DefaultWorkspaceItemType();
        virtual ~ns1__DefaultWorkspaceItemType();
        /// Friend allocator used by soap_new_ns1__DefaultWorkspaceItemType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DefaultWorkspaceItemType * SOAP_FMAC2 soap_instantiate_ns1__DefaultWorkspaceItemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:233 */
#ifndef SOAP_TYPE_ns1__DefaultWorkspaceReturnType
#define SOAP_TYPE_ns1__DefaultWorkspaceReturnType (37)
/* complex XSD type 'ns1:DefaultWorkspaceReturnType': */
class SOAP_CMAC ns1__DefaultWorkspaceReturnType {
      public:
        /// Required element 'responseInfoHeader' of XSD type 'ns1:ResponseInfoHeaderType'
        ns1__ResponseInfoHeaderType *responseInfoHeader;
        /// Optional element 'returnArray' of XSD type 'ns1:DefaultWorkspaceItemType'
        std::vector<ns1__DefaultWorkspaceItemType *> returnArray;
        /// Required element 'fontSize' of XSD type 'xsd:string'
        std::string fontSize;
        /// Required element 'language' of XSD type 'xsd:string'
        std::string language;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DefaultWorkspaceReturnType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DefaultWorkspaceReturnType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DefaultWorkspaceReturnType, default initialized and not managed by a soap context
        virtual ns1__DefaultWorkspaceReturnType *soap_alloc(void) const { return SOAP_NEW(ns1__DefaultWorkspaceReturnType); }
        /// Dealocate all vectors
        virtual void soap_dealloc(void);
      public:
        /// Constructor with initializations
        ns1__DefaultWorkspaceReturnType();
        virtual ~ns1__DefaultWorkspaceReturnType();
        /// Friend allocator used by soap_new_ns1__DefaultWorkspaceReturnType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DefaultWorkspaceReturnType * SOAP_FMAC2 soap_instantiate_ns1__DefaultWorkspaceReturnType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:236 */
#ifndef SOAP_TYPE_ns1__ReportListDataRequestType
#define SOAP_TYPE_ns1__ReportListDataRequestType (38)
/* complex XSD type 'ns1:ReportListDataRequestType': */
class SOAP_CMAC ns1__ReportListDataRequestType {
      public:
        /// Required element 'requestInfoHeader' of XSD type 'ns1:RequestInfoHeaderType'
        ns1__RequestInfoHeaderType *requestInfoHeader;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ReportListDataRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ReportListDataRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ReportListDataRequestType, default initialized and not managed by a soap context
        virtual ns1__ReportListDataRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__ReportListDataRequestType); }
      public:
        /// Constructor with initializations
        ns1__ReportListDataRequestType() : requestInfoHeader(), soap() { }
        virtual ~ns1__ReportListDataRequestType() { }
        /// Friend allocator used by soap_new_ns1__ReportListDataRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ReportListDataRequestType * SOAP_FMAC2 soap_instantiate_ns1__ReportListDataRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:239 */
#ifndef SOAP_TYPE_ns1__ReportListDataItemType
#define SOAP_TYPE_ns1__ReportListDataItemType (39)
/* complex XSD type 'ns1:ReportListDataItemType': */
class SOAP_CMAC ns1__ReportListDataItemType {
      public:
        /// Required element 'reportId' of XSD type 'xsd:unsignedInt'
        unsigned int reportId;
        /// Required element 'isPublic' of XSD type 'xsd:unsignedInt'
        unsigned int isPublic;
        /// Required element 'reportName' of XSD type 'xsd:string'
        std::string reportName;
        /// Required element 'renderName' of XSD type 'xsd:string'
        std::string renderName;
        /// Required element 'params' of XSD type 'xsd:string'
        std::string params;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ReportListDataItemType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ReportListDataItemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ReportListDataItemType, default initialized and not managed by a soap context
        virtual ns1__ReportListDataItemType *soap_alloc(void) const { return SOAP_NEW(ns1__ReportListDataItemType); }
      public:
        /// Constructor with initializations
        ns1__ReportListDataItemType();
        virtual ~ns1__ReportListDataItemType();
        /// Friend allocator used by soap_new_ns1__ReportListDataItemType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ReportListDataItemType * SOAP_FMAC2 soap_instantiate_ns1__ReportListDataItemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:242 */
#ifndef SOAP_TYPE_ns1__ReportListDataReturnType
#define SOAP_TYPE_ns1__ReportListDataReturnType (40)
/* complex XSD type 'ns1:ReportListDataReturnType': */
class SOAP_CMAC ns1__ReportListDataReturnType {
      public:
        /// Required element 'responseInfoHeader' of XSD type 'ns1:ResponseInfoHeaderType'
        ns1__ResponseInfoHeaderType *responseInfoHeader;
        /// Optional element 'returnArray' of XSD type 'ns1:ReportListDataItemType'
        std::vector<ns1__ReportListDataItemType *> returnArray;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ReportListDataReturnType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ReportListDataReturnType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ReportListDataReturnType, default initialized and not managed by a soap context
        virtual ns1__ReportListDataReturnType *soap_alloc(void) const { return SOAP_NEW(ns1__ReportListDataReturnType); }
        /// Dealocate all vectors
        virtual void soap_dealloc(void);
      public:
        /// Constructor with initializations
        ns1__ReportListDataReturnType();
        virtual ~ns1__ReportListDataReturnType();
        /// Friend allocator used by soap_new_ns1__ReportListDataReturnType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ReportListDataReturnType * SOAP_FMAC2 soap_instantiate_ns1__ReportListDataReturnType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:245 */
#ifndef SOAP_TYPE_ns1__DNISListDataItemType
#define SOAP_TYPE_ns1__DNISListDataItemType (41)
/* complex XSD type 'ns1:DNISListDataItemType': */
class SOAP_CMAC ns1__DNISListDataItemType {
      public:
        /// Required element 'dnisId' of XSD type 'xsd:unsignedInt'
        unsigned int dnisId;
        /// Required element 'dnisName' of XSD type 'xsd:string'
        std::string dnisName;
        /// Required element 'dnisNumber' of XSD type 'xsd:string'
        std::string dnisNumber;
        /// Required element 'dnisType' of XSD type 'xsd:unsignedInt'
        unsigned int dnisType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DNISListDataItemType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DNISListDataItemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DNISListDataItemType, default initialized and not managed by a soap context
        virtual ns1__DNISListDataItemType *soap_alloc(void) const { return SOAP_NEW(ns1__DNISListDataItemType); }
      public:
        /// Constructor with initializations
        ns1__DNISListDataItemType();
        virtual ~ns1__DNISListDataItemType();
        /// Friend allocator used by soap_new_ns1__DNISListDataItemType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DNISListDataItemType * SOAP_FMAC2 soap_instantiate_ns1__DNISListDataItemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:248 */
#ifndef SOAP_TYPE_ns1__DNISListReturnType
#define SOAP_TYPE_ns1__DNISListReturnType (42)
/* complex XSD type 'ns1:DNISListReturnType': */
class SOAP_CMAC ns1__DNISListReturnType {
      public:
        /// Required element 'responseInfoHeader' of XSD type 'ns1:ResponseInfoHeaderType'
        ns1__ResponseInfoHeaderType *responseInfoHeader;
        /// Required element 'returnArray' of XSD type 'ns1:DNISListDataItemType'
        std::vector<ns1__DNISListDataItemType *> returnArray;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DNISListReturnType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DNISListReturnType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DNISListReturnType, default initialized and not managed by a soap context
        virtual ns1__DNISListReturnType *soap_alloc(void) const { return SOAP_NEW(ns1__DNISListReturnType); }
        /// Dealocate all vectors
        virtual void soap_dealloc(void);
      public:
        /// Constructor with initializations
        ns1__DNISListReturnType();
        virtual ~ns1__DNISListReturnType();
        /// Friend allocator used by soap_new_ns1__DNISListReturnType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DNISListReturnType * SOAP_FMAC2 soap_instantiate_ns1__DNISListReturnType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:251 */
#ifndef SOAP_TYPE_ns1__BriefDNISInfoRequestType
#define SOAP_TYPE_ns1__BriefDNISInfoRequestType (43)
/* complex XSD type 'ns1:BriefDNISInfoRequestType': */
class SOAP_CMAC ns1__BriefDNISInfoRequestType {
      public:
        /// Required element 'requestInfoHeader' of XSD type 'ns1:RequestInfoHeaderType'
        ns1__RequestInfoHeaderType *requestInfoHeader;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BriefDNISInfoRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BriefDNISInfoRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BriefDNISInfoRequestType, default initialized and not managed by a soap context
        virtual ns1__BriefDNISInfoRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__BriefDNISInfoRequestType); }
      public:
        /// Constructor with initializations
        ns1__BriefDNISInfoRequestType() : requestInfoHeader(), soap() { }
        virtual ~ns1__BriefDNISInfoRequestType() { }
        /// Friend allocator used by soap_new_ns1__BriefDNISInfoRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BriefDNISInfoRequestType * SOAP_FMAC2 soap_instantiate_ns1__BriefDNISInfoRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:254 */
#ifndef SOAP_TYPE_ns1__SuperGroupListDataItemType
#define SOAP_TYPE_ns1__SuperGroupListDataItemType (44)
/* complex XSD type 'ns1:SuperGroupListDataItemType': */
class SOAP_CMAC ns1__SuperGroupListDataItemType {
      public:
        /// Required element 'superGroupId' of XSD type 'xsd:unsignedInt'
        unsigned int superGroupId;
        /// Required element 'superGroupName' of XSD type 'xsd:string'
        std::string superGroupName;
        /// Optional element 'returnArray' of XSD type 'ns1:GroupListDataItemType'
        std::vector<ns1__GroupListDataItemType *> returnArray;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SuperGroupListDataItemType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SuperGroupListDataItemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SuperGroupListDataItemType, default initialized and not managed by a soap context
        virtual ns1__SuperGroupListDataItemType *soap_alloc(void) const { return SOAP_NEW(ns1__SuperGroupListDataItemType); }
        /// Dealocate all vectors  1-Jun-2021 YR BZ#54502
        virtual void soap_dealloc(void);
      public:
        /// Constructor with initializations
        ns1__SuperGroupListDataItemType() : superGroupId(), superGroupName(), returnArray(), soap() { }
        virtual ~ns1__SuperGroupListDataItemType() { }
        /// Friend allocator used by soap_new_ns1__SuperGroupListDataItemType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SuperGroupListDataItemType * SOAP_FMAC2 soap_instantiate_ns1__SuperGroupListDataItemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:257 */
#ifndef SOAP_TYPE_ns1__SuperGroupListReturnType
#define SOAP_TYPE_ns1__SuperGroupListReturnType (45)
/* complex XSD type 'ns1:SuperGroupListReturnType': */
class SOAP_CMAC ns1__SuperGroupListReturnType {
      public:
        /// Required element 'responseInfoHeader' of XSD type 'ns1:ResponseInfoHeaderType'
        ns1__ResponseInfoHeaderType *responseInfoHeader;
        /// Required element 'returnArray' of XSD type 'ns1:SuperGroupListDataItemType'
        std::vector<ns1__SuperGroupListDataItemType *> returnArray;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SuperGroupListReturnType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SuperGroupListReturnType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SuperGroupListReturnType, default initialized and not managed by a soap context
        virtual ns1__SuperGroupListReturnType *soap_alloc(void) const { return SOAP_NEW(ns1__SuperGroupListReturnType); }
        /// Dealocate all vectors  1-Jun-2021 YR BZ#54502
        virtual void soap_dealloc(void);
      public:
        /// Constructor with initializations
        ns1__SuperGroupListReturnType() : responseInfoHeader(), returnArray(), soap() { }
        virtual ~ns1__SuperGroupListReturnType() { }
        /// Friend allocator used by soap_new_ns1__SuperGroupListReturnType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SuperGroupListReturnType * SOAP_FMAC2 soap_instantiate_ns1__SuperGroupListReturnType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:260 */
#ifndef SOAP_TYPE_ns1__SaveWorkspaseRequestType
#define SOAP_TYPE_ns1__SaveWorkspaseRequestType (46)
/* complex XSD type 'ns1:SaveWorkspaseRequestType': */
class SOAP_CMAC ns1__SaveWorkspaseRequestType {
      public:
        /// Required element 'requestInfoHeader' of XSD type 'ns1:RequestInfoHeaderType'
        ns1__RequestInfoHeaderType *requestInfoHeader;
        /// Optional element 'RequestArray' of XSD type 'ns1:DefaultWorkspaceItemType'
        std::vector<ns1__DefaultWorkspaceItemType *> RequestArray;
        /// Required element 'fontSize' of XSD type 'xsd:string'
        std::string fontSize;
        /// Required element 'language' of XSD type 'xsd:string'
        std::string language;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SaveWorkspaseRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SaveWorkspaseRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SaveWorkspaseRequestType, default initialized and not managed by a soap context
        virtual ns1__SaveWorkspaseRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__SaveWorkspaseRequestType); }
        /// Dealocate all vectors
        virtual void soap_dealloc(void);
      public:
        /// Constructor with initializations
        ns1__SaveWorkspaseRequestType();
        virtual ~ns1__SaveWorkspaseRequestType();
        /// Friend allocator used by soap_new_ns1__SaveWorkspaseRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SaveWorkspaseRequestType * SOAP_FMAC2 soap_instantiate_ns1__SaveWorkspaseRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:263 */
#ifndef SOAP_TYPE_ns1__RequestSaveReportType
#define SOAP_TYPE_ns1__RequestSaveReportType (47)
/* complex XSD type 'ns1:RequestSaveReportType': */
class SOAP_CMAC ns1__RequestSaveReportType {
      public:
        /// Required element 'requestInfoHeader' of XSD type 'ns1:RequestInfoHeaderType'
        ns1__RequestInfoHeaderType *requestInfoHeader;
        /// Required element 'RequestItem' of XSD type 'ns1:ReportListDataItemType'
        ns1__ReportListDataItemType *RequestItem;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RequestSaveReportType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__RequestSaveReportType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RequestSaveReportType, default initialized and not managed by a soap context
        virtual ns1__RequestSaveReportType *soap_alloc(void) const { return SOAP_NEW(ns1__RequestSaveReportType); }
      public:
        /// Constructor with initializations
        ns1__RequestSaveReportType() : requestInfoHeader(), RequestItem(), soap() { }
        virtual ~ns1__RequestSaveReportType() { }
        /// Friend allocator used by soap_new_ns1__RequestSaveReportType(struct soap*, int)
        friend SOAP_FMAC1 ns1__RequestSaveReportType * SOAP_FMAC2 soap_instantiate_ns1__RequestSaveReportType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:266 */
#ifndef SOAP_TYPE_ns1__RequestDeleteReportType
#define SOAP_TYPE_ns1__RequestDeleteReportType (48)
/* complex XSD type 'ns1:RequestDeleteReportType': */
class SOAP_CMAC ns1__RequestDeleteReportType {
      public:
        /// Required element 'requestInfoHeader' of XSD type 'ns1:RequestInfoHeaderType'
        ns1__RequestInfoHeaderType *requestInfoHeader;
        /// Required element 'reportId' of XSD type 'xsd:unsignedInt'
        unsigned int reportId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RequestDeleteReportType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__RequestDeleteReportType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RequestDeleteReportType, default initialized and not managed by a soap context
        virtual ns1__RequestDeleteReportType *soap_alloc(void) const { return SOAP_NEW(ns1__RequestDeleteReportType); }
      public:
        /// Constructor with initializations
        ns1__RequestDeleteReportType() : requestInfoHeader(), reportId(), soap() { }
        virtual ~ns1__RequestDeleteReportType() { }
        /// Friend allocator used by soap_new_ns1__RequestDeleteReportType(struct soap*, int)
        friend SOAP_FMAC1 ns1__RequestDeleteReportType * SOAP_FMAC2 soap_instantiate_ns1__RequestDeleteReportType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:269 */
#ifndef SOAP_TYPE_ns1__LoginManagerRequestType
#define SOAP_TYPE_ns1__LoginManagerRequestType (49)
/* complex XSD type 'ns1:LoginManagerRequestType': */
class SOAP_CMAC ns1__LoginManagerRequestType {
      public:
        /// Required element 'requestInfoHeader' of XSD type 'ns1:RequestInfoHeaderType'
        ns1__RequestInfoHeaderType *requestInfoHeader;
        /// Required element 'Id' of XSD type 'xsd:unsignedInt'
        unsigned int Id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__LoginManagerRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__LoginManagerRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__LoginManagerRequestType, default initialized and not managed by a soap context
        virtual ns1__LoginManagerRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__LoginManagerRequestType); }
      public:
        /// Constructor with initializations
        ns1__LoginManagerRequestType() : requestInfoHeader(), Id(), soap() { }
        virtual ~ns1__LoginManagerRequestType() { }
        /// Friend allocator used by soap_new_ns1__LoginManagerRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__LoginManagerRequestType * SOAP_FMAC2 soap_instantiate_ns1__LoginManagerRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:272 */
#ifndef SOAP_TYPE_ns1__ApplicationRegisterRequestType
#define SOAP_TYPE_ns1__ApplicationRegisterRequestType (50)
/* complex XSD type 'ns1:ApplicationRegisterRequestType': */
class SOAP_CMAC ns1__ApplicationRegisterRequestType {
      public:
        /// Required element 'serviceReqId' of XSD type 'xsd:unsignedInt'
        unsigned int serviceReqId;
        /// Required element 'applicationId' of XSD type 'xsd:string'
        std::string applicationId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ApplicationRegisterRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ApplicationRegisterRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ApplicationRegisterRequestType, default initialized and not managed by a soap context
        virtual ns1__ApplicationRegisterRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__ApplicationRegisterRequestType); }
      public:
        /// Constructor with initializations
        ns1__ApplicationRegisterRequestType() : serviceReqId(), applicationId(), soap() { }
        virtual ~ns1__ApplicationRegisterRequestType() { }
        /// Friend allocator used by soap_new_ns1__ApplicationRegisterRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ApplicationRegisterRequestType * SOAP_FMAC2 soap_instantiate_ns1__ApplicationRegisterRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:275 */
#ifndef SOAP_TYPE_ns1__ApplicationKeepAliveRequestType
#define SOAP_TYPE_ns1__ApplicationKeepAliveRequestType (51)
/* complex XSD type 'ns1:ApplicationKeepAliveRequestType': */
class SOAP_CMAC ns1__ApplicationKeepAliveRequestType {
      public:
        /// Required element 'serviceReqId' of XSD type 'xsd:unsignedInt'
        unsigned int serviceReqId;
        /// Required element 'applicationId' of XSD type 'xsd:string'
        std::string applicationId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ApplicationKeepAliveRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ApplicationKeepAliveRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ApplicationKeepAliveRequestType, default initialized and not managed by a soap context
        virtual ns1__ApplicationKeepAliveRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__ApplicationKeepAliveRequestType); }
      public:
        /// Constructor with initializations
        ns1__ApplicationKeepAliveRequestType() : serviceReqId(), applicationId(), soap() { }
        virtual ~ns1__ApplicationKeepAliveRequestType() { }
        /// Friend allocator used by soap_new_ns1__ApplicationKeepAliveRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ApplicationKeepAliveRequestType * SOAP_FMAC2 soap_instantiate_ns1__ApplicationKeepAliveRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:278 */
#ifndef SOAP_TYPE_ns1__ApplicationReturnType
#define SOAP_TYPE_ns1__ApplicationReturnType (52)
/* complex XSD type 'ns1:ApplicationReturnType': */
class SOAP_CMAC ns1__ApplicationReturnType {
      public:
        /// Required element 'responseInfoHeader' of XSD type 'ns1:ResponseInfoHeaderType'
        ns1__ResponseInfoHeaderType *responseInfoHeader;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ApplicationReturnType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ApplicationReturnType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ApplicationReturnType, default initialized and not managed by a soap context
        virtual ns1__ApplicationReturnType *soap_alloc(void) const { return SOAP_NEW(ns1__ApplicationReturnType); }
      public:
        /// Constructor with initializations
        ns1__ApplicationReturnType() : responseInfoHeader(), soap() { }
        virtual ~ns1__ApplicationReturnType() { }
        /// Friend allocator used by soap_new_ns1__ApplicationReturnType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ApplicationReturnType * SOAP_FMAC2 soap_instantiate_ns1__ApplicationReturnType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:281 */
#ifndef SOAP_TYPE_ns1__StatRequestType
#define SOAP_TYPE_ns1__StatRequestType (53)
/* complex XSD type 'ns1:StatRequestType': */
class SOAP_CMAC ns1__StatRequestType {
      public:
        /// Required element 'serviceReqId' of XSD type 'xsd:unsignedInt'
        unsigned int serviceReqId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__StatRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__StatRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__StatRequestType, default initialized and not managed by a soap context
        virtual ns1__StatRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__StatRequestType); }
      public:
        /// Constructor with initializations
        ns1__StatRequestType() : serviceReqId(), soap() { }
        virtual ~ns1__StatRequestType() { }
        /// Friend allocator used by soap_new_ns1__StatRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__StatRequestType * SOAP_FMAC2 soap_instantiate_ns1__StatRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:284 */
#ifndef SOAP_TYPE_ns1__StatItemType
#define SOAP_TYPE_ns1__StatItemType (54)
/* complex XSD type 'ns1:StatItemType': */
class SOAP_CMAC ns1__StatItemType {
      public:
        /// Required element 'ipAddress' of XSD type 'xsd:string'
        std::string ipAddress;
        /// Required element 'applicationId' of XSD type 'xsd:string'
        std::string applicationId;
        /// Required element 'lastKeepAliveSecAgo' of XSD type 'xsd:unsignedInt'
        unsigned int lastKeepAliveSecAgo;
        /// Required element 'numOfVisors' of XSD type 'xsd:unsignedInt'
        unsigned int numOfVisors;
        /// Required element 'numOfMonitors' of XSD type 'xsd:unsignedInt'
        unsigned int numOfMonitors;
        /// Required element 'numOfWebVisors' of XSD type 'xsd:unsignedInt'
        unsigned int numOfWebVisors;
        /// Required element 'totalNumberOfSoapConnections' of XSD type 'xsd:unsignedInt'
        unsigned int totalNumberOfSoapConnections;
        /// Required element 'numberOfSoapConnectionsSinceLastStatRequest' of XSD type 'xsd:unsignedInt'
        unsigned int numberOfSoapConnectionsSinceLastStatRequest;
        /// Required element 'CurrentNumberOfSoapConnections' of XSD type 'xsd:unsignedInt'
        unsigned int CurrentNumberOfSoapConnections;
        /// Required element 'LastError' of XSD type 'xsd:unsignedInt'
        unsigned int LastError;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__StatItemType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__StatItemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__StatItemType, default initialized and not managed by a soap context
        virtual ns1__StatItemType *soap_alloc(void) const { return SOAP_NEW(ns1__StatItemType); }
      public:
        /// Constructor with initializations
        ns1__StatItemType() : ipAddress(), applicationId(), lastKeepAliveSecAgo(), numOfVisors(), numOfMonitors(), numOfWebVisors(), totalNumberOfSoapConnections(), numberOfSoapConnectionsSinceLastStatRequest(), CurrentNumberOfSoapConnections(), LastError(), soap() { }
        virtual ~ns1__StatItemType() { }
        /// Friend allocator used by soap_new_ns1__StatItemType(struct soap*, int)
        friend SOAP_FMAC1 ns1__StatItemType * SOAP_FMAC2 soap_instantiate_ns1__StatItemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:287 */
#ifndef SOAP_TYPE_ns1__StatReturnType
#define SOAP_TYPE_ns1__StatReturnType (55)
/* complex XSD type 'ns1:StatReturnType': */
class SOAP_CMAC ns1__StatReturnType {
      public:
        /// Required element 'responseInfoHeader' of XSD type 'ns1:ResponseInfoHeaderType'
        ns1__ResponseInfoHeaderType *responseInfoHeader;
        /// Optional element 'returnStatArray' of XSD type 'ns1:StatItemType'
        std::vector<ns1__StatItemType *> returnStatArray;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__StatReturnType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__StatReturnType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__StatReturnType, default initialized and not managed by a soap context
        virtual ns1__StatReturnType *soap_alloc(void) const { return SOAP_NEW(ns1__StatReturnType); }
        /// Dealocate all vectors
        virtual void soap_dealloc(void);
      public:
        /// Constructor with initializations
        ns1__StatReturnType();
        //ns1__StatReturnType() : responseInfoHeader(), returnStatArray(), soap() { }
        virtual ~ns1__StatReturnType();
        /// Friend allocator used by soap_new_ns1__StatReturnType(struct soap*, int)
        friend SOAP_FMAC1 ns1__StatReturnType * SOAP_FMAC2 soap_instantiate_ns1__StatReturnType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:1954 */
#ifndef SOAP_TYPE___ns1__GroupDetailFullInfo
#define SOAP_TYPE___ns1__GroupDetailFullInfo (93)
/* Wrapper: */
struct SOAP_CMAC __ns1__GroupDetailFullInfo {
      public:
        /** Optional element 'ns1:RequestGroupDetailFullInfo' of XSD type 'ns1:GenInfoRequestType' */
        ns1__GenInfoRequestType *ns1__RequestGroupDetailFullInfo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GroupDetailFullInfo */
        int soap_type() const { return SOAP_TYPE___ns1__GroupDetailFullInfo; }
        /** Constructor with member initializations */
        __ns1__GroupDetailFullInfo() : ns1__RequestGroupDetailFullInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GroupDetailFullInfo * SOAP_FMAC2 soap_instantiate___ns1__GroupDetailFullInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:2024 */
#ifndef SOAP_TYPE___ns1__GroupQueInfo
#define SOAP_TYPE___ns1__GroupQueInfo (95)
/* Wrapper: */
struct SOAP_CMAC __ns1__GroupQueInfo {
      public:
        /** Optional element 'ns1:RequestGroupQueInfo' of XSD type 'ns1:GenInfoRequestType' */
        ns1__GenInfoRequestType *ns1__RequestGroupQueInfo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GroupQueInfo */
        int soap_type() const { return SOAP_TYPE___ns1__GroupQueInfo; }
        /** Constructor with member initializations */
        __ns1__GroupQueInfo() : ns1__RequestGroupQueInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GroupQueInfo * SOAP_FMAC2 soap_instantiate___ns1__GroupQueInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:2094 */
#ifndef SOAP_TYPE___ns1__GroupAgentsInfo
#define SOAP_TYPE___ns1__GroupAgentsInfo (97)
/* Wrapper: */
struct SOAP_CMAC __ns1__GroupAgentsInfo {
      public:
        /** Optional element 'ns1:RequestGroupAgentsInfo' of XSD type 'ns1:GenInfoRequestType' */
        ns1__GenInfoRequestType *ns1__RequestGroupAgentsInfo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GroupAgentsInfo */
        int soap_type() const { return SOAP_TYPE___ns1__GroupAgentsInfo; }
        /** Constructor with member initializations */
        __ns1__GroupAgentsInfo() : ns1__RequestGroupAgentsInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GroupAgentsInfo * SOAP_FMAC2 soap_instantiate___ns1__GroupAgentsInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:2164 */
#ifndef SOAP_TYPE___ns1__GroupAbndInfo
#define SOAP_TYPE___ns1__GroupAbndInfo (99)
/* Wrapper: */
struct SOAP_CMAC __ns1__GroupAbndInfo {
      public:
        /** Optional element 'ns1:RequestGroupAbndInfo' of XSD type 'ns1:GenInfoRequestType' */
        ns1__GenInfoRequestType *ns1__RequestGroupAbndInfo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GroupAbndInfo */
        int soap_type() const { return SOAP_TYPE___ns1__GroupAbndInfo; }
        /** Constructor with member initializations */
        __ns1__GroupAbndInfo() : ns1__RequestGroupAbndInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GroupAbndInfo * SOAP_FMAC2 soap_instantiate___ns1__GroupAbndInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:2234 */
#ifndef SOAP_TYPE___ns1__GroupIntOvfInfo
#define SOAP_TYPE___ns1__GroupIntOvfInfo (101)
/* Wrapper: */
struct SOAP_CMAC __ns1__GroupIntOvfInfo {
      public:
        /** Optional element 'ns1:RequestGroupIntOvfInfo' of XSD type 'ns1:GenInfoRequestType' */
        ns1__GenInfoRequestType *ns1__RequestGroupIntOvfInfo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GroupIntOvfInfo */
        int soap_type() const { return SOAP_TYPE___ns1__GroupIntOvfInfo; }
        /** Constructor with member initializations */
        __ns1__GroupIntOvfInfo() : ns1__RequestGroupIntOvfInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GroupIntOvfInfo * SOAP_FMAC2 soap_instantiate___ns1__GroupIntOvfInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:2304 */
#ifndef SOAP_TYPE___ns1__GroupShiftInfo
#define SOAP_TYPE___ns1__GroupShiftInfo (103)
/* Wrapper: */
struct SOAP_CMAC __ns1__GroupShiftInfo {
      public:
        /** Optional element 'ns1:RequestGroupShiftInfo' of XSD type 'ns1:GenInfoRequestType' */
        ns1__GenInfoRequestType *ns1__RequestGroupShiftInfo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GroupShiftInfo */
        int soap_type() const { return SOAP_TYPE___ns1__GroupShiftInfo; }
        /** Constructor with member initializations */
        __ns1__GroupShiftInfo() : ns1__RequestGroupShiftInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GroupShiftInfo * SOAP_FMAC2 soap_instantiate___ns1__GroupShiftInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:2374 */
#ifndef SOAP_TYPE___ns1__GroupGeneralInfo
#define SOAP_TYPE___ns1__GroupGeneralInfo (105)
/* Wrapper: */
struct SOAP_CMAC __ns1__GroupGeneralInfo {
      public:
        /** Optional element 'ns1:RequestGroupGeneralInfo' of XSD type 'ns1:GenInfoRequestType' */
        ns1__GenInfoRequestType *ns1__RequestGroupGeneralInfo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GroupGeneralInfo */
        int soap_type() const { return SOAP_TYPE___ns1__GroupGeneralInfo; }
        /** Constructor with member initializations */
        __ns1__GroupGeneralInfo() : ns1__RequestGroupGeneralInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GroupGeneralInfo * SOAP_FMAC2 soap_instantiate___ns1__GroupGeneralInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:2444 */
#ifndef SOAP_TYPE___ns1__GroupPeriodInfo
#define SOAP_TYPE___ns1__GroupPeriodInfo (107)
/* Wrapper: */
struct SOAP_CMAC __ns1__GroupPeriodInfo {
      public:
        /** Optional element 'ns1:RequestGroupPeriodInfo' of XSD type 'ns1:GenInfoRequestType' */
        ns1__GenInfoRequestType *ns1__RequestGroupPeriodInfo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GroupPeriodInfo */
        int soap_type() const { return SOAP_TYPE___ns1__GroupPeriodInfo; }
        /** Constructor with member initializations */
        __ns1__GroupPeriodInfo() : ns1__RequestGroupPeriodInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GroupPeriodInfo * SOAP_FMAC2 soap_instantiate___ns1__GroupPeriodInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:2514 */
#ifndef SOAP_TYPE___ns1__IvrApplInfo
#define SOAP_TYPE___ns1__IvrApplInfo (109)
/* Wrapper: */
struct SOAP_CMAC __ns1__IvrApplInfo {
      public:
        /** Optional element 'ns1:RequestIvrApplInfo' of XSD type 'ns1:GenInfoRequestType' */
        ns1__GenInfoRequestType *ns1__RequestIvrApplInfo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__IvrApplInfo */
        int soap_type() const { return SOAP_TYPE___ns1__IvrApplInfo; }
        /** Constructor with member initializations */
        __ns1__IvrApplInfo() : ns1__RequestIvrApplInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__IvrApplInfo * SOAP_FMAC2 soap_instantiate___ns1__IvrApplInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:2584 */
#ifndef SOAP_TYPE___ns1__IvrPortInfo
#define SOAP_TYPE___ns1__IvrPortInfo (111)
/* Wrapper: */
struct SOAP_CMAC __ns1__IvrPortInfo {
      public:
        /** Optional element 'ns1:RequestIvrPortInfo' of XSD type 'ns1:GenInfoRequestType' */
        ns1__GenInfoRequestType *ns1__RequestIvrPortInfo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__IvrPortInfo */
        int soap_type() const { return SOAP_TYPE___ns1__IvrPortInfo; }
        /** Constructor with member initializations */
        __ns1__IvrPortInfo() : ns1__RequestIvrPortInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__IvrPortInfo * SOAP_FMAC2 soap_instantiate___ns1__IvrPortInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:2654 */
#ifndef SOAP_TYPE___ns1__IvrGrpInfo
#define SOAP_TYPE___ns1__IvrGrpInfo (113)
/* Wrapper: */
struct SOAP_CMAC __ns1__IvrGrpInfo {
      public:
        /** Optional element 'ns1:RequestIvrGrpInfo' of XSD type 'ns1:GenInfoRequestType' */
        ns1__GenInfoRequestType *ns1__RequestIvrGrpInfo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__IvrGrpInfo */
        int soap_type() const { return SOAP_TYPE___ns1__IvrGrpInfo; }
        /** Constructor with member initializations */
        __ns1__IvrGrpInfo() : ns1__RequestIvrGrpInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__IvrGrpInfo * SOAP_FMAC2 soap_instantiate___ns1__IvrGrpInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:2724 */
#ifndef SOAP_TYPE___ns1__MailboxInfo
#define SOAP_TYPE___ns1__MailboxInfo (115)
/* Wrapper: */
struct SOAP_CMAC __ns1__MailboxInfo {
      public:
        /** Optional element 'ns1:RequestMailboxInfo' of XSD type 'ns1:GenInfoRequestType' */
        ns1__GenInfoRequestType *ns1__RequestMailboxInfo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__MailboxInfo */
        int soap_type() const { return SOAP_TYPE___ns1__MailboxInfo; }
        /** Constructor with member initializations */
        __ns1__MailboxInfo() : ns1__RequestMailboxInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__MailboxInfo * SOAP_FMAC2 soap_instantiate___ns1__MailboxInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:2794 */
#ifndef SOAP_TYPE___ns1__SuperGroupInfo
#define SOAP_TYPE___ns1__SuperGroupInfo (117)
/* Wrapper: */
struct SOAP_CMAC __ns1__SuperGroupInfo {
      public:
        /** Optional element 'ns1:RequestSuperGroupInfo' of XSD type 'ns1:GenInfoRequestType' */
        ns1__GenInfoRequestType *ns1__RequestSuperGroupInfo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SuperGroupInfo */
        int soap_type() const { return SOAP_TYPE___ns1__SuperGroupInfo; }
        /** Constructor with member initializations */
        __ns1__SuperGroupInfo() : ns1__RequestSuperGroupInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SuperGroupInfo * SOAP_FMAC2 soap_instantiate___ns1__SuperGroupInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:2864 */
#ifndef SOAP_TYPE___ns1__SuperGroupList
#define SOAP_TYPE___ns1__SuperGroupList (121)
/* Wrapper: */
struct SOAP_CMAC __ns1__SuperGroupList {
      public:
        /** Optional element 'ns1:RequestSuperGroupList' of XSD type 'ns1:GenRequestType' */
        ns1__GenRequestType *ns1__RequestSuperGroupList;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SuperGroupList */
        int soap_type() const { return SOAP_TYPE___ns1__SuperGroupList; }
        /** Constructor with member initializations */
        __ns1__SuperGroupList() : ns1__RequestSuperGroupList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SuperGroupList * SOAP_FMAC2 soap_instantiate___ns1__SuperGroupList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:2934 */
#ifndef SOAP_TYPE___ns1__UserLogin
#define SOAP_TYPE___ns1__UserLogin (125)
/* Wrapper: */
struct SOAP_CMAC __ns1__UserLogin {
      public:
        /** Optional element 'ns1:RequestUserLogin' of XSD type 'ns1:LoginRequestType' */
        ns1__LoginRequestType *ns1__RequestUserLogin;
      public:
        /** Return unique type id SOAP_TYPE___ns1__UserLogin */
        int soap_type() const { return SOAP_TYPE___ns1__UserLogin; }
        /** Constructor with member initializations */
        __ns1__UserLogin() : ns1__RequestUserLogin() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__UserLogin * SOAP_FMAC2 soap_instantiate___ns1__UserLogin(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:3004 */
#ifndef SOAP_TYPE___ns1__UserLogout
#define SOAP_TYPE___ns1__UserLogout (128)
/* Wrapper: */
struct SOAP_CMAC __ns1__UserLogout {
      public:
        /** Optional element 'ns1:RequestUserLogout' of XSD type 'ns1:GenRequestType' */
        ns1__GenRequestType *ns1__RequestUserLogout;
      public:
        /** Return unique type id SOAP_TYPE___ns1__UserLogout */
        int soap_type() const { return SOAP_TYPE___ns1__UserLogout; }
        /** Constructor with member initializations */
        __ns1__UserLogout() : ns1__RequestUserLogout() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__UserLogout * SOAP_FMAC2 soap_instantiate___ns1__UserLogout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:3074 */
#ifndef SOAP_TYPE___ns1__GroupList
#define SOAP_TYPE___ns1__GroupList (131)
/* Wrapper: */
struct SOAP_CMAC __ns1__GroupList {
      public:
        /** Optional element 'ns1:RequestGroupList' of XSD type 'ns1:GenRequestType' */
        ns1__GenRequestType *ns1__RequestGroupList;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GroupList */
        int soap_type() const { return SOAP_TYPE___ns1__GroupList; }
        /** Constructor with member initializations */
        __ns1__GroupList() : ns1__RequestGroupList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GroupList * SOAP_FMAC2 soap_instantiate___ns1__GroupList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:3144 */
#ifndef SOAP_TYPE___ns1__IvrPortGroupList
#define SOAP_TYPE___ns1__IvrPortGroupList (134)
/* Wrapper: */
struct SOAP_CMAC __ns1__IvrPortGroupList {
      public:
        /** Optional element 'ns1:RequestIvrPortGroupList' of XSD type 'ns1:GenRequestType' */
        ns1__GenRequestType *ns1__RequestIvrPortGroupList;
      public:
        /** Return unique type id SOAP_TYPE___ns1__IvrPortGroupList */
        int soap_type() const { return SOAP_TYPE___ns1__IvrPortGroupList; }
        /** Constructor with member initializations */
        __ns1__IvrPortGroupList() : ns1__RequestIvrPortGroupList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__IvrPortGroupList * SOAP_FMAC2 soap_instantiate___ns1__IvrPortGroupList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:3214 */
#ifndef SOAP_TYPE___ns1__IvrAppList
#define SOAP_TYPE___ns1__IvrAppList (136)
/* Wrapper: */
struct SOAP_CMAC __ns1__IvrAppList {
      public:
        /** Optional element 'ns1:RequestIvrAppList' of XSD type 'ns1:GenRequestType' */
        ns1__GenRequestType *ns1__RequestIvrAppList;
      public:
        /** Return unique type id SOAP_TYPE___ns1__IvrAppList */
        int soap_type() const { return SOAP_TYPE___ns1__IvrAppList; }
        /** Constructor with member initializations */
        __ns1__IvrAppList() : ns1__RequestIvrAppList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__IvrAppList * SOAP_FMAC2 soap_instantiate___ns1__IvrAppList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:3284 */
#ifndef SOAP_TYPE___ns1__MailAccList
#define SOAP_TYPE___ns1__MailAccList (138)
/* Wrapper: */
struct SOAP_CMAC __ns1__MailAccList {
      public:
        /** Optional element 'ns1:RequestMailAccList' of XSD type 'ns1:GenRequestType' */
        ns1__GenRequestType *ns1__RequestMailAccList;
      public:
        /** Return unique type id SOAP_TYPE___ns1__MailAccList */
        int soap_type() const { return SOAP_TYPE___ns1__MailAccList; }
        /** Constructor with member initializations */
        __ns1__MailAccList() : ns1__RequestMailAccList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__MailAccList * SOAP_FMAC2 soap_instantiate___ns1__MailAccList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:3354 */
#ifndef SOAP_TYPE___ns1__AgentsPerGroupInfo
#define SOAP_TYPE___ns1__AgentsPerGroupInfo (141)
/* Wrapper: */
struct SOAP_CMAC __ns1__AgentsPerGroupInfo {
      public:
        /** Optional element 'ns1:RequestGroupAgentsMatrix' of XSD type 'ns1:GenInfoRequestType' */
        ns1__GenInfoRequestType *ns1__RequestGroupAgentsMatrix;
      public:
        /** Return unique type id SOAP_TYPE___ns1__AgentsPerGroupInfo */
        int soap_type() const { return SOAP_TYPE___ns1__AgentsPerGroupInfo; }
        /** Constructor with member initializations */
        __ns1__AgentsPerGroupInfo() : ns1__RequestGroupAgentsMatrix() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__AgentsPerGroupInfo * SOAP_FMAC2 soap_instantiate___ns1__AgentsPerGroupInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:3424 */
#ifndef SOAP_TYPE___ns1__AgentsList
#define SOAP_TYPE___ns1__AgentsList (144)
/* Wrapper: */
struct SOAP_CMAC __ns1__AgentsList {
      public:
        /** Optional element 'ns1:RequestAgentsList' of XSD type 'ns1:GenRequestType' */
        ns1__GenRequestType *ns1__RequestAgentsList;
      public:
        /** Return unique type id SOAP_TYPE___ns1__AgentsList */
        int soap_type() const { return SOAP_TYPE___ns1__AgentsList; }
        /** Constructor with member initializations */
        __ns1__AgentsList() : ns1__RequestAgentsList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__AgentsList * SOAP_FMAC2 soap_instantiate___ns1__AgentsList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:3494 */
#ifndef SOAP_TYPE___ns1__BriefAgents
#define SOAP_TYPE___ns1__BriefAgents (148)
/* Wrapper: */
struct SOAP_CMAC __ns1__BriefAgents {
      public:
        /** Optional element 'ns1:RequestBriefAgentsMatrix' of XSD type 'ns1:BriefInfoRequestType' */
        ns1__BriefInfoRequestType *ns1__RequestBriefAgentsMatrix;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BriefAgents */
        int soap_type() const { return SOAP_TYPE___ns1__BriefAgents; }
        /** Constructor with member initializations */
        __ns1__BriefAgents() : ns1__RequestBriefAgentsMatrix() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__BriefAgents * SOAP_FMAC2 soap_instantiate___ns1__BriefAgents(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:3564 */
#ifndef SOAP_TYPE___ns1__DefaultWorkspace
#define SOAP_TYPE___ns1__DefaultWorkspace (152)
/* Wrapper: */
struct SOAP_CMAC __ns1__DefaultWorkspace {
      public:
        /** Optional element 'ns1:RequestDefaultWorkspace' of XSD type 'ns1:DefaultWorkspaceRequestType' */
        ns1__DefaultWorkspaceRequestType *ns1__RequestDefaultWorkspace;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DefaultWorkspace */
        int soap_type() const { return SOAP_TYPE___ns1__DefaultWorkspace; }
        /** Constructor with member initializations */
        __ns1__DefaultWorkspace() : ns1__RequestDefaultWorkspace() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DefaultWorkspace * SOAP_FMAC2 soap_instantiate___ns1__DefaultWorkspace(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:3634 */
#ifndef SOAP_TYPE___ns1__ReportListData
#define SOAP_TYPE___ns1__ReportListData (156)
/* Wrapper: */
struct SOAP_CMAC __ns1__ReportListData {
      public:
        /** Optional element 'ns1:RequestReportListData' of XSD type 'ns1:ReportListDataRequestType' */
        ns1__ReportListDataRequestType *ns1__RequestReportListData;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ReportListData */
        int soap_type() const { return SOAP_TYPE___ns1__ReportListData; }
        /** Constructor with member initializations */
        __ns1__ReportListData() : ns1__RequestReportListData() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ReportListData * SOAP_FMAC2 soap_instantiate___ns1__ReportListData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:3704 */
#ifndef SOAP_TYPE___ns1__VoiceDNISList
#define SOAP_TYPE___ns1__VoiceDNISList (159)
/* Wrapper: */
struct SOAP_CMAC __ns1__VoiceDNISList {
      public:
        /** Optional element 'ns1:RequestVoiceDNISList' of XSD type 'ns1:GenRequestType' */
        ns1__GenRequestType *ns1__RequestVoiceDNISList;
      public:
        /** Return unique type id SOAP_TYPE___ns1__VoiceDNISList */
        int soap_type() const { return SOAP_TYPE___ns1__VoiceDNISList; }
        /** Constructor with member initializations */
        __ns1__VoiceDNISList() : ns1__RequestVoiceDNISList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__VoiceDNISList * SOAP_FMAC2 soap_instantiate___ns1__VoiceDNISList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:3774 */
#ifndef SOAP_TYPE___ns1__EmailDNISList
#define SOAP_TYPE___ns1__EmailDNISList (161)
/* Wrapper: */
struct SOAP_CMAC __ns1__EmailDNISList {
      public:
        /** Optional element 'ns1:RequestEmailDNISList' of XSD type 'ns1:GenRequestType' */
        ns1__GenRequestType *ns1__RequestEmailDNISList;
      public:
        /** Return unique type id SOAP_TYPE___ns1__EmailDNISList */
        int soap_type() const { return SOAP_TYPE___ns1__EmailDNISList; }
        /** Constructor with member initializations */
        __ns1__EmailDNISList() : ns1__RequestEmailDNISList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__EmailDNISList * SOAP_FMAC2 soap_instantiate___ns1__EmailDNISList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:3844 */
#ifndef SOAP_TYPE___ns1__BriefVoiceDNIS
#define SOAP_TYPE___ns1__BriefVoiceDNIS (163)
/* Wrapper: */
struct SOAP_CMAC __ns1__BriefVoiceDNIS {
      public:
        /** Optional element 'ns1:RequestBriefVoiceDNISMatrix' of XSD type 'ns1:BriefInfoRequestType' */
        ns1__BriefInfoRequestType *ns1__RequestBriefVoiceDNISMatrix;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BriefVoiceDNIS */
        int soap_type() const { return SOAP_TYPE___ns1__BriefVoiceDNIS; }
        /** Constructor with member initializations */
        __ns1__BriefVoiceDNIS() : ns1__RequestBriefVoiceDNISMatrix() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__BriefVoiceDNIS * SOAP_FMAC2 soap_instantiate___ns1__BriefVoiceDNIS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:3914 */
#ifndef SOAP_TYPE___ns1__BriefEmailDNIS
#define SOAP_TYPE___ns1__BriefEmailDNIS (165)
/* Wrapper: */
struct SOAP_CMAC __ns1__BriefEmailDNIS {
      public:
        /** Optional element 'ns1:RequestBriefEMailDNISMatrix' of XSD type 'ns1:BriefInfoRequestType' */
        ns1__BriefInfoRequestType *ns1__RequestBriefEMailDNISMatrix;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BriefEmailDNIS */
        int soap_type() const { return SOAP_TYPE___ns1__BriefEmailDNIS; }
        /** Constructor with member initializations */
        __ns1__BriefEmailDNIS() : ns1__RequestBriefEMailDNISMatrix() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__BriefEmailDNIS * SOAP_FMAC2 soap_instantiate___ns1__BriefEmailDNIS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:3984 */
#ifndef SOAP_TYPE___ns1__CommandAgentLoginLogout
#define SOAP_TYPE___ns1__CommandAgentLoginLogout (168)
/* Wrapper: */
struct SOAP_CMAC __ns1__CommandAgentLoginLogout {
      public:
        /** Optional element 'ns1:LoginLogoutRequestAcdComandAgent' of XSD type 'ns1:ACDMultiRequestType' */
        ns1__ACDMultiRequestType *ns1__LoginLogoutRequestAcdComandAgent;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CommandAgentLoginLogout */
        int soap_type() const { return SOAP_TYPE___ns1__CommandAgentLoginLogout; }
        /** Constructor with member initializations */
        __ns1__CommandAgentLoginLogout() : ns1__LoginLogoutRequestAcdComandAgent() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CommandAgentLoginLogout * SOAP_FMAC2 soap_instantiate___ns1__CommandAgentLoginLogout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:4054 */
#ifndef SOAP_TYPE___ns1__CommandAgentReleaseResume
#define SOAP_TYPE___ns1__CommandAgentReleaseResume (171)
/* Wrapper: */
struct SOAP_CMAC __ns1__CommandAgentReleaseResume {
      public:
        /** Optional element 'ns1:ReleaseResumeRequestAcd' of XSD type 'ns1:ACDRequestType' */
        ns1__ACDRequestType *ns1__ReleaseResumeRequestAcd;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CommandAgentReleaseResume */
        int soap_type() const { return SOAP_TYPE___ns1__CommandAgentReleaseResume; }
        /** Constructor with member initializations */
        __ns1__CommandAgentReleaseResume() : ns1__ReleaseResumeRequestAcd() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CommandAgentReleaseResume * SOAP_FMAC2 soap_instantiate___ns1__CommandAgentReleaseResume(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:4124 */
#ifndef SOAP_TYPE___ns1__CommandAgentStartChat
#define SOAP_TYPE___ns1__CommandAgentStartChat (175)
/* Wrapper: */
struct SOAP_CMAC __ns1__CommandAgentStartChat {
      public:
        /** Optional element 'ns1:StartChatRequestAcd' of XSD type 'ns1:TFRequestType' */
        ns1__TFRequestType *ns1__StartChatRequestAcd;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CommandAgentStartChat */
        int soap_type() const { return SOAP_TYPE___ns1__CommandAgentStartChat; }
        /** Constructor with member initializations */
        __ns1__CommandAgentStartChat() : ns1__StartChatRequestAcd() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CommandAgentStartChat * SOAP_FMAC2 soap_instantiate___ns1__CommandAgentStartChat(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:4194 */
#ifndef SOAP_TYPE___ns1__CommandAgentStartRecord
#define SOAP_TYPE___ns1__CommandAgentStartRecord (177)
/* Wrapper: */
struct SOAP_CMAC __ns1__CommandAgentStartRecord {
      public:
        /** Optional element 'ns1:StartRecordRequestAcd' of XSD type 'ns1:TFRequestType' */
        ns1__TFRequestType *ns1__StartRecordRequestAcd;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CommandAgentStartRecord */
        int soap_type() const { return SOAP_TYPE___ns1__CommandAgentStartRecord; }
        /** Constructor with member initializations */
        __ns1__CommandAgentStartRecord() : ns1__StartRecordRequestAcd() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CommandAgentStartRecord * SOAP_FMAC2 soap_instantiate___ns1__CommandAgentStartRecord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:4264 */
#ifndef SOAP_TYPE___ns1__CommandAgentTelephonyFeatures
#define SOAP_TYPE___ns1__CommandAgentTelephonyFeatures (179)
/* Wrapper: */
struct SOAP_CMAC __ns1__CommandAgentTelephonyFeatures {
      public:
        /** Optional element 'ns1:RequestTf' of XSD type 'ns1:TFRequestType' */
        ns1__TFRequestType *ns1__RequestTf;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CommandAgentTelephonyFeatures */
        int soap_type() const { return SOAP_TYPE___ns1__CommandAgentTelephonyFeatures; }
        /** Constructor with member initializations */
        __ns1__CommandAgentTelephonyFeatures() : ns1__RequestTf() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CommandAgentTelephonyFeatures * SOAP_FMAC2 soap_instantiate___ns1__CommandAgentTelephonyFeatures(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:4334 */
#ifndef SOAP_TYPE___ns1__SaveWorkspase
#define SOAP_TYPE___ns1__SaveWorkspase (182)
/* Wrapper: */
struct SOAP_CMAC __ns1__SaveWorkspase {
      public:
        /** Optional element 'ns1:RequestSaveWorkspase' of XSD type 'ns1:SaveWorkspaseRequestType' */
        ns1__SaveWorkspaseRequestType *ns1__RequestSaveWorkspase;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SaveWorkspase */
        int soap_type() const { return SOAP_TYPE___ns1__SaveWorkspase; }
        /** Constructor with member initializations */
        __ns1__SaveWorkspase() : ns1__RequestSaveWorkspase() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SaveWorkspase * SOAP_FMAC2 soap_instantiate___ns1__SaveWorkspase(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:4404 */
#ifndef SOAP_TYPE___ns1__SaveReport
#define SOAP_TYPE___ns1__SaveReport (186)
/* Wrapper: */
struct SOAP_CMAC __ns1__SaveReport {
      public:
        /** Optional element 'ns1:RequestSaveReport' of XSD type 'ns1:RequestSaveReportType' */
        ns1__RequestSaveReportType *ns1__RequestSaveReport;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SaveReport */
        int soap_type() const { return SOAP_TYPE___ns1__SaveReport; }
        /** Constructor with member initializations */
        __ns1__SaveReport() : ns1__RequestSaveReport() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SaveReport * SOAP_FMAC2 soap_instantiate___ns1__SaveReport(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:4474 */
#ifndef SOAP_TYPE___ns1__DeleteReport
#define SOAP_TYPE___ns1__DeleteReport (189)
/* Wrapper: */
struct SOAP_CMAC __ns1__DeleteReport {
      public:
        /** Optional element 'ns1:RequestDeleteReport' of XSD type 'ns1:RequestDeleteReportType' */
        ns1__RequestDeleteReportType *ns1__RequestDeleteReport;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DeleteReport */
        int soap_type() const { return SOAP_TYPE___ns1__DeleteReport; }
        /** Constructor with member initializations */
        __ns1__DeleteReport() : ns1__RequestDeleteReport() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DeleteReport * SOAP_FMAC2 soap_instantiate___ns1__DeleteReport(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:4544 */
#ifndef SOAP_TYPE___ns1__LoginManagerAgentsPerGroup
#define SOAP_TYPE___ns1__LoginManagerAgentsPerGroup (192)
/* Wrapper: */
struct SOAP_CMAC __ns1__LoginManagerAgentsPerGroup {
      public:
        /** Optional element 'ns1:LoginManagerRequestAgents' of XSD type 'ns1:LoginManagerRequestType' */
        ns1__LoginManagerRequestType *ns1__LoginManagerRequestAgents;
      public:
        /** Return unique type id SOAP_TYPE___ns1__LoginManagerAgentsPerGroup */
        int soap_type() const { return SOAP_TYPE___ns1__LoginManagerAgentsPerGroup; }
        /** Constructor with member initializations */
        __ns1__LoginManagerAgentsPerGroup() : ns1__LoginManagerRequestAgents() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__LoginManagerAgentsPerGroup * SOAP_FMAC2 soap_instantiate___ns1__LoginManagerAgentsPerGroup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:4614 */
#ifndef SOAP_TYPE___ns1__LoginManagerGroupsPerAgent
#define SOAP_TYPE___ns1__LoginManagerGroupsPerAgent (194)
/* Wrapper: */
struct SOAP_CMAC __ns1__LoginManagerGroupsPerAgent {
      public:
        /** Optional element 'ns1:LoginManagerRequestGroups' of XSD type 'ns1:LoginManagerRequestType' */
        ns1__LoginManagerRequestType *ns1__LoginManagerRequestGroups;
      public:
        /** Return unique type id SOAP_TYPE___ns1__LoginManagerGroupsPerAgent */
        int soap_type() const { return SOAP_TYPE___ns1__LoginManagerGroupsPerAgent; }
        /** Constructor with member initializations */
        __ns1__LoginManagerGroupsPerAgent() : ns1__LoginManagerRequestGroups() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__LoginManagerGroupsPerAgent * SOAP_FMAC2 soap_instantiate___ns1__LoginManagerGroupsPerAgent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:4684 */
#ifndef SOAP_TYPE___ns1__LoginManagerOneAgentToMultiGroups
#define SOAP_TYPE___ns1__LoginManagerOneAgentToMultiGroups (196)
/* Wrapper: */
struct SOAP_CMAC __ns1__LoginManagerOneAgentToMultiGroups {
      public:
        /** Optional element 'ns1:LoginLogoutRequestAcdOneAgent' of XSD type 'ns1:ACDMultiRequestType' */
        ns1__ACDMultiRequestType *ns1__LoginLogoutRequestAcdOneAgent;
      public:
        /** Return unique type id SOAP_TYPE___ns1__LoginManagerOneAgentToMultiGroups */
        int soap_type() const { return SOAP_TYPE___ns1__LoginManagerOneAgentToMultiGroups; }
        /** Constructor with member initializations */
        __ns1__LoginManagerOneAgentToMultiGroups() : ns1__LoginLogoutRequestAcdOneAgent() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__LoginManagerOneAgentToMultiGroups * SOAP_FMAC2 soap_instantiate___ns1__LoginManagerOneAgentToMultiGroups(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:4754 */
#ifndef SOAP_TYPE___ns1__LoginManagerMultiAgentsToOneGroup
#define SOAP_TYPE___ns1__LoginManagerMultiAgentsToOneGroup (198)
/* Wrapper: */
struct SOAP_CMAC __ns1__LoginManagerMultiAgentsToOneGroup {
      public:
        /** Optional element 'ns1:LoginLogoutRequestAcdMultiAgents' of XSD type 'ns1:ACDMultiRequestType' */
        ns1__ACDMultiRequestType *ns1__LoginLogoutRequestAcdMultiAgents;
      public:
        /** Return unique type id SOAP_TYPE___ns1__LoginManagerMultiAgentsToOneGroup */
        int soap_type() const { return SOAP_TYPE___ns1__LoginManagerMultiAgentsToOneGroup; }
        /** Constructor with member initializations */
        __ns1__LoginManagerMultiAgentsToOneGroup() : ns1__LoginLogoutRequestAcdMultiAgents() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__LoginManagerMultiAgentsToOneGroup * SOAP_FMAC2 soap_instantiate___ns1__LoginManagerMultiAgentsToOneGroup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:4824 */
#ifndef SOAP_TYPE___ns1__LoginManagerAvailableAgentsForGroup
#define SOAP_TYPE___ns1__LoginManagerAvailableAgentsForGroup (200)
/* Wrapper: */
struct SOAP_CMAC __ns1__LoginManagerAvailableAgentsForGroup {
      public:
        /** Optional element 'ns1:LoginManagerRequestAvailableAgents' of XSD type 'ns1:LoginManagerRequestType' */
        ns1__LoginManagerRequestType *ns1__LoginManagerRequestAvailableAgents;
      public:
        /** Return unique type id SOAP_TYPE___ns1__LoginManagerAvailableAgentsForGroup */
        int soap_type() const { return SOAP_TYPE___ns1__LoginManagerAvailableAgentsForGroup; }
        /** Constructor with member initializations */
        __ns1__LoginManagerAvailableAgentsForGroup() : ns1__LoginManagerRequestAvailableAgents() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__LoginManagerAvailableAgentsForGroup * SOAP_FMAC2 soap_instantiate___ns1__LoginManagerAvailableAgentsForGroup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:4894 */
#ifndef SOAP_TYPE___ns1__LoginManagerAvailableGroupsForAgent
#define SOAP_TYPE___ns1__LoginManagerAvailableGroupsForAgent (202)
/* Wrapper: */
struct SOAP_CMAC __ns1__LoginManagerAvailableGroupsForAgent {
      public:
        /** Optional element 'ns1:LoginManagerRequestAvailableGroups' of XSD type 'ns1:LoginManagerRequestType' */
        ns1__LoginManagerRequestType *ns1__LoginManagerRequestAvailableGroups;
      public:
        /** Return unique type id SOAP_TYPE___ns1__LoginManagerAvailableGroupsForAgent */
        int soap_type() const { return SOAP_TYPE___ns1__LoginManagerAvailableGroupsForAgent; }
        /** Constructor with member initializations */
        __ns1__LoginManagerAvailableGroupsForAgent() : ns1__LoginManagerRequestAvailableGroups() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__LoginManagerAvailableGroupsForAgent * SOAP_FMAC2 soap_instantiate___ns1__LoginManagerAvailableGroupsForAgent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:4964 */
#ifndef SOAP_TYPE___ns1__ApplicationRegister
#define SOAP_TYPE___ns1__ApplicationRegister (206)
/* Wrapper: */
struct SOAP_CMAC __ns1__ApplicationRegister {
      public:
        /** Optional element 'ns1:ApplicationRegisterRequest' of XSD type 'ns1:ApplicationRegisterRequestType' */
        ns1__ApplicationRegisterRequestType *ns1__ApplicationRegisterRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ApplicationRegister */
        int soap_type() const { return SOAP_TYPE___ns1__ApplicationRegister; }
        /** Constructor with member initializations */
        __ns1__ApplicationRegister() : ns1__ApplicationRegisterRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ApplicationRegister * SOAP_FMAC2 soap_instantiate___ns1__ApplicationRegister(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:5034 */
#ifndef SOAP_TYPE___ns1__ApplicationKeepAlive
#define SOAP_TYPE___ns1__ApplicationKeepAlive (209)
/* Wrapper: */
struct SOAP_CMAC __ns1__ApplicationKeepAlive {
      public:
        /** Optional element 'ns1:ApplicationKeepAliveRequest' of XSD type 'ns1:ApplicationKeepAliveRequestType' */
        ns1__ApplicationKeepAliveRequestType *ns1__ApplicationKeepAliveRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ApplicationKeepAlive */
        int soap_type() const { return SOAP_TYPE___ns1__ApplicationKeepAlive; }
        /** Constructor with member initializations */
        __ns1__ApplicationKeepAlive() : ns1__ApplicationKeepAliveRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ApplicationKeepAlive * SOAP_FMAC2 soap_instantiate___ns1__ApplicationKeepAlive(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:5104 */
#ifndef SOAP_TYPE___ns1__TraceInternalStat
#define SOAP_TYPE___ns1__TraceInternalStat (213)
/* Wrapper: */
struct SOAP_CMAC __ns1__TraceInternalStat {
      public:
        /** Optional element 'ns1:TraceInternalStatRequest' of XSD type 'ns1:StatRequestType' */
        ns1__StatRequestType *ns1__TraceInternalStatRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__TraceInternalStat */
        int soap_type() const { return SOAP_TYPE___ns1__TraceInternalStat; }
        /** Constructor with member initializations */
        __ns1__TraceInternalStat() : ns1__TraceInternalStatRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__TraceInternalStat * SOAP_FMAC2 soap_instantiate___ns1__TraceInternalStat(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:5174 */
#ifndef SOAP_TYPE___ns1__AgentNeedHelp
#define SOAP_TYPE___ns1__AgentNeedHelp (215)
/* Wrapper: */
struct SOAP_CMAC __ns1__AgentNeedHelp {
      public:
        /** Optional element 'ns1:AgentNeedHelpRequest' of XSD type 'ns1:BriefInfoRequestType' */
        ns1__BriefInfoRequestType *ns1__AgentNeedHelpRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__AgentNeedHelp */
        int soap_type() const { return SOAP_TYPE___ns1__AgentNeedHelp; }
        /** Constructor with member initializations */
        __ns1__AgentNeedHelp() : ns1__AgentNeedHelpRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__AgentNeedHelp * SOAP_FMAC2 soap_instantiate___ns1__AgentNeedHelp(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:5244 */
#ifndef SOAP_TYPE___ns1__GroupHourlyInfo
#define SOAP_TYPE___ns1__GroupHourlyInfo (217)
/* Wrapper: */
struct SOAP_CMAC __ns1__GroupHourlyInfo {
      public:
        /** Optional element 'ns1:GroupHourlyInfoRequest' of XSD type 'ns1:GenInfoRequestType' */
        ns1__GenInfoRequestType *ns1__GroupHourlyInfoRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GroupHourlyInfo */
        int soap_type() const { return SOAP_TYPE___ns1__GroupHourlyInfo; }
        /** Constructor with member initializations */
        __ns1__GroupHourlyInfo() : ns1__GroupHourlyInfoRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GroupHourlyInfo * SOAP_FMAC2 soap_instantiate___ns1__GroupHourlyInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:5314 */
#ifndef SOAP_TYPE___ns1__GroupDailyBriefInfo
#define SOAP_TYPE___ns1__GroupDailyBriefInfo (219)
/* Wrapper: */
struct SOAP_CMAC __ns1__GroupDailyBriefInfo {
      public:
        /** Optional element 'ns1:GroupDailyBriefInfoRequest' of XSD type 'ns1:GenInfoRequestType' */
        ns1__GenInfoRequestType *ns1__GroupDailyBriefInfoRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GroupDailyBriefInfo */
        int soap_type() const { return SOAP_TYPE___ns1__GroupDailyBriefInfo; }
        /** Constructor with member initializations */
        __ns1__GroupDailyBriefInfo() : ns1__GroupDailyBriefInfoRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GroupDailyBriefInfo * SOAP_FMAC2 soap_instantiate___ns1__GroupDailyBriefInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:5384 */
#ifndef SOAP_TYPE___ns1__GroupDailyDetailedInfo
#define SOAP_TYPE___ns1__GroupDailyDetailedInfo (221)
/* Wrapper: */
struct SOAP_CMAC __ns1__GroupDailyDetailedInfo {
      public:
        /** Optional element 'ns1:GroupDailyDetailedInfoRequest' of XSD type 'ns1:GenInfoRequestType' */
        ns1__GenInfoRequestType *ns1__GroupDailyDetailedInfoRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GroupDailyDetailedInfo */
        int soap_type() const { return SOAP_TYPE___ns1__GroupDailyDetailedInfo; }
        /** Constructor with member initializations */
        __ns1__GroupDailyDetailedInfo() : ns1__GroupDailyDetailedInfoRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GroupDailyDetailedInfo * SOAP_FMAC2 soap_instantiate___ns1__GroupDailyDetailedInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:5454 */
#ifndef SOAP_TYPE___ns1__SuperGroupHourlyInfo
#define SOAP_TYPE___ns1__SuperGroupHourlyInfo (224)
/* Wrapper: */
struct SOAP_CMAC __ns1__SuperGroupHourlyInfo {
      public:
        /** Optional element 'ns1:SuperGroupHourlyInfoRequest' of XSD type 'ns1:GenInfoRequestType' */
        ns1__GenInfoRequestType *ns1__SuperGroupHourlyInfoRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SuperGroupHourlyInfo */
        int soap_type() const { return SOAP_TYPE___ns1__SuperGroupHourlyInfo; }
        /** Constructor with member initializations */
        __ns1__SuperGroupHourlyInfo() : ns1__SuperGroupHourlyInfoRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SuperGroupHourlyInfo * SOAP_FMAC2 soap_instantiate___ns1__SuperGroupHourlyInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:5524 */
#ifndef SOAP_TYPE___ns1__SuperGroupDailyBriefInfo
#define SOAP_TYPE___ns1__SuperGroupDailyBriefInfo (226)
/* Wrapper: */
struct SOAP_CMAC __ns1__SuperGroupDailyBriefInfo {
      public:
        /** Optional element 'ns1:SuperGroupDailyBriefInfoRequest' of XSD type 'ns1:GenInfoRequestType' */
        ns1__GenInfoRequestType *ns1__SuperGroupDailyBriefInfoRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SuperGroupDailyBriefInfo */
        int soap_type() const { return SOAP_TYPE___ns1__SuperGroupDailyBriefInfo; }
        /** Constructor with member initializations */
        __ns1__SuperGroupDailyBriefInfo() : ns1__SuperGroupDailyBriefInfoRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SuperGroupDailyBriefInfo * SOAP_FMAC2 soap_instantiate___ns1__SuperGroupDailyBriefInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* emisweb.h:5771 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (227)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* emisweb.h:5771 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (228)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* emisweb.h:5771 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (230)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* emisweb.h:5771 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (233)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* emisweb.h:5771 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (234)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* emisweb.h:101 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* emisweb.h:101 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* short has binding name 'short' for type 'xsd:short' */
#ifndef SOAP_TYPE_short
#define SOAP_TYPE_short (79)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (56)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (57)
#endif

/* ns1__StatReturnType has binding name 'ns1__StatReturnType' for type 'ns1:StatReturnType' */
#ifndef SOAP_TYPE_ns1__StatReturnType
#define SOAP_TYPE_ns1__StatReturnType (55)
#endif

/* ns1__StatItemType has binding name 'ns1__StatItemType' for type 'ns1:StatItemType' */
#ifndef SOAP_TYPE_ns1__StatItemType
#define SOAP_TYPE_ns1__StatItemType (54)
#endif

/* ns1__StatRequestType has binding name 'ns1__StatRequestType' for type 'ns1:StatRequestType' */
#ifndef SOAP_TYPE_ns1__StatRequestType
#define SOAP_TYPE_ns1__StatRequestType (53)
#endif

/* ns1__ApplicationReturnType has binding name 'ns1__ApplicationReturnType' for type 'ns1:ApplicationReturnType' */
#ifndef SOAP_TYPE_ns1__ApplicationReturnType
#define SOAP_TYPE_ns1__ApplicationReturnType (52)
#endif

/* ns1__ApplicationKeepAliveRequestType has binding name 'ns1__ApplicationKeepAliveRequestType' for type 'ns1:ApplicationKeepAliveRequestType' */
#ifndef SOAP_TYPE_ns1__ApplicationKeepAliveRequestType
#define SOAP_TYPE_ns1__ApplicationKeepAliveRequestType (51)
#endif

/* ns1__ApplicationRegisterRequestType has binding name 'ns1__ApplicationRegisterRequestType' for type 'ns1:ApplicationRegisterRequestType' */
#ifndef SOAP_TYPE_ns1__ApplicationRegisterRequestType
#define SOAP_TYPE_ns1__ApplicationRegisterRequestType (50)
#endif

/* ns1__LoginManagerRequestType has binding name 'ns1__LoginManagerRequestType' for type 'ns1:LoginManagerRequestType' */
#ifndef SOAP_TYPE_ns1__LoginManagerRequestType
#define SOAP_TYPE_ns1__LoginManagerRequestType (49)
#endif

/* ns1__RequestDeleteReportType has binding name 'ns1__RequestDeleteReportType' for type 'ns1:RequestDeleteReportType' */
#ifndef SOAP_TYPE_ns1__RequestDeleteReportType
#define SOAP_TYPE_ns1__RequestDeleteReportType (48)
#endif

/* ns1__RequestSaveReportType has binding name 'ns1__RequestSaveReportType' for type 'ns1:RequestSaveReportType' */
#ifndef SOAP_TYPE_ns1__RequestSaveReportType
#define SOAP_TYPE_ns1__RequestSaveReportType (47)
#endif

/* ns1__SaveWorkspaseRequestType has binding name 'ns1__SaveWorkspaseRequestType' for type 'ns1:SaveWorkspaseRequestType' */
#ifndef SOAP_TYPE_ns1__SaveWorkspaseRequestType
#define SOAP_TYPE_ns1__SaveWorkspaseRequestType (46)
#endif

/* ns1__SuperGroupListReturnType has binding name 'ns1__SuperGroupListReturnType' for type 'ns1:SuperGroupListReturnType' */
#ifndef SOAP_TYPE_ns1__SuperGroupListReturnType
#define SOAP_TYPE_ns1__SuperGroupListReturnType (45)
#endif

/* ns1__SuperGroupListDataItemType has binding name 'ns1__SuperGroupListDataItemType' for type 'ns1:SuperGroupListDataItemType' */
#ifndef SOAP_TYPE_ns1__SuperGroupListDataItemType
#define SOAP_TYPE_ns1__SuperGroupListDataItemType (44)
#endif

/* ns1__BriefDNISInfoRequestType has binding name 'ns1__BriefDNISInfoRequestType' for type 'ns1:BriefDNISInfoRequestType' */
#ifndef SOAP_TYPE_ns1__BriefDNISInfoRequestType
#define SOAP_TYPE_ns1__BriefDNISInfoRequestType (43)
#endif

/* ns1__DNISListReturnType has binding name 'ns1__DNISListReturnType' for type 'ns1:DNISListReturnType' */
#ifndef SOAP_TYPE_ns1__DNISListReturnType
#define SOAP_TYPE_ns1__DNISListReturnType (42)
#endif

/* ns1__DNISListDataItemType has binding name 'ns1__DNISListDataItemType' for type 'ns1:DNISListDataItemType' */
#ifndef SOAP_TYPE_ns1__DNISListDataItemType
#define SOAP_TYPE_ns1__DNISListDataItemType (41)
#endif

/* ns1__ReportListDataReturnType has binding name 'ns1__ReportListDataReturnType' for type 'ns1:ReportListDataReturnType' */
#ifndef SOAP_TYPE_ns1__ReportListDataReturnType
#define SOAP_TYPE_ns1__ReportListDataReturnType (40)
#endif

/* ns1__ReportListDataItemType has binding name 'ns1__ReportListDataItemType' for type 'ns1:ReportListDataItemType' */
#ifndef SOAP_TYPE_ns1__ReportListDataItemType
#define SOAP_TYPE_ns1__ReportListDataItemType (39)
#endif

/* ns1__ReportListDataRequestType has binding name 'ns1__ReportListDataRequestType' for type 'ns1:ReportListDataRequestType' */
#ifndef SOAP_TYPE_ns1__ReportListDataRequestType
#define SOAP_TYPE_ns1__ReportListDataRequestType (38)
#endif

/* ns1__DefaultWorkspaceReturnType has binding name 'ns1__DefaultWorkspaceReturnType' for type 'ns1:DefaultWorkspaceReturnType' */
#ifndef SOAP_TYPE_ns1__DefaultWorkspaceReturnType
#define SOAP_TYPE_ns1__DefaultWorkspaceReturnType (37)
#endif

/* ns1__DefaultWorkspaceItemType has binding name 'ns1__DefaultWorkspaceItemType' for type 'ns1:DefaultWorkspaceItemType' */
#ifndef SOAP_TYPE_ns1__DefaultWorkspaceItemType
#define SOAP_TYPE_ns1__DefaultWorkspaceItemType (36)
#endif

/* ns1__DefaultWorkspaceRequestType has binding name 'ns1__DefaultWorkspaceRequestType' for type 'ns1:DefaultWorkspaceRequestType' */
#ifndef SOAP_TYPE_ns1__DefaultWorkspaceRequestType
#define SOAP_TYPE_ns1__DefaultWorkspaceRequestType (35)
#endif

/* ns1__BriefInfoRequestType has binding name 'ns1__BriefInfoRequestType' for type 'ns1:BriefInfoRequestType' */
#ifndef SOAP_TYPE_ns1__BriefInfoRequestType
#define SOAP_TYPE_ns1__BriefInfoRequestType (34)
#endif

/* ns1__AgentsListReturnType has binding name 'ns1__AgentsListReturnType' for type 'ns1:AgentsListReturnType' */
#ifndef SOAP_TYPE_ns1__AgentsListReturnType
#define SOAP_TYPE_ns1__AgentsListReturnType (33)
#endif

/* ns1__AgentsListDataItemType has binding name 'ns1__AgentsListDataItemType' for type 'ns1:AgentsListDataItemType' */
#ifndef SOAP_TYPE_ns1__AgentsListDataItemType
#define SOAP_TYPE_ns1__AgentsListDataItemType (32)
#endif

/* ns1__GenListReturnType has binding name 'ns1__GenListReturnType' for type 'ns1:GenListReturnType' */
#ifndef SOAP_TYPE_ns1__GenListReturnType
#define SOAP_TYPE_ns1__GenListReturnType (31)
#endif

/* ns1__GenListDataItemType has binding name 'ns1__GenListDataItemType' for type 'ns1:GenListDataItemType' */
#ifndef SOAP_TYPE_ns1__GenListDataItemType
#define SOAP_TYPE_ns1__GenListDataItemType (30)
#endif

/* ns1__GroupListReturnType has binding name 'ns1__GroupListReturnType' for type 'ns1:GroupListReturnType' */
#ifndef SOAP_TYPE_ns1__GroupListReturnType
#define SOAP_TYPE_ns1__GroupListReturnType (29)
#endif

/* ns1__GroupListDataItemType has binding name 'ns1__GroupListDataItemType' for type 'ns1:GroupListDataItemType' */
#ifndef SOAP_TYPE_ns1__GroupListDataItemType
#define SOAP_TYPE_ns1__GroupListDataItemType (28)
#endif

/* ns1__GenRequestType has binding name 'ns1__GenRequestType' for type 'ns1:GenRequestType' */
#ifndef SOAP_TYPE_ns1__GenRequestType
#define SOAP_TYPE_ns1__GenRequestType (27)
#endif

/* ns1__LoginReturnType has binding name 'ns1__LoginReturnType' for type 'ns1:LoginReturnType' */
#ifndef SOAP_TYPE_ns1__LoginReturnType
#define SOAP_TYPE_ns1__LoginReturnType (26)
#endif

/* ns1__LoginRequestType has binding name 'ns1__LoginRequestType' for type 'ns1:LoginRequestType' */
#ifndef SOAP_TYPE_ns1__LoginRequestType
#define SOAP_TYPE_ns1__LoginRequestType (25)
#endif

/* ns1__ReturnMatrixDataTypeBG has binding name 'ns1__ReturnMatrixDataTypeBG' for type 'ns1:ReturnMatrixDataTypeBG' */
#ifndef SOAP_TYPE_ns1__ReturnMatrixDataTypeBG
#define SOAP_TYPE_ns1__ReturnMatrixDataTypeBG (24)
#endif

/* ns1__ReturnMatrixDataTypePerSuperGroup has binding name 'ns1__ReturnMatrixDataTypePerSuperGroup' for type 'ns1:ReturnMatrixDataTypePerSuperGroup' */
#ifndef SOAP_TYPE_ns1__ReturnMatrixDataTypePerSuperGroup
#define SOAP_TYPE_ns1__ReturnMatrixDataTypePerSuperGroup (23)
#endif

/* ns1__returnDataRowsPerSuperGroup has binding name 'ns1__returnDataRowsPerSuperGroup' for type 'ns1:returnDataRowsPerSuperGroup' */
#ifndef SOAP_TYPE_ns1__returnDataRowsPerSuperGroup
#define SOAP_TYPE_ns1__returnDataRowsPerSuperGroup (22)
#endif

/* ns1__ReturnMatrixDataTypePerGroup has binding name 'ns1__ReturnMatrixDataTypePerGroup' for type 'ns1:ReturnMatrixDataTypePerGroup' */
#ifndef SOAP_TYPE_ns1__ReturnMatrixDataTypePerGroup
#define SOAP_TYPE_ns1__ReturnMatrixDataTypePerGroup (21)
#endif

/* ns1__returnDataRowsPerGroup has binding name 'ns1__returnDataRowsPerGroup' for type 'ns1:returnDataRowsPerGroup' */
#ifndef SOAP_TYPE_ns1__returnDataRowsPerGroup
#define SOAP_TYPE_ns1__returnDataRowsPerGroup (20)
#endif

/* ns1__ReturnArrayDataType has binding name 'ns1__ReturnArrayDataType' for type 'ns1:ReturnArrayDataType' */
#ifndef SOAP_TYPE_ns1__ReturnArrayDataType
#define SOAP_TYPE_ns1__ReturnArrayDataType (19)
#endif

/* ns1__BlockItemType has binding name 'ns1__BlockItemType' for type 'ns1:BlockItemType' */
#ifndef SOAP_TYPE_ns1__BlockItemType
#define SOAP_TYPE_ns1__BlockItemType (18)
#endif

/* ns1__DataItemRow has binding name 'ns1__DataItemRow' for type 'ns1:DataItemRow' */
#ifndef SOAP_TYPE_ns1__DataItemRow
#define SOAP_TYPE_ns1__DataItemRow (17)
#endif

/* ns1__DataItemType has binding name 'ns1__DataItemType' for type 'ns1:DataItemType' */
#ifndef SOAP_TYPE_ns1__DataItemType
#define SOAP_TYPE_ns1__DataItemType (16)
#endif

/* ns1__ResponseSaveReportType has binding name 'ns1__ResponseSaveReportType' for type 'ns1:ResponseSaveReportType' */
#ifndef SOAP_TYPE_ns1__ResponseSaveReportType
#define SOAP_TYPE_ns1__ResponseSaveReportType (15)
#endif

/* ns1__ResponseInfoHeaderType has binding name 'ns1__ResponseInfoHeaderType' for type 'ns1:ResponseInfoHeaderType' */
#ifndef SOAP_TYPE_ns1__ResponseInfoHeaderType
#define SOAP_TYPE_ns1__ResponseInfoHeaderType (14)
#endif

/* ns1__ChatResponseType has binding name 'ns1__ChatResponseType' for type 'ns1:ChatResponseType' */
#ifndef SOAP_TYPE_ns1__ChatResponseType
#define SOAP_TYPE_ns1__ChatResponseType (13)
#endif

/* ns1__TFRequestType has binding name 'ns1__TFRequestType' for type 'ns1:TFRequestType' */
#ifndef SOAP_TYPE_ns1__TFRequestType
#define SOAP_TYPE_ns1__TFRequestType (12)
#endif

/* ns1__ACDRequestType has binding name 'ns1__ACDRequestType' for type 'ns1:ACDRequestType' */
#ifndef SOAP_TYPE_ns1__ACDRequestType
#define SOAP_TYPE_ns1__ACDRequestType (11)
#endif

/* ns1__ACDMultiRequestType has binding name 'ns1__ACDMultiRequestType' for type 'ns1:ACDMultiRequestType' */
#ifndef SOAP_TYPE_ns1__ACDMultiRequestType
#define SOAP_TYPE_ns1__ACDMultiRequestType (10)
#endif

/* ns1__GenInfoRequestType has binding name 'ns1__GenInfoRequestType' for type 'ns1:GenInfoRequestType' */
#ifndef SOAP_TYPE_ns1__GenInfoRequestType
#define SOAP_TYPE_ns1__GenInfoRequestType (9)
#endif

/* ns1__RequestInfoHeaderType has binding name 'ns1__RequestInfoHeaderType' for type 'ns1:RequestInfoHeaderType' */
#ifndef SOAP_TYPE_ns1__RequestInfoHeaderType
#define SOAP_TYPE_ns1__RequestInfoHeaderType (8)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (234)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (233)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (230)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (228)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (227)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (236)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (235)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (229)
#endif

/* ns1__StatRequestType * has binding name 'PointerTons1__StatRequestType' for type 'ns1:StatRequestType' */
#ifndef SOAP_TYPE_PointerTons1__StatRequestType
#define SOAP_TYPE_PointerTons1__StatRequestType (210)
#endif

/* ns1__ApplicationKeepAliveRequestType * has binding name 'PointerTons1__ApplicationKeepAliveRequestType' for type 'ns1:ApplicationKeepAliveRequestType' */
#ifndef SOAP_TYPE_PointerTons1__ApplicationKeepAliveRequestType
#define SOAP_TYPE_PointerTons1__ApplicationKeepAliveRequestType (207)
#endif

/* ns1__ApplicationRegisterRequestType * has binding name 'PointerTons1__ApplicationRegisterRequestType' for type 'ns1:ApplicationRegisterRequestType' */
#ifndef SOAP_TYPE_PointerTons1__ApplicationRegisterRequestType
#define SOAP_TYPE_PointerTons1__ApplicationRegisterRequestType (203)
#endif

/* ns1__LoginManagerRequestType * has binding name 'PointerTons1__LoginManagerRequestType' for type 'ns1:LoginManagerRequestType' */
#ifndef SOAP_TYPE_PointerTons1__LoginManagerRequestType
#define SOAP_TYPE_PointerTons1__LoginManagerRequestType (190)
#endif

/* ns1__RequestDeleteReportType * has binding name 'PointerTons1__RequestDeleteReportType' for type 'ns1:RequestDeleteReportType' */
#ifndef SOAP_TYPE_PointerTons1__RequestDeleteReportType
#define SOAP_TYPE_PointerTons1__RequestDeleteReportType (187)
#endif

/* ns1__RequestSaveReportType * has binding name 'PointerTons1__RequestSaveReportType' for type 'ns1:RequestSaveReportType' */
#ifndef SOAP_TYPE_PointerTons1__RequestSaveReportType
#define SOAP_TYPE_PointerTons1__RequestSaveReportType (183)
#endif

/* ns1__SaveWorkspaseRequestType * has binding name 'PointerTons1__SaveWorkspaseRequestType' for type 'ns1:SaveWorkspaseRequestType' */
#ifndef SOAP_TYPE_PointerTons1__SaveWorkspaseRequestType
#define SOAP_TYPE_PointerTons1__SaveWorkspaseRequestType (180)
#endif

/* ns1__TFRequestType * has binding name 'PointerTons1__TFRequestType' for type 'ns1:TFRequestType' */
#ifndef SOAP_TYPE_PointerTons1__TFRequestType
#define SOAP_TYPE_PointerTons1__TFRequestType (172)
#endif

/* ns1__ACDRequestType * has binding name 'PointerTons1__ACDRequestType' for type 'ns1:ACDRequestType' */
#ifndef SOAP_TYPE_PointerTons1__ACDRequestType
#define SOAP_TYPE_PointerTons1__ACDRequestType (169)
#endif

/* ns1__ACDMultiRequestType * has binding name 'PointerTons1__ACDMultiRequestType' for type 'ns1:ACDMultiRequestType' */
#ifndef SOAP_TYPE_PointerTons1__ACDMultiRequestType
#define SOAP_TYPE_PointerTons1__ACDMultiRequestType (166)
#endif

/* ns1__ReportListDataRequestType * has binding name 'PointerTons1__ReportListDataRequestType' for type 'ns1:ReportListDataRequestType' */
#ifndef SOAP_TYPE_PointerTons1__ReportListDataRequestType
#define SOAP_TYPE_PointerTons1__ReportListDataRequestType (153)
#endif

/* ns1__DefaultWorkspaceRequestType * has binding name 'PointerTons1__DefaultWorkspaceRequestType' for type 'ns1:DefaultWorkspaceRequestType' */
#ifndef SOAP_TYPE_PointerTons1__DefaultWorkspaceRequestType
#define SOAP_TYPE_PointerTons1__DefaultWorkspaceRequestType (149)
#endif

/* ns1__BriefInfoRequestType * has binding name 'PointerTons1__BriefInfoRequestType' for type 'ns1:BriefInfoRequestType' */
#ifndef SOAP_TYPE_PointerTons1__BriefInfoRequestType
#define SOAP_TYPE_PointerTons1__BriefInfoRequestType (145)
#endif

/* ns1__LoginRequestType * has binding name 'PointerTons1__LoginRequestType' for type 'ns1:LoginRequestType' */
#ifndef SOAP_TYPE_PointerTons1__LoginRequestType
#define SOAP_TYPE_PointerTons1__LoginRequestType (122)
#endif

/* ns1__GenRequestType * has binding name 'PointerTons1__GenRequestType' for type 'ns1:GenRequestType' */
#ifndef SOAP_TYPE_PointerTons1__GenRequestType
#define SOAP_TYPE_PointerTons1__GenRequestType (118)
#endif

/* ns1__GenInfoRequestType * has binding name 'PointerTons1__GenInfoRequestType' for type 'ns1:GenInfoRequestType' */
#ifndef SOAP_TYPE_PointerTons1__GenInfoRequestType
#define SOAP_TYPE_PointerTons1__GenInfoRequestType (90)
#endif

/* ns1__StatItemType * has binding name 'PointerTons1__StatItemType' for type 'ns1:StatItemType' */
#ifndef SOAP_TYPE_PointerTons1__StatItemType
#define SOAP_TYPE_PointerTons1__StatItemType (88)
#endif

/* ns1__SuperGroupListDataItemType * has binding name 'PointerTons1__SuperGroupListDataItemType' for type 'ns1:SuperGroupListDataItemType' */
#ifndef SOAP_TYPE_PointerTons1__SuperGroupListDataItemType
#define SOAP_TYPE_PointerTons1__SuperGroupListDataItemType (86)
#endif

/* ns1__DNISListDataItemType * has binding name 'PointerTons1__DNISListDataItemType' for type 'ns1:DNISListDataItemType' */
#ifndef SOAP_TYPE_PointerTons1__DNISListDataItemType
#define SOAP_TYPE_PointerTons1__DNISListDataItemType (84)
#endif

/* ns1__ReportListDataItemType * has binding name 'PointerTons1__ReportListDataItemType' for type 'ns1:ReportListDataItemType' */
#ifndef SOAP_TYPE_PointerTons1__ReportListDataItemType
#define SOAP_TYPE_PointerTons1__ReportListDataItemType (82)
#endif

/* ns1__DefaultWorkspaceItemType * has binding name 'PointerTons1__DefaultWorkspaceItemType' for type 'ns1:DefaultWorkspaceItemType' */
#ifndef SOAP_TYPE_PointerTons1__DefaultWorkspaceItemType
#define SOAP_TYPE_PointerTons1__DefaultWorkspaceItemType (80)
#endif

/* ns1__AgentsListDataItemType * has binding name 'PointerTons1__AgentsListDataItemType' for type 'ns1:AgentsListDataItemType' */
#ifndef SOAP_TYPE_PointerTons1__AgentsListDataItemType
#define SOAP_TYPE_PointerTons1__AgentsListDataItemType (77)
#endif

/* ns1__GenListDataItemType * has binding name 'PointerTons1__GenListDataItemType' for type 'ns1:GenListDataItemType' */
#ifndef SOAP_TYPE_PointerTons1__GenListDataItemType
#define SOAP_TYPE_PointerTons1__GenListDataItemType (75)
#endif

/* ns1__GroupListDataItemType * has binding name 'PointerTons1__GroupListDataItemType' for type 'ns1:GroupListDataItemType' */
#ifndef SOAP_TYPE_PointerTons1__GroupListDataItemType
#define SOAP_TYPE_PointerTons1__GroupListDataItemType (73)
#endif

/* ns1__returnDataRowsPerSuperGroup * has binding name 'PointerTons1__returnDataRowsPerSuperGroup' for type 'ns1:returnDataRowsPerSuperGroup' */
#ifndef SOAP_TYPE_PointerTons1__returnDataRowsPerSuperGroup
#define SOAP_TYPE_PointerTons1__returnDataRowsPerSuperGroup (71)
#endif

/* ns1__returnDataRowsPerGroup * has binding name 'PointerTons1__returnDataRowsPerGroup' for type 'ns1:returnDataRowsPerGroup' */
#ifndef SOAP_TYPE_PointerTons1__returnDataRowsPerGroup
#define SOAP_TYPE_PointerTons1__returnDataRowsPerGroup (69)
#endif

/* ns1__DataItemRow * has binding name 'PointerTons1__DataItemRow' for type 'ns1:DataItemRow' */
#ifndef SOAP_TYPE_PointerTons1__DataItemRow
#define SOAP_TYPE_PointerTons1__DataItemRow (67)
#endif

/* ns1__BlockItemType * has binding name 'PointerTons1__BlockItemType' for type 'ns1:BlockItemType' */
#ifndef SOAP_TYPE_PointerTons1__BlockItemType
#define SOAP_TYPE_PointerTons1__BlockItemType (65)
#endif

/* ns1__ResponseInfoHeaderType * has binding name 'PointerTons1__ResponseInfoHeaderType' for type 'ns1:ResponseInfoHeaderType' */
#ifndef SOAP_TYPE_PointerTons1__ResponseInfoHeaderType
#define SOAP_TYPE_PointerTons1__ResponseInfoHeaderType (64)
#endif

/* ns1__DataItemType * has binding name 'PointerTons1__DataItemType' for type 'ns1:DataItemType' */
#ifndef SOAP_TYPE_PointerTons1__DataItemType
#define SOAP_TYPE_PointerTons1__DataItemType (62)
#endif

/* unsigned int * has binding name 'PointerTounsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_PointerTounsignedInt
#define SOAP_TYPE_PointerTounsignedInt (61)
#endif

/* ns1__RequestInfoHeaderType * has binding name 'PointerTons1__RequestInfoHeaderType' for type 'ns1:RequestInfoHeaderType' */
#ifndef SOAP_TYPE_PointerTons1__RequestInfoHeaderType
#define SOAP_TYPE_PointerTons1__RequestInfoHeaderType (59)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<ns1__StatItemType *>  has binding name 'std__vectorTemplateOfPointerTons1__StatItemType' for type 'ns1:StatItemType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__StatItemType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__StatItemType (89)
#endif

/* std::vector<ns1__SuperGroupListDataItemType *>  has binding name 'std__vectorTemplateOfPointerTons1__SuperGroupListDataItemType' for type 'ns1:SuperGroupListDataItemType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__SuperGroupListDataItemType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__SuperGroupListDataItemType (87)
#endif

/* std::vector<ns1__DNISListDataItemType *>  has binding name 'std__vectorTemplateOfPointerTons1__DNISListDataItemType' for type 'ns1:DNISListDataItemType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__DNISListDataItemType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__DNISListDataItemType (85)
#endif

/* std::vector<ns1__ReportListDataItemType *>  has binding name 'std__vectorTemplateOfPointerTons1__ReportListDataItemType' for type 'ns1:ReportListDataItemType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__ReportListDataItemType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__ReportListDataItemType (83)
#endif

/* std::vector<ns1__DefaultWorkspaceItemType *>  has binding name 'std__vectorTemplateOfPointerTons1__DefaultWorkspaceItemType' for type 'ns1:DefaultWorkspaceItemType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__DefaultWorkspaceItemType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__DefaultWorkspaceItemType (81)
#endif

/* std::vector<ns1__AgentsListDataItemType *>  has binding name 'std__vectorTemplateOfPointerTons1__AgentsListDataItemType' for type 'ns1:AgentsListDataItemType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__AgentsListDataItemType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__AgentsListDataItemType (78)
#endif

/* std::vector<ns1__GenListDataItemType *>  has binding name 'std__vectorTemplateOfPointerTons1__GenListDataItemType' for type 'ns1:GenListDataItemType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__GenListDataItemType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__GenListDataItemType (76)
#endif

/* std::vector<ns1__GroupListDataItemType *>  has binding name 'std__vectorTemplateOfPointerTons1__GroupListDataItemType' for type 'ns1:GroupListDataItemType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__GroupListDataItemType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__GroupListDataItemType (74)
#endif

/* std::vector<ns1__returnDataRowsPerSuperGroup *>  has binding name 'std__vectorTemplateOfPointerTons1__returnDataRowsPerSuperGroup' for type 'ns1:returnDataRowsPerSuperGroup' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__returnDataRowsPerSuperGroup
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__returnDataRowsPerSuperGroup (72)
#endif

/* std::vector<ns1__returnDataRowsPerGroup *>  has binding name 'std__vectorTemplateOfPointerTons1__returnDataRowsPerGroup' for type 'ns1:returnDataRowsPerGroup' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__returnDataRowsPerGroup
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__returnDataRowsPerGroup (70)
#endif

/* std::vector<ns1__DataItemRow *>  has binding name 'std__vectorTemplateOfPointerTons1__DataItemRow' for type 'ns1:DataItemRow' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__DataItemRow
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__DataItemRow (68)
#endif

/* std::vector<ns1__BlockItemType *>  has binding name 'std__vectorTemplateOfPointerTons1__BlockItemType' for type 'ns1:BlockItemType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__BlockItemType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__BlockItemType (66)
#endif

/* std::vector<ns1__DataItemType *>  has binding name 'std__vectorTemplateOfPointerTons1__DataItemType' for type 'ns1:DataItemType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__DataItemType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__DataItemType (63)
#endif

/* std::vector<unsigned int>  has binding name 'std__vectorTemplateOfunsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_std__vectorTemplateOfunsignedInt
#define SOAP_TYPE_std__vectorTemplateOfunsignedInt (60)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Client-Side Call Stub Functions                                            *
 *                                                                            *
\******************************************************************************/

    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GroupDetailFullInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenInfoRequestType *ns1__RequestGroupDetailFullInfo, ns1__ReturnArrayDataType &ns1__ReturnGroupDetailFullInfo);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GroupQueInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenInfoRequestType *ns1__RequestGroupQueInfo, ns1__ReturnArrayDataType &ns1__ReturnGroupQueInfo);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GroupAgentsInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenInfoRequestType *ns1__RequestGroupAgentsInfo, ns1__ReturnArrayDataType &ns1__ReturnGroupAgentsInfo);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GroupAbndInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenInfoRequestType *ns1__RequestGroupAbndInfo, ns1__ReturnArrayDataType &ns1__ReturnGroupAbndInfo);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GroupIntOvfInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenInfoRequestType *ns1__RequestGroupIntOvfInfo, ns1__ReturnArrayDataType &ns1__ReturnGroupIntOvfInfo);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GroupShiftInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenInfoRequestType *ns1__RequestGroupShiftInfo, ns1__ReturnArrayDataType &ns1__ReturnGroupShiftInfo);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GroupGeneralInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenInfoRequestType *ns1__RequestGroupGeneralInfo, ns1__ReturnArrayDataType &ns1__ReturnGroupGeneralInfo);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GroupPeriodInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenInfoRequestType *ns1__RequestGroupPeriodInfo, ns1__ReturnArrayDataType &ns1__ReturnGroupPeriodInfo);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__IvrApplInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenInfoRequestType *ns1__RequestIvrApplInfo, ns1__ReturnArrayDataType &ns1__ReturnIvrApplInfo);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__IvrPortInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenInfoRequestType *ns1__RequestIvrPortInfo, ns1__ReturnArrayDataType &ns1__ReturnIvrPortInfo);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__IvrGrpInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenInfoRequestType *ns1__RequestIvrGrpInfo, ns1__ReturnArrayDataType &ns1__ReturnIvrGrpInfo);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__MailboxInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenInfoRequestType *ns1__RequestMailboxInfo, ns1__ReturnArrayDataType &ns1__ReturnMailboxInfo);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SuperGroupInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenInfoRequestType *ns1__RequestSuperGroupInfo, ns1__ReturnArrayDataType &ns1__ReturnSuperGroupInfo);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SuperGroupList(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenRequestType *ns1__RequestSuperGroupList, ns1__SuperGroupListReturnType &ns1__ReturnSuperGroupList);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__UserLogin(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__LoginRequestType *ns1__RequestUserLogin, ns1__LoginReturnType &ns1__ReturnUserLogin);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__UserLogout(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenRequestType *ns1__RequestUserLogout, ns1__ResponseInfoHeaderType &ns1__NoDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GroupList(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenRequestType *ns1__RequestGroupList, ns1__GroupListReturnType &ns1__ReturnGroupList);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__IvrPortGroupList(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenRequestType *ns1__RequestIvrPortGroupList, ns1__GenListReturnType &ns1__ReturnIvrPortGroupList);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__IvrAppList(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenRequestType *ns1__RequestIvrAppList, ns1__GenListReturnType &ns1__ReturnIvrAppList);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__MailAccList(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenRequestType *ns1__RequestMailAccList, ns1__GenListReturnType &ns1__ReturnMailAccList);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__AgentsPerGroupInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenInfoRequestType *ns1__RequestGroupAgentsMatrix, ns1__ReturnMatrixDataTypePerGroup &ns1__ReturnGroupAgentsMatrix);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__AgentsList(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenRequestType *ns1__RequestAgentsList, ns1__AgentsListReturnType &ns1__ReturnAgentsList);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__BriefAgents(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__BriefInfoRequestType *ns1__RequestBriefAgentsMatrix, ns1__ReturnMatrixDataTypeBG &ns1__ReturnBriefAgentsMatrix);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__DefaultWorkspace(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__DefaultWorkspaceRequestType *ns1__RequestDefaultWorkspace, ns1__DefaultWorkspaceReturnType &ns1__ReturnDefaultWorkspace);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ReportListData(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__ReportListDataRequestType *ns1__RequestReportListData, ns1__ReportListDataReturnType &ns1__ReturnReportListData);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__VoiceDNISList(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenRequestType *ns1__RequestVoiceDNISList, ns1__DNISListReturnType &ns1__ReturnVoiceDNISList);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__EmailDNISList(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenRequestType *ns1__RequestEmailDNISList, ns1__DNISListReturnType &ns1__ReturnEmailDNISList);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__BriefVoiceDNIS(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__BriefInfoRequestType *ns1__RequestBriefVoiceDNISMatrix, ns1__ReturnMatrixDataTypeBG &ns1__ReturnBriefVoiceDNISMatrix);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__BriefEmailDNIS(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__BriefInfoRequestType *ns1__RequestBriefEMailDNISMatrix, ns1__ReturnMatrixDataTypeBG &ns1__ReturnBriefEMailDNISMatrix);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__CommandAgentLoginLogout(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__ACDMultiRequestType *ns1__LoginLogoutRequestAcdComandAgent, ns1__ResponseInfoHeaderType &ns1__NoDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__CommandAgentReleaseResume(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__ACDRequestType *ns1__ReleaseResumeRequestAcd, ns1__ResponseInfoHeaderType &ns1__NoDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__CommandAgentStartChat(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__TFRequestType *ns1__StartChatRequestAcd, ns1__ChatResponseType &ns1__StartChatResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__CommandAgentStartRecord(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__TFRequestType *ns1__StartRecordRequestAcd, ns1__ResponseInfoHeaderType &ns1__NoDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__CommandAgentTelephonyFeatures(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__TFRequestType *ns1__RequestTf, ns1__ResponseInfoHeaderType &ns1__NoDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SaveWorkspase(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__SaveWorkspaseRequestType *ns1__RequestSaveWorkspase, ns1__ResponseInfoHeaderType &ns1__NoDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SaveReport(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__RequestSaveReportType *ns1__RequestSaveReport, ns1__ResponseSaveReportType &ns1__ResponseSaveReport);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__DeleteReport(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__RequestDeleteReportType *ns1__RequestDeleteReport, ns1__ResponseInfoHeaderType &ns1__NoDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__LoginManagerAgentsPerGroup(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__LoginManagerRequestType *ns1__LoginManagerRequestAgents, ns1__GenListReturnType &ns1__LoginManagerResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__LoginManagerGroupsPerAgent(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__LoginManagerRequestType *ns1__LoginManagerRequestGroups, ns1__GenListReturnType &ns1__LoginManagerResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__LoginManagerOneAgentToMultiGroups(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__ACDMultiRequestType *ns1__LoginLogoutRequestAcdOneAgent, ns1__ResponseInfoHeaderType &ns1__NoDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__LoginManagerMultiAgentsToOneGroup(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__ACDMultiRequestType *ns1__LoginLogoutRequestAcdMultiAgents, ns1__ResponseInfoHeaderType &ns1__NoDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__LoginManagerAvailableAgentsForGroup(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__LoginManagerRequestType *ns1__LoginManagerRequestAvailableAgents, ns1__GenListReturnType &ns1__LoginManagerResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__LoginManagerAvailableGroupsForAgent(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__LoginManagerRequestType *ns1__LoginManagerRequestAvailableGroups, ns1__GenListReturnType &ns1__LoginManagerResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ApplicationRegister(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__ApplicationRegisterRequestType *ns1__ApplicationRegisterRequest, ns1__ApplicationReturnType &ns1__ApplicationRegisterResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ApplicationKeepAlive(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__ApplicationKeepAliveRequestType *ns1__ApplicationKeepAliveRequest, ns1__ApplicationReturnType &ns1__ApplicationKeepAliveResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__TraceInternalStat(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__StatRequestType *ns1__TraceInternalStatRequest, ns1__StatReturnType &ns1__TraceInternalStatResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__AgentNeedHelp(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__BriefInfoRequestType *ns1__AgentNeedHelpRequest, ns1__ReturnMatrixDataTypeBG &ns1__AgentNeedHelpResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GroupHourlyInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenInfoRequestType *ns1__GroupHourlyInfoRequest, ns1__ReturnMatrixDataTypePerGroup &ns1__GroupHourlyInfoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GroupDailyBriefInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenInfoRequestType *ns1__GroupDailyBriefInfoRequest, ns1__ReturnArrayDataType &ns1__GroupDailyBriefInfoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GroupDailyDetailedInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenInfoRequestType *ns1__GroupDailyDetailedInfoRequest, ns1__ReturnArrayDataType &ns1__GroupDailyDetailedInfoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SuperGroupHourlyInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenInfoRequestType *ns1__SuperGroupHourlyInfoRequest, ns1__ReturnMatrixDataTypePerSuperGroup &ns1__SuperGroupHourlyInfoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SuperGroupDailyBriefInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GenInfoRequestType *ns1__SuperGroupDailyBriefInfoRequest, ns1__ReturnArrayDataType &ns1__SuperGroupDailyBriefInfoResponse);

/******************************************************************************\
 *                                                                            *
 * Server-Side Operations                                                     *
 *                                                                            *
\******************************************************************************/

    /** Web service operation '__ns1__GroupDetailFullInfo' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GroupDetailFullInfo(struct soap*, ns1__GenInfoRequestType *ns1__RequestGroupDetailFullInfo, ns1__ReturnArrayDataType &ns1__ReturnGroupDetailFullInfo);
    /** Web service operation '__ns1__GroupQueInfo' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GroupQueInfo(struct soap*, ns1__GenInfoRequestType *ns1__RequestGroupQueInfo, ns1__ReturnArrayDataType &ns1__ReturnGroupQueInfo);
    /** Web service operation '__ns1__GroupAgentsInfo' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GroupAgentsInfo(struct soap*, ns1__GenInfoRequestType *ns1__RequestGroupAgentsInfo, ns1__ReturnArrayDataType &ns1__ReturnGroupAgentsInfo);
    /** Web service operation '__ns1__GroupAbndInfo' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GroupAbndInfo(struct soap*, ns1__GenInfoRequestType *ns1__RequestGroupAbndInfo, ns1__ReturnArrayDataType &ns1__ReturnGroupAbndInfo);
    /** Web service operation '__ns1__GroupIntOvfInfo' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GroupIntOvfInfo(struct soap*, ns1__GenInfoRequestType *ns1__RequestGroupIntOvfInfo, ns1__ReturnArrayDataType &ns1__ReturnGroupIntOvfInfo);
    /** Web service operation '__ns1__GroupShiftInfo' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GroupShiftInfo(struct soap*, ns1__GenInfoRequestType *ns1__RequestGroupShiftInfo, ns1__ReturnArrayDataType &ns1__ReturnGroupShiftInfo);
    /** Web service operation '__ns1__GroupGeneralInfo' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GroupGeneralInfo(struct soap*, ns1__GenInfoRequestType *ns1__RequestGroupGeneralInfo, ns1__ReturnArrayDataType &ns1__ReturnGroupGeneralInfo);
    /** Web service operation '__ns1__GroupPeriodInfo' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GroupPeriodInfo(struct soap*, ns1__GenInfoRequestType *ns1__RequestGroupPeriodInfo, ns1__ReturnArrayDataType &ns1__ReturnGroupPeriodInfo);
    /** Web service operation '__ns1__IvrApplInfo' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__IvrApplInfo(struct soap*, ns1__GenInfoRequestType *ns1__RequestIvrApplInfo, ns1__ReturnArrayDataType &ns1__ReturnIvrApplInfo);
    /** Web service operation '__ns1__IvrPortInfo' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__IvrPortInfo(struct soap*, ns1__GenInfoRequestType *ns1__RequestIvrPortInfo, ns1__ReturnArrayDataType &ns1__ReturnIvrPortInfo);
    /** Web service operation '__ns1__IvrGrpInfo' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__IvrGrpInfo(struct soap*, ns1__GenInfoRequestType *ns1__RequestIvrGrpInfo, ns1__ReturnArrayDataType &ns1__ReturnIvrGrpInfo);
    /** Web service operation '__ns1__MailboxInfo' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__MailboxInfo(struct soap*, ns1__GenInfoRequestType *ns1__RequestMailboxInfo, ns1__ReturnArrayDataType &ns1__ReturnMailboxInfo);
    /** Web service operation '__ns1__SuperGroupInfo' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__SuperGroupInfo(struct soap*, ns1__GenInfoRequestType *ns1__RequestSuperGroupInfo, ns1__ReturnArrayDataType &ns1__ReturnSuperGroupInfo);
    /** Web service operation '__ns1__SuperGroupList' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__SuperGroupList(struct soap*, ns1__GenRequestType *ns1__RequestSuperGroupList, ns1__SuperGroupListReturnType &ns1__ReturnSuperGroupList);
    /** Web service operation '__ns1__UserLogin' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__UserLogin(struct soap*, ns1__LoginRequestType *ns1__RequestUserLogin, ns1__LoginReturnType &ns1__ReturnUserLogin);
    /** Web service operation '__ns1__UserLogout' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__UserLogout(struct soap*, ns1__GenRequestType *ns1__RequestUserLogout, ns1__ResponseInfoHeaderType &ns1__NoDataResponse);
    /** Web service operation '__ns1__GroupList' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GroupList(struct soap*, ns1__GenRequestType *ns1__RequestGroupList, ns1__GroupListReturnType &ns1__ReturnGroupList);
    /** Web service operation '__ns1__IvrPortGroupList' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__IvrPortGroupList(struct soap*, ns1__GenRequestType *ns1__RequestIvrPortGroupList, ns1__GenListReturnType &ns1__ReturnIvrPortGroupList);
    /** Web service operation '__ns1__IvrAppList' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__IvrAppList(struct soap*, ns1__GenRequestType *ns1__RequestIvrAppList, ns1__GenListReturnType &ns1__ReturnIvrAppList);
    /** Web service operation '__ns1__MailAccList' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__MailAccList(struct soap*, ns1__GenRequestType *ns1__RequestMailAccList, ns1__GenListReturnType &ns1__ReturnMailAccList);
    /** Web service operation '__ns1__AgentsPerGroupInfo' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__AgentsPerGroupInfo(struct soap*, ns1__GenInfoRequestType *ns1__RequestGroupAgentsMatrix, ns1__ReturnMatrixDataTypePerGroup &ns1__ReturnGroupAgentsMatrix);
    /** Web service operation '__ns1__AgentsList' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__AgentsList(struct soap*, ns1__GenRequestType *ns1__RequestAgentsList, ns1__AgentsListReturnType &ns1__ReturnAgentsList);
    /** Web service operation '__ns1__BriefAgents' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__BriefAgents(struct soap*, ns1__BriefInfoRequestType *ns1__RequestBriefAgentsMatrix, ns1__ReturnMatrixDataTypeBG &ns1__ReturnBriefAgentsMatrix);
    /** Web service operation '__ns1__DefaultWorkspace' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__DefaultWorkspace(struct soap*, ns1__DefaultWorkspaceRequestType *ns1__RequestDefaultWorkspace, ns1__DefaultWorkspaceReturnType &ns1__ReturnDefaultWorkspace);
    /** Web service operation '__ns1__ReportListData' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__ReportListData(struct soap*, ns1__ReportListDataRequestType *ns1__RequestReportListData, ns1__ReportListDataReturnType &ns1__ReturnReportListData);
    /** Web service operation '__ns1__VoiceDNISList' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__VoiceDNISList(struct soap*, ns1__GenRequestType *ns1__RequestVoiceDNISList, ns1__DNISListReturnType &ns1__ReturnVoiceDNISList);
    /** Web service operation '__ns1__EmailDNISList' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__EmailDNISList(struct soap*, ns1__GenRequestType *ns1__RequestEmailDNISList, ns1__DNISListReturnType &ns1__ReturnEmailDNISList);
    /** Web service operation '__ns1__BriefVoiceDNIS' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__BriefVoiceDNIS(struct soap*, ns1__BriefInfoRequestType *ns1__RequestBriefVoiceDNISMatrix, ns1__ReturnMatrixDataTypeBG &ns1__ReturnBriefVoiceDNISMatrix);
    /** Web service operation '__ns1__BriefEmailDNIS' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__BriefEmailDNIS(struct soap*, ns1__BriefInfoRequestType *ns1__RequestBriefEMailDNISMatrix, ns1__ReturnMatrixDataTypeBG &ns1__ReturnBriefEMailDNISMatrix);
    /** Web service operation '__ns1__CommandAgentLoginLogout' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__CommandAgentLoginLogout(struct soap*, ns1__ACDMultiRequestType *ns1__LoginLogoutRequestAcdComandAgent, ns1__ResponseInfoHeaderType &ns1__NoDataResponse);
    /** Web service operation '__ns1__CommandAgentReleaseResume' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__CommandAgentReleaseResume(struct soap*, ns1__ACDRequestType *ns1__ReleaseResumeRequestAcd, ns1__ResponseInfoHeaderType &ns1__NoDataResponse);
    /** Web service operation '__ns1__CommandAgentStartChat' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__CommandAgentStartChat(struct soap*, ns1__TFRequestType *ns1__StartChatRequestAcd, ns1__ChatResponseType &ns1__StartChatResponse);
    /** Web service operation '__ns1__CommandAgentStartRecord' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__CommandAgentStartRecord(struct soap*, ns1__TFRequestType *ns1__StartRecordRequestAcd, ns1__ResponseInfoHeaderType &ns1__NoDataResponse);
    /** Web service operation '__ns1__CommandAgentTelephonyFeatures' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__CommandAgentTelephonyFeatures(struct soap*, ns1__TFRequestType *ns1__RequestTf, ns1__ResponseInfoHeaderType &ns1__NoDataResponse);
    /** Web service operation '__ns1__SaveWorkspase' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__SaveWorkspase(struct soap*, ns1__SaveWorkspaseRequestType *ns1__RequestSaveWorkspase, ns1__ResponseInfoHeaderType &ns1__NoDataResponse);
    /** Web service operation '__ns1__SaveReport' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__SaveReport(struct soap*, ns1__RequestSaveReportType *ns1__RequestSaveReport, ns1__ResponseSaveReportType &ns1__ResponseSaveReport);
    /** Web service operation '__ns1__DeleteReport' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__DeleteReport(struct soap*, ns1__RequestDeleteReportType *ns1__RequestDeleteReport, ns1__ResponseInfoHeaderType &ns1__NoDataResponse);
    /** Web service operation '__ns1__LoginManagerAgentsPerGroup' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__LoginManagerAgentsPerGroup(struct soap*, ns1__LoginManagerRequestType *ns1__LoginManagerRequestAgents, ns1__GenListReturnType &ns1__LoginManagerResponse);
    /** Web service operation '__ns1__LoginManagerGroupsPerAgent' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__LoginManagerGroupsPerAgent(struct soap*, ns1__LoginManagerRequestType *ns1__LoginManagerRequestGroups, ns1__GenListReturnType &ns1__LoginManagerResponse);
    /** Web service operation '__ns1__LoginManagerOneAgentToMultiGroups' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__LoginManagerOneAgentToMultiGroups(struct soap*, ns1__ACDMultiRequestType *ns1__LoginLogoutRequestAcdOneAgent, ns1__ResponseInfoHeaderType &ns1__NoDataResponse);
    /** Web service operation '__ns1__LoginManagerMultiAgentsToOneGroup' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__LoginManagerMultiAgentsToOneGroup(struct soap*, ns1__ACDMultiRequestType *ns1__LoginLogoutRequestAcdMultiAgents, ns1__ResponseInfoHeaderType &ns1__NoDataResponse);
    /** Web service operation '__ns1__LoginManagerAvailableAgentsForGroup' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__LoginManagerAvailableAgentsForGroup(struct soap*, ns1__LoginManagerRequestType *ns1__LoginManagerRequestAvailableAgents, ns1__GenListReturnType &ns1__LoginManagerResponse);
    /** Web service operation '__ns1__LoginManagerAvailableGroupsForAgent' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__LoginManagerAvailableGroupsForAgent(struct soap*, ns1__LoginManagerRequestType *ns1__LoginManagerRequestAvailableGroups, ns1__GenListReturnType &ns1__LoginManagerResponse);
    /** Web service operation '__ns1__ApplicationRegister' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__ApplicationRegister(struct soap*, ns1__ApplicationRegisterRequestType *ns1__ApplicationRegisterRequest, ns1__ApplicationReturnType &ns1__ApplicationRegisterResponse);
    /** Web service operation '__ns1__ApplicationKeepAlive' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__ApplicationKeepAlive(struct soap*, ns1__ApplicationKeepAliveRequestType *ns1__ApplicationKeepAliveRequest, ns1__ApplicationReturnType &ns1__ApplicationKeepAliveResponse);
    /** Web service operation '__ns1__TraceInternalStat' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__TraceInternalStat(struct soap*, ns1__StatRequestType *ns1__TraceInternalStatRequest, ns1__StatReturnType &ns1__TraceInternalStatResponse);
    /** Web service operation '__ns1__AgentNeedHelp' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__AgentNeedHelp(struct soap*, ns1__BriefInfoRequestType *ns1__AgentNeedHelpRequest, ns1__ReturnMatrixDataTypeBG &ns1__AgentNeedHelpResponse);
    /** Web service operation '__ns1__GroupHourlyInfo' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GroupHourlyInfo(struct soap*, ns1__GenInfoRequestType *ns1__GroupHourlyInfoRequest, ns1__ReturnMatrixDataTypePerGroup &ns1__GroupHourlyInfoResponse);
    /** Web service operation '__ns1__GroupDailyBriefInfo' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GroupDailyBriefInfo(struct soap*, ns1__GenInfoRequestType *ns1__GroupDailyBriefInfoRequest, ns1__ReturnArrayDataType &ns1__GroupDailyBriefInfoResponse);
    /** Web service operation '__ns1__GroupDailyDetailedInfo' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GroupDailyDetailedInfo(struct soap*, ns1__GenInfoRequestType *ns1__GroupDailyDetailedInfoRequest, ns1__ReturnArrayDataType &ns1__GroupDailyDetailedInfoResponse);
    /** Web service operation '__ns1__SuperGroupHourlyInfo' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__SuperGroupHourlyInfo(struct soap*, ns1__GenInfoRequestType *ns1__SuperGroupHourlyInfoRequest, ns1__ReturnMatrixDataTypePerSuperGroup &ns1__SuperGroupHourlyInfoResponse);
    /** Web service operation '__ns1__SuperGroupDailyBriefInfo' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__SuperGroupDailyBriefInfo(struct soap*, ns1__GenInfoRequestType *ns1__SuperGroupDailyBriefInfoRequest, ns1__ReturnArrayDataType &ns1__SuperGroupDailyBriefInfoResponse);

/******************************************************************************\
 *                                                                            *
 * Server-Side Skeletons to Invoke Service Operations                         *
 *                                                                            *
\******************************************************************************/

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve(struct soap*);

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve_request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GroupDetailFullInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GroupQueInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GroupAgentsInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GroupAbndInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GroupIntOvfInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GroupShiftInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GroupGeneralInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GroupPeriodInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__IvrApplInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__IvrPortInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__IvrGrpInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__MailboxInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__SuperGroupInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__SuperGroupList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__UserLogin(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__UserLogout(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GroupList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__IvrPortGroupList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__IvrAppList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__MailAccList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__AgentsPerGroupInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__AgentsList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__BriefAgents(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__DefaultWorkspace(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__ReportListData(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__VoiceDNISList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__EmailDNISList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__BriefVoiceDNIS(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__BriefEmailDNIS(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__CommandAgentLoginLogout(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__CommandAgentReleaseResume(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__CommandAgentStartChat(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__CommandAgentStartRecord(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__CommandAgentTelephonyFeatures(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__SaveWorkspase(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__SaveReport(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__DeleteReport(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__LoginManagerAgentsPerGroup(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__LoginManagerGroupsPerAgent(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__LoginManagerOneAgentToMultiGroups(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__LoginManagerMultiAgentsToOneGroup(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__LoginManagerAvailableAgentsForGroup(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__LoginManagerAvailableGroupsForAgent(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__ApplicationRegister(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__ApplicationKeepAlive(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__TraceInternalStat(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__AgentNeedHelp(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GroupHourlyInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GroupDailyBriefInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GroupDailyDetailedInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__SuperGroupHourlyInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__SuperGroupDailyBriefInfo(struct soap*);

#endif

/* End of soapStub.h */
