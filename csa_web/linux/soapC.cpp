/* soapC.cpp
   Generated by gSOAP 2.8.52 for emisweb.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"
#include <proj_gen.h>
#include <bswlog.h>

_USING_BSW
//static BswLog_c soap_obj_log_d(BswMakeLogSite(FC_CSA_WEB, 1),LM_INTER_CSCI, LOGL_DETAILED);

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.52 2019-02-27 09:34:29 GMT")

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_in_short(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__StatReturnType:
		return soap_in_ns1__StatReturnType(soap, NULL, NULL, "ns1:StatReturnType");
	case SOAP_TYPE_ns1__StatItemType:
		return soap_in_ns1__StatItemType(soap, NULL, NULL, "ns1:StatItemType");
	case SOAP_TYPE_ns1__StatRequestType:
		return soap_in_ns1__StatRequestType(soap, NULL, NULL, "ns1:StatRequestType");
	case SOAP_TYPE_ns1__ApplicationReturnType:
		return soap_in_ns1__ApplicationReturnType(soap, NULL, NULL, "ns1:ApplicationReturnType");
	case SOAP_TYPE_ns1__ApplicationKeepAliveRequestType:
		return soap_in_ns1__ApplicationKeepAliveRequestType(soap, NULL, NULL, "ns1:ApplicationKeepAliveRequestType");
	case SOAP_TYPE_ns1__ApplicationRegisterRequestType:
		return soap_in_ns1__ApplicationRegisterRequestType(soap, NULL, NULL, "ns1:ApplicationRegisterRequestType");
	case SOAP_TYPE_ns1__LoginManagerRequestType:
		return soap_in_ns1__LoginManagerRequestType(soap, NULL, NULL, "ns1:LoginManagerRequestType");
	case SOAP_TYPE_ns1__RequestDeleteReportType:
		return soap_in_ns1__RequestDeleteReportType(soap, NULL, NULL, "ns1:RequestDeleteReportType");
	case SOAP_TYPE_ns1__RequestSaveReportType:
		return soap_in_ns1__RequestSaveReportType(soap, NULL, NULL, "ns1:RequestSaveReportType");
	case SOAP_TYPE_ns1__SaveWorkspaseRequestType:
		return soap_in_ns1__SaveWorkspaseRequestType(soap, NULL, NULL, "ns1:SaveWorkspaseRequestType");
	case SOAP_TYPE_ns1__SuperGroupListReturnType:
		return soap_in_ns1__SuperGroupListReturnType(soap, NULL, NULL, "ns1:SuperGroupListReturnType");
	case SOAP_TYPE_ns1__SuperGroupListDataItemType:
		return soap_in_ns1__SuperGroupListDataItemType(soap, NULL, NULL, "ns1:SuperGroupListDataItemType");
	case SOAP_TYPE_ns1__BriefDNISInfoRequestType:
		return soap_in_ns1__BriefDNISInfoRequestType(soap, NULL, NULL, "ns1:BriefDNISInfoRequestType");
	case SOAP_TYPE_ns1__DNISListReturnType:
		return soap_in_ns1__DNISListReturnType(soap, NULL, NULL, "ns1:DNISListReturnType");
	case SOAP_TYPE_ns1__DNISListDataItemType:
		return soap_in_ns1__DNISListDataItemType(soap, NULL, NULL, "ns1:DNISListDataItemType");
	case SOAP_TYPE_ns1__ReportListDataReturnType:
		return soap_in_ns1__ReportListDataReturnType(soap, NULL, NULL, "ns1:ReportListDataReturnType");
	case SOAP_TYPE_ns1__ReportListDataItemType:
		return soap_in_ns1__ReportListDataItemType(soap, NULL, NULL, "ns1:ReportListDataItemType");
	case SOAP_TYPE_ns1__ReportListDataRequestType:
		return soap_in_ns1__ReportListDataRequestType(soap, NULL, NULL, "ns1:ReportListDataRequestType");
	case SOAP_TYPE_ns1__DefaultWorkspaceReturnType:
		return soap_in_ns1__DefaultWorkspaceReturnType(soap, NULL, NULL, "ns1:DefaultWorkspaceReturnType");
	case SOAP_TYPE_ns1__DefaultWorkspaceItemType:
		return soap_in_ns1__DefaultWorkspaceItemType(soap, NULL, NULL, "ns1:DefaultWorkspaceItemType");
	case SOAP_TYPE_ns1__DefaultWorkspaceRequestType:
		return soap_in_ns1__DefaultWorkspaceRequestType(soap, NULL, NULL, "ns1:DefaultWorkspaceRequestType");
	case SOAP_TYPE_ns1__BriefInfoRequestType:
		return soap_in_ns1__BriefInfoRequestType(soap, NULL, NULL, "ns1:BriefInfoRequestType");
	case SOAP_TYPE_ns1__AgentsListReturnType:
		return soap_in_ns1__AgentsListReturnType(soap, NULL, NULL, "ns1:AgentsListReturnType");
	case SOAP_TYPE_ns1__AgentsListDataItemType:
		return soap_in_ns1__AgentsListDataItemType(soap, NULL, NULL, "ns1:AgentsListDataItemType");
	case SOAP_TYPE_ns1__GenListReturnType:
		return soap_in_ns1__GenListReturnType(soap, NULL, NULL, "ns1:GenListReturnType");
	case SOAP_TYPE_ns1__GenListDataItemType:
		return soap_in_ns1__GenListDataItemType(soap, NULL, NULL, "ns1:GenListDataItemType");
	case SOAP_TYPE_ns1__GroupListReturnType:
		return soap_in_ns1__GroupListReturnType(soap, NULL, NULL, "ns1:GroupListReturnType");
	case SOAP_TYPE_ns1__GroupListDataItemType:
		return soap_in_ns1__GroupListDataItemType(soap, NULL, NULL, "ns1:GroupListDataItemType");
	case SOAP_TYPE_ns1__GenRequestType:
		return soap_in_ns1__GenRequestType(soap, NULL, NULL, "ns1:GenRequestType");
	case SOAP_TYPE_ns1__LoginReturnType:
		return soap_in_ns1__LoginReturnType(soap, NULL, NULL, "ns1:LoginReturnType");
	case SOAP_TYPE_ns1__LoginRequestType:
		return soap_in_ns1__LoginRequestType(soap, NULL, NULL, "ns1:LoginRequestType");
	case SOAP_TYPE_ns1__ReturnMatrixDataTypeBG:
		return soap_in_ns1__ReturnMatrixDataTypeBG(soap, NULL, NULL, "ns1:ReturnMatrixDataTypeBG");
	case SOAP_TYPE_ns1__ReturnMatrixDataTypePerSuperGroup:
		return soap_in_ns1__ReturnMatrixDataTypePerSuperGroup(soap, NULL, NULL, "ns1:ReturnMatrixDataTypePerSuperGroup");
	case SOAP_TYPE_ns1__returnDataRowsPerSuperGroup:
		return soap_in_ns1__returnDataRowsPerSuperGroup(soap, NULL, NULL, "ns1:returnDataRowsPerSuperGroup");
	case SOAP_TYPE_ns1__ReturnMatrixDataTypePerGroup:
		return soap_in_ns1__ReturnMatrixDataTypePerGroup(soap, NULL, NULL, "ns1:ReturnMatrixDataTypePerGroup");
	case SOAP_TYPE_ns1__returnDataRowsPerGroup:
		return soap_in_ns1__returnDataRowsPerGroup(soap, NULL, NULL, "ns1:returnDataRowsPerGroup");
	case SOAP_TYPE_ns1__ReturnArrayDataType:
		return soap_in_ns1__ReturnArrayDataType(soap, NULL, NULL, "ns1:ReturnArrayDataType");
	case SOAP_TYPE_ns1__BlockItemType:
		return soap_in_ns1__BlockItemType(soap, NULL, NULL, "ns1:BlockItemType");
	case SOAP_TYPE_ns1__DataItemRow:
		return soap_in_ns1__DataItemRow(soap, NULL, NULL, "ns1:DataItemRow");
	case SOAP_TYPE_ns1__DataItemType:
		return soap_in_ns1__DataItemType(soap, NULL, NULL, "ns1:DataItemType");
	case SOAP_TYPE_ns1__ResponseSaveReportType:
		return soap_in_ns1__ResponseSaveReportType(soap, NULL, NULL, "ns1:ResponseSaveReportType");
	case SOAP_TYPE_ns1__ResponseInfoHeaderType:
		return soap_in_ns1__ResponseInfoHeaderType(soap, NULL, NULL, "ns1:ResponseInfoHeaderType");
	case SOAP_TYPE_ns1__ChatResponseType:
		return soap_in_ns1__ChatResponseType(soap, NULL, NULL, "ns1:ChatResponseType");
	case SOAP_TYPE_ns1__TFRequestType:
		return soap_in_ns1__TFRequestType(soap, NULL, NULL, "ns1:TFRequestType");
	case SOAP_TYPE_ns1__ACDRequestType:
		return soap_in_ns1__ACDRequestType(soap, NULL, NULL, "ns1:ACDRequestType");
	case SOAP_TYPE_ns1__ACDMultiRequestType:
		return soap_in_ns1__ACDMultiRequestType(soap, NULL, NULL, "ns1:ACDMultiRequestType");
	case SOAP_TYPE_ns1__GenInfoRequestType:
		return soap_in_ns1__GenInfoRequestType(soap, NULL, NULL, "ns1:GenInfoRequestType");
	case SOAP_TYPE_ns1__RequestInfoHeaderType:
		return soap_in_ns1__RequestInfoHeaderType(soap, NULL, NULL, "ns1:RequestInfoHeaderType");
	case SOAP_TYPE_PointerTons1__StatRequestType:
		return soap_in_PointerTons1__StatRequestType(soap, NULL, NULL, "ns1:StatRequestType");
	case SOAP_TYPE_PointerTons1__ApplicationKeepAliveRequestType:
		return soap_in_PointerTons1__ApplicationKeepAliveRequestType(soap, NULL, NULL, "ns1:ApplicationKeepAliveRequestType");
	case SOAP_TYPE_PointerTons1__ApplicationRegisterRequestType:
		return soap_in_PointerTons1__ApplicationRegisterRequestType(soap, NULL, NULL, "ns1:ApplicationRegisterRequestType");
	case SOAP_TYPE_PointerTons1__LoginManagerRequestType:
		return soap_in_PointerTons1__LoginManagerRequestType(soap, NULL, NULL, "ns1:LoginManagerRequestType");
	case SOAP_TYPE_PointerTons1__RequestDeleteReportType:
		return soap_in_PointerTons1__RequestDeleteReportType(soap, NULL, NULL, "ns1:RequestDeleteReportType");
	case SOAP_TYPE_PointerTons1__RequestSaveReportType:
		return soap_in_PointerTons1__RequestSaveReportType(soap, NULL, NULL, "ns1:RequestSaveReportType");
	case SOAP_TYPE_PointerTons1__SaveWorkspaseRequestType:
		return soap_in_PointerTons1__SaveWorkspaseRequestType(soap, NULL, NULL, "ns1:SaveWorkspaseRequestType");
	case SOAP_TYPE_PointerTons1__TFRequestType:
		return soap_in_PointerTons1__TFRequestType(soap, NULL, NULL, "ns1:TFRequestType");
	case SOAP_TYPE_PointerTons1__ACDRequestType:
		return soap_in_PointerTons1__ACDRequestType(soap, NULL, NULL, "ns1:ACDRequestType");
	case SOAP_TYPE_PointerTons1__ACDMultiRequestType:
		return soap_in_PointerTons1__ACDMultiRequestType(soap, NULL, NULL, "ns1:ACDMultiRequestType");
	case SOAP_TYPE_PointerTons1__ReportListDataRequestType:
		return soap_in_PointerTons1__ReportListDataRequestType(soap, NULL, NULL, "ns1:ReportListDataRequestType");
	case SOAP_TYPE_PointerTons1__DefaultWorkspaceRequestType:
		return soap_in_PointerTons1__DefaultWorkspaceRequestType(soap, NULL, NULL, "ns1:DefaultWorkspaceRequestType");
	case SOAP_TYPE_PointerTons1__BriefInfoRequestType:
		return soap_in_PointerTons1__BriefInfoRequestType(soap, NULL, NULL, "ns1:BriefInfoRequestType");
	case SOAP_TYPE_PointerTons1__LoginRequestType:
		return soap_in_PointerTons1__LoginRequestType(soap, NULL, NULL, "ns1:LoginRequestType");
	case SOAP_TYPE_PointerTons1__GenRequestType:
		return soap_in_PointerTons1__GenRequestType(soap, NULL, NULL, "ns1:GenRequestType");
	case SOAP_TYPE_PointerTons1__GenInfoRequestType:
		return soap_in_PointerTons1__GenInfoRequestType(soap, NULL, NULL, "ns1:GenInfoRequestType");
	case SOAP_TYPE_PointerTons1__StatItemType:
		return soap_in_PointerTons1__StatItemType(soap, NULL, NULL, "ns1:StatItemType");
	case SOAP_TYPE_PointerTons1__SuperGroupListDataItemType:
		return soap_in_PointerTons1__SuperGroupListDataItemType(soap, NULL, NULL, "ns1:SuperGroupListDataItemType");
	case SOAP_TYPE_PointerTons1__DNISListDataItemType:
		return soap_in_PointerTons1__DNISListDataItemType(soap, NULL, NULL, "ns1:DNISListDataItemType");
	case SOAP_TYPE_PointerTons1__ReportListDataItemType:
		return soap_in_PointerTons1__ReportListDataItemType(soap, NULL, NULL, "ns1:ReportListDataItemType");
	case SOAP_TYPE_PointerTons1__DefaultWorkspaceItemType:
		return soap_in_PointerTons1__DefaultWorkspaceItemType(soap, NULL, NULL, "ns1:DefaultWorkspaceItemType");
	case SOAP_TYPE_PointerTons1__AgentsListDataItemType:
		return soap_in_PointerTons1__AgentsListDataItemType(soap, NULL, NULL, "ns1:AgentsListDataItemType");
	case SOAP_TYPE_PointerTons1__GenListDataItemType:
		return soap_in_PointerTons1__GenListDataItemType(soap, NULL, NULL, "ns1:GenListDataItemType");
	case SOAP_TYPE_PointerTons1__GroupListDataItemType:
		return soap_in_PointerTons1__GroupListDataItemType(soap, NULL, NULL, "ns1:GroupListDataItemType");
	case SOAP_TYPE_PointerTons1__returnDataRowsPerSuperGroup:
		return soap_in_PointerTons1__returnDataRowsPerSuperGroup(soap, NULL, NULL, "ns1:returnDataRowsPerSuperGroup");
	case SOAP_TYPE_PointerTons1__returnDataRowsPerGroup:
		return soap_in_PointerTons1__returnDataRowsPerGroup(soap, NULL, NULL, "ns1:returnDataRowsPerGroup");
	case SOAP_TYPE_PointerTons1__DataItemRow:
		return soap_in_PointerTons1__DataItemRow(soap, NULL, NULL, "ns1:DataItemRow");
	case SOAP_TYPE_PointerTons1__BlockItemType:
		return soap_in_PointerTons1__BlockItemType(soap, NULL, NULL, "ns1:BlockItemType");
	case SOAP_TYPE_PointerTons1__ResponseInfoHeaderType:
		return soap_in_PointerTons1__ResponseInfoHeaderType(soap, NULL, NULL, "ns1:ResponseInfoHeaderType");
	case SOAP_TYPE_PointerTons1__DataItemType:
		return soap_in_PointerTons1__DataItemType(soap, NULL, NULL, "ns1:DataItemType");
	case SOAP_TYPE_PointerTounsignedInt:
		return soap_in_PointerTounsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_PointerTons1__RequestInfoHeaderType:
		return soap_in_PointerTons1__RequestInfoHeaderType(soap, NULL, NULL, "ns1:RequestInfoHeaderType");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StatReturnType"))
		{	*type = SOAP_TYPE_ns1__StatReturnType;
			return soap_in_ns1__StatReturnType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StatItemType"))
		{	*type = SOAP_TYPE_ns1__StatItemType;
			return soap_in_ns1__StatItemType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StatRequestType"))
		{	*type = SOAP_TYPE_ns1__StatRequestType;
			return soap_in_ns1__StatRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ApplicationReturnType"))
		{	*type = SOAP_TYPE_ns1__ApplicationReturnType;
			return soap_in_ns1__ApplicationReturnType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ApplicationKeepAliveRequestType"))
		{	*type = SOAP_TYPE_ns1__ApplicationKeepAliveRequestType;
			return soap_in_ns1__ApplicationKeepAliveRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ApplicationRegisterRequestType"))
		{	*type = SOAP_TYPE_ns1__ApplicationRegisterRequestType;
			return soap_in_ns1__ApplicationRegisterRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LoginManagerRequestType"))
		{	*type = SOAP_TYPE_ns1__LoginManagerRequestType;
			return soap_in_ns1__LoginManagerRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RequestDeleteReportType"))
		{	*type = SOAP_TYPE_ns1__RequestDeleteReportType;
			return soap_in_ns1__RequestDeleteReportType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RequestSaveReportType"))
		{	*type = SOAP_TYPE_ns1__RequestSaveReportType;
			return soap_in_ns1__RequestSaveReportType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SaveWorkspaseRequestType"))
		{	*type = SOAP_TYPE_ns1__SaveWorkspaseRequestType;
			return soap_in_ns1__SaveWorkspaseRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SuperGroupListReturnType"))
		{	*type = SOAP_TYPE_ns1__SuperGroupListReturnType;
			return soap_in_ns1__SuperGroupListReturnType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SuperGroupListDataItemType"))
		{	*type = SOAP_TYPE_ns1__SuperGroupListDataItemType;
			return soap_in_ns1__SuperGroupListDataItemType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BriefDNISInfoRequestType"))
		{	*type = SOAP_TYPE_ns1__BriefDNISInfoRequestType;
			return soap_in_ns1__BriefDNISInfoRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DNISListReturnType"))
		{	*type = SOAP_TYPE_ns1__DNISListReturnType;
			return soap_in_ns1__DNISListReturnType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DNISListDataItemType"))
		{	*type = SOAP_TYPE_ns1__DNISListDataItemType;
			return soap_in_ns1__DNISListDataItemType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReportListDataReturnType"))
		{	*type = SOAP_TYPE_ns1__ReportListDataReturnType;
			return soap_in_ns1__ReportListDataReturnType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReportListDataItemType"))
		{	*type = SOAP_TYPE_ns1__ReportListDataItemType;
			return soap_in_ns1__ReportListDataItemType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReportListDataRequestType"))
		{	*type = SOAP_TYPE_ns1__ReportListDataRequestType;
			return soap_in_ns1__ReportListDataRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DefaultWorkspaceReturnType"))
		{	*type = SOAP_TYPE_ns1__DefaultWorkspaceReturnType;
			return soap_in_ns1__DefaultWorkspaceReturnType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DefaultWorkspaceItemType"))
		{	*type = SOAP_TYPE_ns1__DefaultWorkspaceItemType;
			return soap_in_ns1__DefaultWorkspaceItemType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DefaultWorkspaceRequestType"))
		{	*type = SOAP_TYPE_ns1__DefaultWorkspaceRequestType;
			return soap_in_ns1__DefaultWorkspaceRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BriefInfoRequestType"))
		{	*type = SOAP_TYPE_ns1__BriefInfoRequestType;
			return soap_in_ns1__BriefInfoRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AgentsListReturnType"))
		{	*type = SOAP_TYPE_ns1__AgentsListReturnType;
			return soap_in_ns1__AgentsListReturnType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AgentsListDataItemType"))
		{	*type = SOAP_TYPE_ns1__AgentsListDataItemType;
			return soap_in_ns1__AgentsListDataItemType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GenListReturnType"))
		{	*type = SOAP_TYPE_ns1__GenListReturnType;
			return soap_in_ns1__GenListReturnType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GenListDataItemType"))
		{	*type = SOAP_TYPE_ns1__GenListDataItemType;
			return soap_in_ns1__GenListDataItemType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GroupListReturnType"))
		{	*type = SOAP_TYPE_ns1__GroupListReturnType;
			return soap_in_ns1__GroupListReturnType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GroupListDataItemType"))
		{	*type = SOAP_TYPE_ns1__GroupListDataItemType;
			return soap_in_ns1__GroupListDataItemType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GenRequestType"))
		{	*type = SOAP_TYPE_ns1__GenRequestType;
			return soap_in_ns1__GenRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LoginReturnType"))
		{	*type = SOAP_TYPE_ns1__LoginReturnType;
			return soap_in_ns1__LoginReturnType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LoginRequestType"))
		{	*type = SOAP_TYPE_ns1__LoginRequestType;
			return soap_in_ns1__LoginRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReturnMatrixDataTypeBG"))
		{	*type = SOAP_TYPE_ns1__ReturnMatrixDataTypeBG;
			return soap_in_ns1__ReturnMatrixDataTypeBG(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReturnMatrixDataTypePerSuperGroup"))
		{	*type = SOAP_TYPE_ns1__ReturnMatrixDataTypePerSuperGroup;
			return soap_in_ns1__ReturnMatrixDataTypePerSuperGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:returnDataRowsPerSuperGroup"))
		{	*type = SOAP_TYPE_ns1__returnDataRowsPerSuperGroup;
			return soap_in_ns1__returnDataRowsPerSuperGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReturnMatrixDataTypePerGroup"))
		{	*type = SOAP_TYPE_ns1__ReturnMatrixDataTypePerGroup;
			return soap_in_ns1__ReturnMatrixDataTypePerGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:returnDataRowsPerGroup"))
		{	*type = SOAP_TYPE_ns1__returnDataRowsPerGroup;
			return soap_in_ns1__returnDataRowsPerGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReturnArrayDataType"))
		{	*type = SOAP_TYPE_ns1__ReturnArrayDataType;
			return soap_in_ns1__ReturnArrayDataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BlockItemType"))
		{	*type = SOAP_TYPE_ns1__BlockItemType;
			return soap_in_ns1__BlockItemType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DataItemRow"))
		{	*type = SOAP_TYPE_ns1__DataItemRow;
			return soap_in_ns1__DataItemRow(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DataItemType"))
		{	*type = SOAP_TYPE_ns1__DataItemType;
			return soap_in_ns1__DataItemType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ResponseSaveReportType"))
		{	*type = SOAP_TYPE_ns1__ResponseSaveReportType;
			return soap_in_ns1__ResponseSaveReportType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ResponseInfoHeaderType"))
		{	*type = SOAP_TYPE_ns1__ResponseInfoHeaderType;
			return soap_in_ns1__ResponseInfoHeaderType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChatResponseType"))
		{	*type = SOAP_TYPE_ns1__ChatResponseType;
			return soap_in_ns1__ChatResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TFRequestType"))
		{	*type = SOAP_TYPE_ns1__TFRequestType;
			return soap_in_ns1__TFRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ACDRequestType"))
		{	*type = SOAP_TYPE_ns1__ACDRequestType;
			return soap_in_ns1__ACDRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ACDMultiRequestType"))
		{	*type = SOAP_TYPE_ns1__ACDMultiRequestType;
			return soap_in_ns1__ACDMultiRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GenInfoRequestType"))
		{	*type = SOAP_TYPE_ns1__GenInfoRequestType;
			return soap_in_ns1__GenInfoRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RequestInfoHeaderType"))
		{	*type = SOAP_TYPE_ns1__RequestInfoHeaderType;
			return soap_in_ns1__RequestInfoHeaderType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_short;
			return soap_in_short(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				if (soap_ignore(soap) || soap_element_end_in(soap, NULL))
					return soap->error;
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_out_short(soap, tag, id, (const short *)ptr, "xsd:short");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_ns1__StatReturnType:
		return ((ns1__StatReturnType *)ptr)->soap_out(soap, tag, id, "ns1:StatReturnType");
	case SOAP_TYPE_ns1__StatItemType:
		return ((ns1__StatItemType *)ptr)->soap_out(soap, tag, id, "ns1:StatItemType");
	case SOAP_TYPE_ns1__StatRequestType:
		return ((ns1__StatRequestType *)ptr)->soap_out(soap, tag, id, "ns1:StatRequestType");
	case SOAP_TYPE_ns1__ApplicationReturnType:
		return ((ns1__ApplicationReturnType *)ptr)->soap_out(soap, tag, id, "ns1:ApplicationReturnType");
	case SOAP_TYPE_ns1__ApplicationKeepAliveRequestType:
		return ((ns1__ApplicationKeepAliveRequestType *)ptr)->soap_out(soap, tag, id, "ns1:ApplicationKeepAliveRequestType");
	case SOAP_TYPE_ns1__ApplicationRegisterRequestType:
		return ((ns1__ApplicationRegisterRequestType *)ptr)->soap_out(soap, tag, id, "ns1:ApplicationRegisterRequestType");
	case SOAP_TYPE_ns1__LoginManagerRequestType:
		return ((ns1__LoginManagerRequestType *)ptr)->soap_out(soap, tag, id, "ns1:LoginManagerRequestType");
	case SOAP_TYPE_ns1__RequestDeleteReportType:
		return ((ns1__RequestDeleteReportType *)ptr)->soap_out(soap, tag, id, "ns1:RequestDeleteReportType");
	case SOAP_TYPE_ns1__RequestSaveReportType:
		return ((ns1__RequestSaveReportType *)ptr)->soap_out(soap, tag, id, "ns1:RequestSaveReportType");
	case SOAP_TYPE_ns1__SaveWorkspaseRequestType:
		return ((ns1__SaveWorkspaseRequestType *)ptr)->soap_out(soap, tag, id, "ns1:SaveWorkspaseRequestType");
	case SOAP_TYPE_ns1__SuperGroupListReturnType:
		return ((ns1__SuperGroupListReturnType *)ptr)->soap_out(soap, tag, id, "ns1:SuperGroupListReturnType");
	case SOAP_TYPE_ns1__SuperGroupListDataItemType:
		return ((ns1__SuperGroupListDataItemType *)ptr)->soap_out(soap, tag, id, "ns1:SuperGroupListDataItemType");
	case SOAP_TYPE_ns1__BriefDNISInfoRequestType:
		return ((ns1__BriefDNISInfoRequestType *)ptr)->soap_out(soap, tag, id, "ns1:BriefDNISInfoRequestType");
	case SOAP_TYPE_ns1__DNISListReturnType:
		return ((ns1__DNISListReturnType *)ptr)->soap_out(soap, tag, id, "ns1:DNISListReturnType");
	case SOAP_TYPE_ns1__DNISListDataItemType:
		return ((ns1__DNISListDataItemType *)ptr)->soap_out(soap, tag, id, "ns1:DNISListDataItemType");
	case SOAP_TYPE_ns1__ReportListDataReturnType:
		return ((ns1__ReportListDataReturnType *)ptr)->soap_out(soap, tag, id, "ns1:ReportListDataReturnType");
	case SOAP_TYPE_ns1__ReportListDataItemType:
		return ((ns1__ReportListDataItemType *)ptr)->soap_out(soap, tag, id, "ns1:ReportListDataItemType");
	case SOAP_TYPE_ns1__ReportListDataRequestType:
		return ((ns1__ReportListDataRequestType *)ptr)->soap_out(soap, tag, id, "ns1:ReportListDataRequestType");
	case SOAP_TYPE_ns1__DefaultWorkspaceReturnType:
		return ((ns1__DefaultWorkspaceReturnType *)ptr)->soap_out(soap, tag, id, "ns1:DefaultWorkspaceReturnType");
	case SOAP_TYPE_ns1__DefaultWorkspaceItemType:
		return ((ns1__DefaultWorkspaceItemType *)ptr)->soap_out(soap, tag, id, "ns1:DefaultWorkspaceItemType");
	case SOAP_TYPE_ns1__DefaultWorkspaceRequestType:
		return ((ns1__DefaultWorkspaceRequestType *)ptr)->soap_out(soap, tag, id, "ns1:DefaultWorkspaceRequestType");
	case SOAP_TYPE_ns1__BriefInfoRequestType:
		return ((ns1__BriefInfoRequestType *)ptr)->soap_out(soap, tag, id, "ns1:BriefInfoRequestType");
	case SOAP_TYPE_ns1__AgentsListReturnType:
		return ((ns1__AgentsListReturnType *)ptr)->soap_out(soap, tag, id, "ns1:AgentsListReturnType");
	case SOAP_TYPE_ns1__AgentsListDataItemType:
		return ((ns1__AgentsListDataItemType *)ptr)->soap_out(soap, tag, id, "ns1:AgentsListDataItemType");
	case SOAP_TYPE_ns1__GenListReturnType:
		return ((ns1__GenListReturnType *)ptr)->soap_out(soap, tag, id, "ns1:GenListReturnType");
	case SOAP_TYPE_ns1__GenListDataItemType:
		return ((ns1__GenListDataItemType *)ptr)->soap_out(soap, tag, id, "ns1:GenListDataItemType");
	case SOAP_TYPE_ns1__GroupListReturnType:
		return ((ns1__GroupListReturnType *)ptr)->soap_out(soap, tag, id, "ns1:GroupListReturnType");
	case SOAP_TYPE_ns1__GroupListDataItemType:
		return ((ns1__GroupListDataItemType *)ptr)->soap_out(soap, tag, id, "ns1:GroupListDataItemType");
	case SOAP_TYPE_ns1__GenRequestType:
		return ((ns1__GenRequestType *)ptr)->soap_out(soap, tag, id, "ns1:GenRequestType");
	case SOAP_TYPE_ns1__LoginReturnType:
		return ((ns1__LoginReturnType *)ptr)->soap_out(soap, tag, id, "ns1:LoginReturnType");
	case SOAP_TYPE_ns1__LoginRequestType:
		return ((ns1__LoginRequestType *)ptr)->soap_out(soap, tag, id, "ns1:LoginRequestType");
	case SOAP_TYPE_ns1__ReturnMatrixDataTypeBG:
		return ((ns1__ReturnMatrixDataTypeBG *)ptr)->soap_out(soap, tag, id, "ns1:ReturnMatrixDataTypeBG");
	case SOAP_TYPE_ns1__ReturnMatrixDataTypePerSuperGroup:
		return ((ns1__ReturnMatrixDataTypePerSuperGroup *)ptr)->soap_out(soap, tag, id, "ns1:ReturnMatrixDataTypePerSuperGroup");
	case SOAP_TYPE_ns1__returnDataRowsPerSuperGroup:
		return ((ns1__returnDataRowsPerSuperGroup *)ptr)->soap_out(soap, tag, id, "ns1:returnDataRowsPerSuperGroup");
	case SOAP_TYPE_ns1__ReturnMatrixDataTypePerGroup:
		return ((ns1__ReturnMatrixDataTypePerGroup *)ptr)->soap_out(soap, tag, id, "ns1:ReturnMatrixDataTypePerGroup");
	case SOAP_TYPE_ns1__returnDataRowsPerGroup:
		return ((ns1__returnDataRowsPerGroup *)ptr)->soap_out(soap, tag, id, "ns1:returnDataRowsPerGroup");
	case SOAP_TYPE_ns1__ReturnArrayDataType:
		return ((ns1__ReturnArrayDataType *)ptr)->soap_out(soap, tag, id, "ns1:ReturnArrayDataType");
	case SOAP_TYPE_ns1__BlockItemType:
		return ((ns1__BlockItemType *)ptr)->soap_out(soap, tag, id, "ns1:BlockItemType");
	case SOAP_TYPE_ns1__DataItemRow:
		return ((ns1__DataItemRow *)ptr)->soap_out(soap, tag, id, "ns1:DataItemRow");
	case SOAP_TYPE_ns1__DataItemType:
		return ((ns1__DataItemType *)ptr)->soap_out(soap, tag, id, "ns1:DataItemType");
	case SOAP_TYPE_ns1__ResponseSaveReportType:
		return ((ns1__ResponseSaveReportType *)ptr)->soap_out(soap, tag, id, "ns1:ResponseSaveReportType");
	case SOAP_TYPE_ns1__ResponseInfoHeaderType:
		return ((ns1__ResponseInfoHeaderType *)ptr)->soap_out(soap, tag, id, "ns1:ResponseInfoHeaderType");
	case SOAP_TYPE_ns1__ChatResponseType:
		return ((ns1__ChatResponseType *)ptr)->soap_out(soap, tag, id, "ns1:ChatResponseType");
	case SOAP_TYPE_ns1__TFRequestType:
		return ((ns1__TFRequestType *)ptr)->soap_out(soap, tag, id, "ns1:TFRequestType");
	case SOAP_TYPE_ns1__ACDRequestType:
		return ((ns1__ACDRequestType *)ptr)->soap_out(soap, tag, id, "ns1:ACDRequestType");
	case SOAP_TYPE_ns1__ACDMultiRequestType:
		return ((ns1__ACDMultiRequestType *)ptr)->soap_out(soap, tag, id, "ns1:ACDMultiRequestType");
	case SOAP_TYPE_ns1__GenInfoRequestType:
		return ((ns1__GenInfoRequestType *)ptr)->soap_out(soap, tag, id, "ns1:GenInfoRequestType");
	case SOAP_TYPE_ns1__RequestInfoHeaderType:
		return ((ns1__RequestInfoHeaderType *)ptr)->soap_out(soap, tag, id, "ns1:RequestInfoHeaderType");
	case SOAP_TYPE_PointerTons1__StatRequestType:
		return soap_out_PointerTons1__StatRequestType(soap, tag, id, (ns1__StatRequestType *const*)ptr, "ns1:StatRequestType");
	case SOAP_TYPE_PointerTons1__ApplicationKeepAliveRequestType:
		return soap_out_PointerTons1__ApplicationKeepAliveRequestType(soap, tag, id, (ns1__ApplicationKeepAliveRequestType *const*)ptr, "ns1:ApplicationKeepAliveRequestType");
	case SOAP_TYPE_PointerTons1__ApplicationRegisterRequestType:
		return soap_out_PointerTons1__ApplicationRegisterRequestType(soap, tag, id, (ns1__ApplicationRegisterRequestType *const*)ptr, "ns1:ApplicationRegisterRequestType");
	case SOAP_TYPE_PointerTons1__LoginManagerRequestType:
		return soap_out_PointerTons1__LoginManagerRequestType(soap, tag, id, (ns1__LoginManagerRequestType *const*)ptr, "ns1:LoginManagerRequestType");
	case SOAP_TYPE_PointerTons1__RequestDeleteReportType:
		return soap_out_PointerTons1__RequestDeleteReportType(soap, tag, id, (ns1__RequestDeleteReportType *const*)ptr, "ns1:RequestDeleteReportType");
	case SOAP_TYPE_PointerTons1__RequestSaveReportType:
		return soap_out_PointerTons1__RequestSaveReportType(soap, tag, id, (ns1__RequestSaveReportType *const*)ptr, "ns1:RequestSaveReportType");
	case SOAP_TYPE_PointerTons1__SaveWorkspaseRequestType:
		return soap_out_PointerTons1__SaveWorkspaseRequestType(soap, tag, id, (ns1__SaveWorkspaseRequestType *const*)ptr, "ns1:SaveWorkspaseRequestType");
	case SOAP_TYPE_PointerTons1__TFRequestType:
		return soap_out_PointerTons1__TFRequestType(soap, tag, id, (ns1__TFRequestType *const*)ptr, "ns1:TFRequestType");
	case SOAP_TYPE_PointerTons1__ACDRequestType:
		return soap_out_PointerTons1__ACDRequestType(soap, tag, id, (ns1__ACDRequestType *const*)ptr, "ns1:ACDRequestType");
	case SOAP_TYPE_PointerTons1__ACDMultiRequestType:
		return soap_out_PointerTons1__ACDMultiRequestType(soap, tag, id, (ns1__ACDMultiRequestType *const*)ptr, "ns1:ACDMultiRequestType");
	case SOAP_TYPE_PointerTons1__ReportListDataRequestType:
		return soap_out_PointerTons1__ReportListDataRequestType(soap, tag, id, (ns1__ReportListDataRequestType *const*)ptr, "ns1:ReportListDataRequestType");
	case SOAP_TYPE_PointerTons1__DefaultWorkspaceRequestType:
		return soap_out_PointerTons1__DefaultWorkspaceRequestType(soap, tag, id, (ns1__DefaultWorkspaceRequestType *const*)ptr, "ns1:DefaultWorkspaceRequestType");
	case SOAP_TYPE_PointerTons1__BriefInfoRequestType:
		return soap_out_PointerTons1__BriefInfoRequestType(soap, tag, id, (ns1__BriefInfoRequestType *const*)ptr, "ns1:BriefInfoRequestType");
	case SOAP_TYPE_PointerTons1__LoginRequestType:
		return soap_out_PointerTons1__LoginRequestType(soap, tag, id, (ns1__LoginRequestType *const*)ptr, "ns1:LoginRequestType");
	case SOAP_TYPE_PointerTons1__GenRequestType:
		return soap_out_PointerTons1__GenRequestType(soap, tag, id, (ns1__GenRequestType *const*)ptr, "ns1:GenRequestType");
	case SOAP_TYPE_PointerTons1__GenInfoRequestType:
		return soap_out_PointerTons1__GenInfoRequestType(soap, tag, id, (ns1__GenInfoRequestType *const*)ptr, "ns1:GenInfoRequestType");
	case SOAP_TYPE_PointerTons1__StatItemType:
		return soap_out_PointerTons1__StatItemType(soap, tag, id, (ns1__StatItemType *const*)ptr, "ns1:StatItemType");
	case SOAP_TYPE_PointerTons1__SuperGroupListDataItemType:
		return soap_out_PointerTons1__SuperGroupListDataItemType(soap, tag, id, (ns1__SuperGroupListDataItemType *const*)ptr, "ns1:SuperGroupListDataItemType");
	case SOAP_TYPE_PointerTons1__DNISListDataItemType:
		return soap_out_PointerTons1__DNISListDataItemType(soap, tag, id, (ns1__DNISListDataItemType *const*)ptr, "ns1:DNISListDataItemType");
	case SOAP_TYPE_PointerTons1__ReportListDataItemType:
		return soap_out_PointerTons1__ReportListDataItemType(soap, tag, id, (ns1__ReportListDataItemType *const*)ptr, "ns1:ReportListDataItemType");
	case SOAP_TYPE_PointerTons1__DefaultWorkspaceItemType:
		return soap_out_PointerTons1__DefaultWorkspaceItemType(soap, tag, id, (ns1__DefaultWorkspaceItemType *const*)ptr, "ns1:DefaultWorkspaceItemType");
	case SOAP_TYPE_PointerTons1__AgentsListDataItemType:
		return soap_out_PointerTons1__AgentsListDataItemType(soap, tag, id, (ns1__AgentsListDataItemType *const*)ptr, "ns1:AgentsListDataItemType");
	case SOAP_TYPE_PointerTons1__GenListDataItemType:
		return soap_out_PointerTons1__GenListDataItemType(soap, tag, id, (ns1__GenListDataItemType *const*)ptr, "ns1:GenListDataItemType");
	case SOAP_TYPE_PointerTons1__GroupListDataItemType:
		return soap_out_PointerTons1__GroupListDataItemType(soap, tag, id, (ns1__GroupListDataItemType *const*)ptr, "ns1:GroupListDataItemType");
	case SOAP_TYPE_PointerTons1__returnDataRowsPerSuperGroup:
		return soap_out_PointerTons1__returnDataRowsPerSuperGroup(soap, tag, id, (ns1__returnDataRowsPerSuperGroup *const*)ptr, "ns1:returnDataRowsPerSuperGroup");
	case SOAP_TYPE_PointerTons1__returnDataRowsPerGroup:
		return soap_out_PointerTons1__returnDataRowsPerGroup(soap, tag, id, (ns1__returnDataRowsPerGroup *const*)ptr, "ns1:returnDataRowsPerGroup");
	case SOAP_TYPE_PointerTons1__DataItemRow:
		return soap_out_PointerTons1__DataItemRow(soap, tag, id, (ns1__DataItemRow *const*)ptr, "ns1:DataItemRow");
	case SOAP_TYPE_PointerTons1__BlockItemType:
		return soap_out_PointerTons1__BlockItemType(soap, tag, id, (ns1__BlockItemType *const*)ptr, "ns1:BlockItemType");
	case SOAP_TYPE_PointerTons1__ResponseInfoHeaderType:
		return soap_out_PointerTons1__ResponseInfoHeaderType(soap, tag, id, (ns1__ResponseInfoHeaderType *const*)ptr, "ns1:ResponseInfoHeaderType");
	case SOAP_TYPE_PointerTons1__DataItemType:
		return soap_out_PointerTons1__DataItemType(soap, tag, id, (ns1__DataItemType *const*)ptr, "ns1:DataItemType");
	case SOAP_TYPE_PointerTounsignedInt:
		return soap_out_PointerTounsignedInt(soap, tag, id, (unsigned int *const*)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_PointerTons1__RequestInfoHeaderType:
		return soap_out_PointerTons1__RequestInfoHeaderType(soap, tag, id, (ns1__RequestInfoHeaderType *const*)ptr, "ns1:RequestInfoHeaderType");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__StatReturnType:
		((ns1__StatReturnType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__StatItemType:
		((ns1__StatItemType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__StatRequestType:
		((ns1__StatRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ApplicationReturnType:
		((ns1__ApplicationReturnType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ApplicationKeepAliveRequestType:
		((ns1__ApplicationKeepAliveRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ApplicationRegisterRequestType:
		((ns1__ApplicationRegisterRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__LoginManagerRequestType:
		((ns1__LoginManagerRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RequestDeleteReportType:
		((ns1__RequestDeleteReportType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RequestSaveReportType:
		((ns1__RequestSaveReportType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SaveWorkspaseRequestType:
		((ns1__SaveWorkspaseRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SuperGroupListReturnType:
		((ns1__SuperGroupListReturnType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SuperGroupListDataItemType:
		((ns1__SuperGroupListDataItemType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__BriefDNISInfoRequestType:
		((ns1__BriefDNISInfoRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DNISListReturnType:
		((ns1__DNISListReturnType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DNISListDataItemType:
		((ns1__DNISListDataItemType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ReportListDataReturnType:
		((ns1__ReportListDataReturnType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ReportListDataItemType:
		((ns1__ReportListDataItemType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ReportListDataRequestType:
		((ns1__ReportListDataRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DefaultWorkspaceReturnType:
		((ns1__DefaultWorkspaceReturnType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DefaultWorkspaceItemType:
		((ns1__DefaultWorkspaceItemType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DefaultWorkspaceRequestType:
		((ns1__DefaultWorkspaceRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__BriefInfoRequestType:
		((ns1__BriefInfoRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AgentsListReturnType:
		((ns1__AgentsListReturnType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AgentsListDataItemType:
		((ns1__AgentsListDataItemType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GenListReturnType:
		((ns1__GenListReturnType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GenListDataItemType:
		((ns1__GenListDataItemType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GroupListReturnType:
		((ns1__GroupListReturnType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GroupListDataItemType:
		((ns1__GroupListDataItemType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GenRequestType:
		((ns1__GenRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__LoginReturnType:
		((ns1__LoginReturnType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__LoginRequestType:
		((ns1__LoginRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ReturnMatrixDataTypeBG:
		((ns1__ReturnMatrixDataTypeBG *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ReturnMatrixDataTypePerSuperGroup:
		((ns1__ReturnMatrixDataTypePerSuperGroup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__returnDataRowsPerSuperGroup:
		((ns1__returnDataRowsPerSuperGroup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ReturnMatrixDataTypePerGroup:
		((ns1__ReturnMatrixDataTypePerGroup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__returnDataRowsPerGroup:
		((ns1__returnDataRowsPerGroup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ReturnArrayDataType:
		((ns1__ReturnArrayDataType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__BlockItemType:
		((ns1__BlockItemType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DataItemRow:
		((ns1__DataItemRow *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DataItemType:
		((ns1__DataItemType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ResponseSaveReportType:
		((ns1__ResponseSaveReportType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ResponseInfoHeaderType:
		((ns1__ResponseInfoHeaderType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ChatResponseType:
		((ns1__ChatResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TFRequestType:
		((ns1__TFRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ACDRequestType:
		((ns1__ACDRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ACDMultiRequestType:
		((ns1__ACDMultiRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GenInfoRequestType:
		((ns1__GenInfoRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RequestInfoHeaderType:
		((ns1__RequestInfoHeaderType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__SuperGroupDailyBriefInfo:
		soap_serialize___ns1__SuperGroupDailyBriefInfo(soap, (const struct __ns1__SuperGroupDailyBriefInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__SuperGroupHourlyInfo:
		soap_serialize___ns1__SuperGroupHourlyInfo(soap, (const struct __ns1__SuperGroupHourlyInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GroupDailyDetailedInfo:
		soap_serialize___ns1__GroupDailyDetailedInfo(soap, (const struct __ns1__GroupDailyDetailedInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GroupDailyBriefInfo:
		soap_serialize___ns1__GroupDailyBriefInfo(soap, (const struct __ns1__GroupDailyBriefInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GroupHourlyInfo:
		soap_serialize___ns1__GroupHourlyInfo(soap, (const struct __ns1__GroupHourlyInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__AgentNeedHelp:
		soap_serialize___ns1__AgentNeedHelp(soap, (const struct __ns1__AgentNeedHelp *)ptr);
		break;
	case SOAP_TYPE___ns1__TraceInternalStat:
		soap_serialize___ns1__TraceInternalStat(soap, (const struct __ns1__TraceInternalStat *)ptr);
		break;
	case SOAP_TYPE___ns1__ApplicationKeepAlive:
		soap_serialize___ns1__ApplicationKeepAlive(soap, (const struct __ns1__ApplicationKeepAlive *)ptr);
		break;
	case SOAP_TYPE___ns1__ApplicationRegister:
		soap_serialize___ns1__ApplicationRegister(soap, (const struct __ns1__ApplicationRegister *)ptr);
		break;
	case SOAP_TYPE___ns1__LoginManagerAvailableGroupsForAgent:
		soap_serialize___ns1__LoginManagerAvailableGroupsForAgent(soap, (const struct __ns1__LoginManagerAvailableGroupsForAgent *)ptr);
		break;
	case SOAP_TYPE___ns1__LoginManagerAvailableAgentsForGroup:
		soap_serialize___ns1__LoginManagerAvailableAgentsForGroup(soap, (const struct __ns1__LoginManagerAvailableAgentsForGroup *)ptr);
		break;
	case SOAP_TYPE___ns1__LoginManagerMultiAgentsToOneGroup:
		soap_serialize___ns1__LoginManagerMultiAgentsToOneGroup(soap, (const struct __ns1__LoginManagerMultiAgentsToOneGroup *)ptr);
		break;
	case SOAP_TYPE___ns1__LoginManagerOneAgentToMultiGroups:
		soap_serialize___ns1__LoginManagerOneAgentToMultiGroups(soap, (const struct __ns1__LoginManagerOneAgentToMultiGroups *)ptr);
		break;
	case SOAP_TYPE___ns1__LoginManagerGroupsPerAgent:
		soap_serialize___ns1__LoginManagerGroupsPerAgent(soap, (const struct __ns1__LoginManagerGroupsPerAgent *)ptr);
		break;
	case SOAP_TYPE___ns1__LoginManagerAgentsPerGroup:
		soap_serialize___ns1__LoginManagerAgentsPerGroup(soap, (const struct __ns1__LoginManagerAgentsPerGroup *)ptr);
		break;
	case SOAP_TYPE___ns1__DeleteReport:
		soap_serialize___ns1__DeleteReport(soap, (const struct __ns1__DeleteReport *)ptr);
		break;
	case SOAP_TYPE___ns1__SaveReport:
		soap_serialize___ns1__SaveReport(soap, (const struct __ns1__SaveReport *)ptr);
		break;
	case SOAP_TYPE___ns1__SaveWorkspase:
		soap_serialize___ns1__SaveWorkspase(soap, (const struct __ns1__SaveWorkspase *)ptr);
		break;
	case SOAP_TYPE___ns1__CommandAgentTelephonyFeatures:
		soap_serialize___ns1__CommandAgentTelephonyFeatures(soap, (const struct __ns1__CommandAgentTelephonyFeatures *)ptr);
		break;
	case SOAP_TYPE___ns1__CommandAgentStartRecord:
		soap_serialize___ns1__CommandAgentStartRecord(soap, (const struct __ns1__CommandAgentStartRecord *)ptr);
		break;
	case SOAP_TYPE___ns1__CommandAgentStartChat:
		soap_serialize___ns1__CommandAgentStartChat(soap, (const struct __ns1__CommandAgentStartChat *)ptr);
		break;
	case SOAP_TYPE___ns1__CommandAgentReleaseResume:
		soap_serialize___ns1__CommandAgentReleaseResume(soap, (const struct __ns1__CommandAgentReleaseResume *)ptr);
		break;
	case SOAP_TYPE___ns1__CommandAgentLoginLogout:
		soap_serialize___ns1__CommandAgentLoginLogout(soap, (const struct __ns1__CommandAgentLoginLogout *)ptr);
		break;
	case SOAP_TYPE___ns1__BriefEmailDNIS:
		soap_serialize___ns1__BriefEmailDNIS(soap, (const struct __ns1__BriefEmailDNIS *)ptr);
		break;
	case SOAP_TYPE___ns1__BriefVoiceDNIS:
		soap_serialize___ns1__BriefVoiceDNIS(soap, (const struct __ns1__BriefVoiceDNIS *)ptr);
		break;
	case SOAP_TYPE___ns1__EmailDNISList:
		soap_serialize___ns1__EmailDNISList(soap, (const struct __ns1__EmailDNISList *)ptr);
		break;
	case SOAP_TYPE___ns1__VoiceDNISList:
		soap_serialize___ns1__VoiceDNISList(soap, (const struct __ns1__VoiceDNISList *)ptr);
		break;
	case SOAP_TYPE___ns1__ReportListData:
		soap_serialize___ns1__ReportListData(soap, (const struct __ns1__ReportListData *)ptr);
		break;
	case SOAP_TYPE___ns1__DefaultWorkspace:
		soap_serialize___ns1__DefaultWorkspace(soap, (const struct __ns1__DefaultWorkspace *)ptr);
		break;
	case SOAP_TYPE___ns1__BriefAgents:
		soap_serialize___ns1__BriefAgents(soap, (const struct __ns1__BriefAgents *)ptr);
		break;
	case SOAP_TYPE___ns1__AgentsList:
		soap_serialize___ns1__AgentsList(soap, (const struct __ns1__AgentsList *)ptr);
		break;
	case SOAP_TYPE___ns1__AgentsPerGroupInfo:
		soap_serialize___ns1__AgentsPerGroupInfo(soap, (const struct __ns1__AgentsPerGroupInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__MailAccList:
		soap_serialize___ns1__MailAccList(soap, (const struct __ns1__MailAccList *)ptr);
		break;
	case SOAP_TYPE___ns1__IvrAppList:
		soap_serialize___ns1__IvrAppList(soap, (const struct __ns1__IvrAppList *)ptr);
		break;
	case SOAP_TYPE___ns1__IvrPortGroupList:
		soap_serialize___ns1__IvrPortGroupList(soap, (const struct __ns1__IvrPortGroupList *)ptr);
		break;
	case SOAP_TYPE___ns1__GroupList:
		soap_serialize___ns1__GroupList(soap, (const struct __ns1__GroupList *)ptr);
		break;
	case SOAP_TYPE___ns1__UserLogout:
		soap_serialize___ns1__UserLogout(soap, (const struct __ns1__UserLogout *)ptr);
		break;
	case SOAP_TYPE___ns1__UserLogin:
		soap_serialize___ns1__UserLogin(soap, (const struct __ns1__UserLogin *)ptr);
		break;
	case SOAP_TYPE___ns1__SuperGroupList:
		soap_serialize___ns1__SuperGroupList(soap, (const struct __ns1__SuperGroupList *)ptr);
		break;
	case SOAP_TYPE___ns1__SuperGroupInfo:
		soap_serialize___ns1__SuperGroupInfo(soap, (const struct __ns1__SuperGroupInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__MailboxInfo:
		soap_serialize___ns1__MailboxInfo(soap, (const struct __ns1__MailboxInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__IvrGrpInfo:
		soap_serialize___ns1__IvrGrpInfo(soap, (const struct __ns1__IvrGrpInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__IvrPortInfo:
		soap_serialize___ns1__IvrPortInfo(soap, (const struct __ns1__IvrPortInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__IvrApplInfo:
		soap_serialize___ns1__IvrApplInfo(soap, (const struct __ns1__IvrApplInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GroupPeriodInfo:
		soap_serialize___ns1__GroupPeriodInfo(soap, (const struct __ns1__GroupPeriodInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GroupGeneralInfo:
		soap_serialize___ns1__GroupGeneralInfo(soap, (const struct __ns1__GroupGeneralInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GroupShiftInfo:
		soap_serialize___ns1__GroupShiftInfo(soap, (const struct __ns1__GroupShiftInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GroupIntOvfInfo:
		soap_serialize___ns1__GroupIntOvfInfo(soap, (const struct __ns1__GroupIntOvfInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GroupAbndInfo:
		soap_serialize___ns1__GroupAbndInfo(soap, (const struct __ns1__GroupAbndInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GroupAgentsInfo:
		soap_serialize___ns1__GroupAgentsInfo(soap, (const struct __ns1__GroupAgentsInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GroupQueInfo:
		soap_serialize___ns1__GroupQueInfo(soap, (const struct __ns1__GroupQueInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GroupDetailFullInfo:
		soap_serialize___ns1__GroupDetailFullInfo(soap, (const struct __ns1__GroupDetailFullInfo *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__StatRequestType:
		soap_serialize_PointerTons1__StatRequestType(soap, (ns1__StatRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ApplicationKeepAliveRequestType:
		soap_serialize_PointerTons1__ApplicationKeepAliveRequestType(soap, (ns1__ApplicationKeepAliveRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ApplicationRegisterRequestType:
		soap_serialize_PointerTons1__ApplicationRegisterRequestType(soap, (ns1__ApplicationRegisterRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__LoginManagerRequestType:
		soap_serialize_PointerTons1__LoginManagerRequestType(soap, (ns1__LoginManagerRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RequestDeleteReportType:
		soap_serialize_PointerTons1__RequestDeleteReportType(soap, (ns1__RequestDeleteReportType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RequestSaveReportType:
		soap_serialize_PointerTons1__RequestSaveReportType(soap, (ns1__RequestSaveReportType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SaveWorkspaseRequestType:
		soap_serialize_PointerTons1__SaveWorkspaseRequestType(soap, (ns1__SaveWorkspaseRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TFRequestType:
		soap_serialize_PointerTons1__TFRequestType(soap, (ns1__TFRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ACDRequestType:
		soap_serialize_PointerTons1__ACDRequestType(soap, (ns1__ACDRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ACDMultiRequestType:
		soap_serialize_PointerTons1__ACDMultiRequestType(soap, (ns1__ACDMultiRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ReportListDataRequestType:
		soap_serialize_PointerTons1__ReportListDataRequestType(soap, (ns1__ReportListDataRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DefaultWorkspaceRequestType:
		soap_serialize_PointerTons1__DefaultWorkspaceRequestType(soap, (ns1__DefaultWorkspaceRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BriefInfoRequestType:
		soap_serialize_PointerTons1__BriefInfoRequestType(soap, (ns1__BriefInfoRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__LoginRequestType:
		soap_serialize_PointerTons1__LoginRequestType(soap, (ns1__LoginRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GenRequestType:
		soap_serialize_PointerTons1__GenRequestType(soap, (ns1__GenRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GenInfoRequestType:
		soap_serialize_PointerTons1__GenInfoRequestType(soap, (ns1__GenInfoRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__StatItemType:
		soap_serialize_PointerTons1__StatItemType(soap, (ns1__StatItemType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SuperGroupListDataItemType:
		soap_serialize_PointerTons1__SuperGroupListDataItemType(soap, (ns1__SuperGroupListDataItemType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DNISListDataItemType:
		soap_serialize_PointerTons1__DNISListDataItemType(soap, (ns1__DNISListDataItemType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ReportListDataItemType:
		soap_serialize_PointerTons1__ReportListDataItemType(soap, (ns1__ReportListDataItemType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DefaultWorkspaceItemType:
		soap_serialize_PointerTons1__DefaultWorkspaceItemType(soap, (ns1__DefaultWorkspaceItemType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AgentsListDataItemType:
		soap_serialize_PointerTons1__AgentsListDataItemType(soap, (ns1__AgentsListDataItemType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GenListDataItemType:
		soap_serialize_PointerTons1__GenListDataItemType(soap, (ns1__GenListDataItemType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GroupListDataItemType:
		soap_serialize_PointerTons1__GroupListDataItemType(soap, (ns1__GroupListDataItemType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__returnDataRowsPerSuperGroup:
		soap_serialize_PointerTons1__returnDataRowsPerSuperGroup(soap, (ns1__returnDataRowsPerSuperGroup *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__returnDataRowsPerGroup:
		soap_serialize_PointerTons1__returnDataRowsPerGroup(soap, (ns1__returnDataRowsPerGroup *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DataItemRow:
		soap_serialize_PointerTons1__DataItemRow(soap, (ns1__DataItemRow *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BlockItemType:
		soap_serialize_PointerTons1__BlockItemType(soap, (ns1__BlockItemType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ResponseInfoHeaderType:
		soap_serialize_PointerTons1__ResponseInfoHeaderType(soap, (ns1__ResponseInfoHeaderType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DataItemType:
		soap_serialize_PointerTons1__DataItemType(soap, (ns1__DataItemType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedInt:
		soap_serialize_PointerTounsignedInt(soap, (unsigned int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RequestInfoHeaderType:
		soap_serialize_PointerTons1__RequestInfoHeaderType(soap, (ns1__RequestInfoHeaderType *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RequestInfoHeaderType:
		return (void*)soap_instantiate_ns1__RequestInfoHeaderType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GenInfoRequestType:
		return (void*)soap_instantiate_ns1__GenInfoRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ACDMultiRequestType:
		return (void*)soap_instantiate_ns1__ACDMultiRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ACDRequestType:
		return (void*)soap_instantiate_ns1__ACDRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TFRequestType:
		return (void*)soap_instantiate_ns1__TFRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ChatResponseType:
		return (void*)soap_instantiate_ns1__ChatResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ResponseInfoHeaderType:
		return (void*)soap_instantiate_ns1__ResponseInfoHeaderType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ResponseSaveReportType:
		return (void*)soap_instantiate_ns1__ResponseSaveReportType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DataItemType:
		return (void*)soap_instantiate_ns1__DataItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DataItemRow:
		return (void*)soap_instantiate_ns1__DataItemRow(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BlockItemType:
		return (void*)soap_instantiate_ns1__BlockItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ReturnArrayDataType:
		return (void*)soap_instantiate_ns1__ReturnArrayDataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__returnDataRowsPerGroup:
		return (void*)soap_instantiate_ns1__returnDataRowsPerGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ReturnMatrixDataTypePerGroup:
		return (void*)soap_instantiate_ns1__ReturnMatrixDataTypePerGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__returnDataRowsPerSuperGroup:
		return (void*)soap_instantiate_ns1__returnDataRowsPerSuperGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ReturnMatrixDataTypePerSuperGroup:
		return (void*)soap_instantiate_ns1__ReturnMatrixDataTypePerSuperGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ReturnMatrixDataTypeBG:
		return (void*)soap_instantiate_ns1__ReturnMatrixDataTypeBG(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__LoginRequestType:
		return (void*)soap_instantiate_ns1__LoginRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__LoginReturnType:
		return (void*)soap_instantiate_ns1__LoginReturnType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GenRequestType:
		return (void*)soap_instantiate_ns1__GenRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GroupListDataItemType:
		return (void*)soap_instantiate_ns1__GroupListDataItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GroupListReturnType:
		return (void*)soap_instantiate_ns1__GroupListReturnType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GenListDataItemType:
		return (void*)soap_instantiate_ns1__GenListDataItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GenListReturnType:
		return (void*)soap_instantiate_ns1__GenListReturnType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AgentsListDataItemType:
		return (void*)soap_instantiate_ns1__AgentsListDataItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AgentsListReturnType:
		return (void*)soap_instantiate_ns1__AgentsListReturnType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BriefInfoRequestType:
		return (void*)soap_instantiate_ns1__BriefInfoRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DefaultWorkspaceRequestType:
		return (void*)soap_instantiate_ns1__DefaultWorkspaceRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DefaultWorkspaceItemType:
		return (void*)soap_instantiate_ns1__DefaultWorkspaceItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DefaultWorkspaceReturnType:
		return (void*)soap_instantiate_ns1__DefaultWorkspaceReturnType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ReportListDataRequestType:
		return (void*)soap_instantiate_ns1__ReportListDataRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ReportListDataItemType:
		return (void*)soap_instantiate_ns1__ReportListDataItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ReportListDataReturnType:
		return (void*)soap_instantiate_ns1__ReportListDataReturnType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DNISListDataItemType:
		return (void*)soap_instantiate_ns1__DNISListDataItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DNISListReturnType:
		return (void*)soap_instantiate_ns1__DNISListReturnType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BriefDNISInfoRequestType:
		return (void*)soap_instantiate_ns1__BriefDNISInfoRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SuperGroupListDataItemType:
		return (void*)soap_instantiate_ns1__SuperGroupListDataItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SuperGroupListReturnType:
		return (void*)soap_instantiate_ns1__SuperGroupListReturnType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SaveWorkspaseRequestType:
		return (void*)soap_instantiate_ns1__SaveWorkspaseRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RequestSaveReportType:
		return (void*)soap_instantiate_ns1__RequestSaveReportType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RequestDeleteReportType:
		return (void*)soap_instantiate_ns1__RequestDeleteReportType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__LoginManagerRequestType:
		return (void*)soap_instantiate_ns1__LoginManagerRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ApplicationRegisterRequestType:
		return (void*)soap_instantiate_ns1__ApplicationRegisterRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ApplicationKeepAliveRequestType:
		return (void*)soap_instantiate_ns1__ApplicationKeepAliveRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ApplicationReturnType:
		return (void*)soap_instantiate_ns1__ApplicationReturnType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__StatRequestType:
		return (void*)soap_instantiate_ns1__StatRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__StatItemType:
		return (void*)soap_instantiate_ns1__StatItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__StatReturnType:
		return (void*)soap_instantiate_ns1__StatReturnType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GroupDetailFullInfo:
		return (void*)soap_instantiate___ns1__GroupDetailFullInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GroupQueInfo:
		return (void*)soap_instantiate___ns1__GroupQueInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GroupAgentsInfo:
		return (void*)soap_instantiate___ns1__GroupAgentsInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GroupAbndInfo:
		return (void*)soap_instantiate___ns1__GroupAbndInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GroupIntOvfInfo:
		return (void*)soap_instantiate___ns1__GroupIntOvfInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GroupShiftInfo:
		return (void*)soap_instantiate___ns1__GroupShiftInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GroupGeneralInfo:
		return (void*)soap_instantiate___ns1__GroupGeneralInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GroupPeriodInfo:
		return (void*)soap_instantiate___ns1__GroupPeriodInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__IvrApplInfo:
		return (void*)soap_instantiate___ns1__IvrApplInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__IvrPortInfo:
		return (void*)soap_instantiate___ns1__IvrPortInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__IvrGrpInfo:
		return (void*)soap_instantiate___ns1__IvrGrpInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__MailboxInfo:
		return (void*)soap_instantiate___ns1__MailboxInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SuperGroupInfo:
		return (void*)soap_instantiate___ns1__SuperGroupInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SuperGroupList:
		return (void*)soap_instantiate___ns1__SuperGroupList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UserLogin:
		return (void*)soap_instantiate___ns1__UserLogin(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UserLogout:
		return (void*)soap_instantiate___ns1__UserLogout(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GroupList:
		return (void*)soap_instantiate___ns1__GroupList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__IvrPortGroupList:
		return (void*)soap_instantiate___ns1__IvrPortGroupList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__IvrAppList:
		return (void*)soap_instantiate___ns1__IvrAppList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__MailAccList:
		return (void*)soap_instantiate___ns1__MailAccList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__AgentsPerGroupInfo:
		return (void*)soap_instantiate___ns1__AgentsPerGroupInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__AgentsList:
		return (void*)soap_instantiate___ns1__AgentsList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__BriefAgents:
		return (void*)soap_instantiate___ns1__BriefAgents(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DefaultWorkspace:
		return (void*)soap_instantiate___ns1__DefaultWorkspace(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ReportListData:
		return (void*)soap_instantiate___ns1__ReportListData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__VoiceDNISList:
		return (void*)soap_instantiate___ns1__VoiceDNISList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__EmailDNISList:
		return (void*)soap_instantiate___ns1__EmailDNISList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__BriefVoiceDNIS:
		return (void*)soap_instantiate___ns1__BriefVoiceDNIS(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__BriefEmailDNIS:
		return (void*)soap_instantiate___ns1__BriefEmailDNIS(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CommandAgentLoginLogout:
		return (void*)soap_instantiate___ns1__CommandAgentLoginLogout(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CommandAgentReleaseResume:
		return (void*)soap_instantiate___ns1__CommandAgentReleaseResume(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CommandAgentStartChat:
		return (void*)soap_instantiate___ns1__CommandAgentStartChat(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CommandAgentStartRecord:
		return (void*)soap_instantiate___ns1__CommandAgentStartRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CommandAgentTelephonyFeatures:
		return (void*)soap_instantiate___ns1__CommandAgentTelephonyFeatures(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SaveWorkspase:
		return (void*)soap_instantiate___ns1__SaveWorkspase(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SaveReport:
		return (void*)soap_instantiate___ns1__SaveReport(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DeleteReport:
		return (void*)soap_instantiate___ns1__DeleteReport(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__LoginManagerAgentsPerGroup:
		return (void*)soap_instantiate___ns1__LoginManagerAgentsPerGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__LoginManagerGroupsPerAgent:
		return (void*)soap_instantiate___ns1__LoginManagerGroupsPerAgent(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__LoginManagerOneAgentToMultiGroups:
		return (void*)soap_instantiate___ns1__LoginManagerOneAgentToMultiGroups(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__LoginManagerMultiAgentsToOneGroup:
		return (void*)soap_instantiate___ns1__LoginManagerMultiAgentsToOneGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__LoginManagerAvailableAgentsForGroup:
		return (void*)soap_instantiate___ns1__LoginManagerAvailableAgentsForGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__LoginManagerAvailableGroupsForAgent:
		return (void*)soap_instantiate___ns1__LoginManagerAvailableGroupsForAgent(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ApplicationRegister:
		return (void*)soap_instantiate___ns1__ApplicationRegister(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ApplicationKeepAlive:
		return (void*)soap_instantiate___ns1__ApplicationKeepAlive(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__TraceInternalStat:
		return (void*)soap_instantiate___ns1__TraceInternalStat(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__AgentNeedHelp:
		return (void*)soap_instantiate___ns1__AgentNeedHelp(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GroupHourlyInfo:
		return (void*)soap_instantiate___ns1__GroupHourlyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GroupDailyBriefInfo:
		return (void*)soap_instantiate___ns1__GroupDailyBriefInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GroupDailyDetailedInfo:
		return (void*)soap_instantiate___ns1__GroupDailyDetailedInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SuperGroupHourlyInfo:
		return (void*)soap_instantiate___ns1__SuperGroupHourlyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SuperGroupDailyBriefInfo:
		return (void*)soap_instantiate___ns1__SuperGroupDailyBriefInfo(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__StatItemType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__StatItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SuperGroupListDataItemType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__SuperGroupListDataItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DNISListDataItemType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__DNISListDataItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ReportListDataItemType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ReportListDataItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DefaultWorkspaceItemType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__DefaultWorkspaceItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__AgentsListDataItemType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__AgentsListDataItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__GenListDataItemType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__GenListDataItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__GroupListDataItemType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__GroupListDataItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__returnDataRowsPerSuperGroup:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__returnDataRowsPerSuperGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__returnDataRowsPerGroup:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__returnDataRowsPerGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DataItemRow:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__DataItemRow(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__BlockItemType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__BlockItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DataItemType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__DataItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfunsignedInt:
		return (void*)soap_instantiate_std__vectorTemplateOfunsignedInt(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__RequestInfoHeaderType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__RequestInfoHeaderType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__RequestInfoHeaderType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__GenInfoRequestType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__GenInfoRequestType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__GenInfoRequestType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ACDMultiRequestType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ACDMultiRequestType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ACDMultiRequestType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ACDRequestType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ACDRequestType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ACDRequestType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__TFRequestType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__TFRequestType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__TFRequestType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ChatResponseType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ChatResponseType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ChatResponseType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ResponseInfoHeaderType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ResponseInfoHeaderType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ResponseInfoHeaderType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ResponseSaveReportType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ResponseSaveReportType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ResponseSaveReportType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__DataItemType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__DataItemType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__DataItemType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__DataItemRow:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__DataItemRow*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__DataItemRow*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__BlockItemType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__BlockItemType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__BlockItemType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ReturnArrayDataType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ReturnArrayDataType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ReturnArrayDataType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__returnDataRowsPerGroup:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__returnDataRowsPerGroup*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__returnDataRowsPerGroup*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ReturnMatrixDataTypePerGroup:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ReturnMatrixDataTypePerGroup*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ReturnMatrixDataTypePerGroup*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__returnDataRowsPerSuperGroup:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__returnDataRowsPerSuperGroup*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__returnDataRowsPerSuperGroup*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ReturnMatrixDataTypePerSuperGroup:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ReturnMatrixDataTypePerSuperGroup*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ReturnMatrixDataTypePerSuperGroup*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ReturnMatrixDataTypeBG:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ReturnMatrixDataTypeBG*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ReturnMatrixDataTypeBG*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__LoginRequestType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__LoginRequestType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__LoginRequestType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__LoginReturnType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__LoginReturnType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__LoginReturnType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__GenRequestType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__GenRequestType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__GenRequestType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__GroupListDataItemType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__GroupListDataItemType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__GroupListDataItemType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__GroupListReturnType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__GroupListReturnType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__GroupListReturnType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__GenListDataItemType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__GenListDataItemType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__GenListDataItemType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__GenListReturnType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__GenListReturnType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__GenListReturnType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__AgentsListDataItemType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__AgentsListDataItemType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__AgentsListDataItemType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__AgentsListReturnType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__AgentsListReturnType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__AgentsListReturnType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__BriefInfoRequestType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__BriefInfoRequestType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__BriefInfoRequestType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__DefaultWorkspaceRequestType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__DefaultWorkspaceRequestType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__DefaultWorkspaceRequestType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__DefaultWorkspaceItemType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__DefaultWorkspaceItemType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__DefaultWorkspaceItemType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__DefaultWorkspaceReturnType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__DefaultWorkspaceReturnType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__DefaultWorkspaceReturnType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ReportListDataRequestType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ReportListDataRequestType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ReportListDataRequestType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ReportListDataItemType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ReportListDataItemType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ReportListDataItemType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ReportListDataReturnType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ReportListDataReturnType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ReportListDataReturnType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__DNISListDataItemType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__DNISListDataItemType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__DNISListDataItemType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__DNISListReturnType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__DNISListReturnType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__DNISListReturnType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__BriefDNISInfoRequestType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__BriefDNISInfoRequestType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__BriefDNISInfoRequestType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__SuperGroupListDataItemType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__SuperGroupListDataItemType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__SuperGroupListDataItemType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__SuperGroupListReturnType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__SuperGroupListReturnType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__SuperGroupListReturnType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__SaveWorkspaseRequestType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__SaveWorkspaseRequestType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__SaveWorkspaseRequestType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__RequestSaveReportType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__RequestSaveReportType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__RequestSaveReportType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__RequestDeleteReportType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__RequestDeleteReportType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__RequestDeleteReportType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__LoginManagerRequestType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__LoginManagerRequestType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__LoginManagerRequestType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ApplicationRegisterRequestType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ApplicationRegisterRequestType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ApplicationRegisterRequestType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ApplicationKeepAliveRequestType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ApplicationKeepAliveRequestType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ApplicationKeepAliveRequestType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ApplicationReturnType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ApplicationReturnType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ApplicationReturnType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__StatRequestType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__StatRequestType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__StatRequestType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__StatItemType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__StatItemType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__StatItemType*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__StatReturnType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__StatReturnType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__StatReturnType*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GroupDetailFullInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GroupDetailFullInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GroupDetailFullInfo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GroupQueInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GroupQueInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GroupQueInfo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GroupAgentsInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GroupAgentsInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GroupAgentsInfo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GroupAbndInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GroupAbndInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GroupAbndInfo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GroupIntOvfInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GroupIntOvfInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GroupIntOvfInfo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GroupShiftInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GroupShiftInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GroupShiftInfo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GroupGeneralInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GroupGeneralInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GroupGeneralInfo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GroupPeriodInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GroupPeriodInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GroupPeriodInfo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__IvrApplInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__IvrApplInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__IvrApplInfo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__IvrPortInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__IvrPortInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__IvrPortInfo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__IvrGrpInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__IvrGrpInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__IvrGrpInfo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__MailboxInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__MailboxInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__MailboxInfo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SuperGroupInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SuperGroupInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SuperGroupInfo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SuperGroupList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SuperGroupList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SuperGroupList*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__UserLogin:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__UserLogin*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__UserLogin*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__UserLogout:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__UserLogout*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__UserLogout*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GroupList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GroupList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GroupList*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__IvrPortGroupList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__IvrPortGroupList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__IvrPortGroupList*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__IvrAppList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__IvrAppList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__IvrAppList*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__MailAccList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__MailAccList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__MailAccList*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__AgentsPerGroupInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__AgentsPerGroupInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__AgentsPerGroupInfo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__AgentsList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__AgentsList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__AgentsList*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__BriefAgents:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__BriefAgents*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__BriefAgents*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__DefaultWorkspace:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__DefaultWorkspace*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__DefaultWorkspace*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__ReportListData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ReportListData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ReportListData*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__VoiceDNISList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__VoiceDNISList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__VoiceDNISList*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__EmailDNISList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__EmailDNISList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__EmailDNISList*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__BriefVoiceDNIS:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__BriefVoiceDNIS*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__BriefVoiceDNIS*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__BriefEmailDNIS:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__BriefEmailDNIS*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__BriefEmailDNIS*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__CommandAgentLoginLogout:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__CommandAgentLoginLogout*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__CommandAgentLoginLogout*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__CommandAgentReleaseResume:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__CommandAgentReleaseResume*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__CommandAgentReleaseResume*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__CommandAgentStartChat:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__CommandAgentStartChat*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__CommandAgentStartChat*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__CommandAgentStartRecord:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__CommandAgentStartRecord*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__CommandAgentStartRecord*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__CommandAgentTelephonyFeatures:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__CommandAgentTelephonyFeatures*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__CommandAgentTelephonyFeatures*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SaveWorkspase:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SaveWorkspase*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SaveWorkspase*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SaveReport:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SaveReport*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SaveReport*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__DeleteReport:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__DeleteReport*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__DeleteReport*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__LoginManagerAgentsPerGroup:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__LoginManagerAgentsPerGroup*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__LoginManagerAgentsPerGroup*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__LoginManagerGroupsPerAgent:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__LoginManagerGroupsPerAgent*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__LoginManagerGroupsPerAgent*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__LoginManagerOneAgentToMultiGroups:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__LoginManagerOneAgentToMultiGroups*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__LoginManagerOneAgentToMultiGroups*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__LoginManagerMultiAgentsToOneGroup:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__LoginManagerMultiAgentsToOneGroup*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__LoginManagerMultiAgentsToOneGroup*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__LoginManagerAvailableAgentsForGroup:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__LoginManagerAvailableAgentsForGroup*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__LoginManagerAvailableAgentsForGroup*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__LoginManagerAvailableGroupsForAgent:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__LoginManagerAvailableGroupsForAgent*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__LoginManagerAvailableGroupsForAgent*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__ApplicationRegister:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ApplicationRegister*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ApplicationRegister*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__ApplicationKeepAlive:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ApplicationKeepAlive*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ApplicationKeepAlive*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__TraceInternalStat:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__TraceInternalStat*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__TraceInternalStat*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__AgentNeedHelp:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__AgentNeedHelp*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__AgentNeedHelp*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GroupHourlyInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GroupHourlyInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GroupHourlyInfo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GroupDailyBriefInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GroupDailyBriefInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GroupDailyBriefInfo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GroupDailyDetailedInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GroupDailyDetailedInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GroupDailyDetailedInfo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SuperGroupHourlyInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SuperGroupHourlyInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SuperGroupHourlyInfo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SuperGroupDailyBriefInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SuperGroupDailyBriefInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SuperGroupDailyBriefInfo*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		break;
#endif
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__StatItemType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__StatItemType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__StatItemType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SuperGroupListDataItemType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__SuperGroupListDataItemType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__SuperGroupListDataItemType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DNISListDataItemType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__DNISListDataItemType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__DNISListDataItemType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ReportListDataItemType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__ReportListDataItemType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__ReportListDataItemType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DefaultWorkspaceItemType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__DefaultWorkspaceItemType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__DefaultWorkspaceItemType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__AgentsListDataItemType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__AgentsListDataItemType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__AgentsListDataItemType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__GenListDataItemType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__GenListDataItemType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__GenListDataItemType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__GroupListDataItemType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__GroupListDataItemType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__GroupListDataItemType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__returnDataRowsPerSuperGroup:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__returnDataRowsPerSuperGroup *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__returnDataRowsPerSuperGroup *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__returnDataRowsPerGroup:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__returnDataRowsPerGroup *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__returnDataRowsPerGroup *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DataItemRow:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__DataItemRow *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__DataItemRow *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__BlockItemType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__BlockItemType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__BlockItemType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DataItemType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__DataItemType *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__DataItemType *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfunsignedInt:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<unsigned int> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<unsigned int> *>(p->ptr));
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{	(void)t; (void)b; /* appease -Wall -Werror */
	return 0;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__StatItemType:
		if (t == SOAP_TYPE_ns1__StatItemType || soap_fbase(t, SOAP_TYPE_ns1__StatItemType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__StatItemType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__StatItemType *> *)p)[index] = *(ns1__StatItemType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SuperGroupListDataItemType:
		if (t == SOAP_TYPE_ns1__SuperGroupListDataItemType || soap_fbase(t, SOAP_TYPE_ns1__SuperGroupListDataItemType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__SuperGroupListDataItemType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__SuperGroupListDataItemType *> *)p)[index] = *(ns1__SuperGroupListDataItemType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DNISListDataItemType:
		if (t == SOAP_TYPE_ns1__DNISListDataItemType || soap_fbase(t, SOAP_TYPE_ns1__DNISListDataItemType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__DNISListDataItemType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__DNISListDataItemType *> *)p)[index] = *(ns1__DNISListDataItemType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ReportListDataItemType:
		if (t == SOAP_TYPE_ns1__ReportListDataItemType || soap_fbase(t, SOAP_TYPE_ns1__ReportListDataItemType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__ReportListDataItemType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__ReportListDataItemType *> *)p)[index] = *(ns1__ReportListDataItemType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DefaultWorkspaceItemType:
		if (t == SOAP_TYPE_ns1__DefaultWorkspaceItemType || soap_fbase(t, SOAP_TYPE_ns1__DefaultWorkspaceItemType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__DefaultWorkspaceItemType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__DefaultWorkspaceItemType *> *)p)[index] = *(ns1__DefaultWorkspaceItemType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__AgentsListDataItemType:
		if (t == SOAP_TYPE_ns1__AgentsListDataItemType || soap_fbase(t, SOAP_TYPE_ns1__AgentsListDataItemType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__AgentsListDataItemType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__AgentsListDataItemType *> *)p)[index] = *(ns1__AgentsListDataItemType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__GenListDataItemType:
		if (t == SOAP_TYPE_ns1__GenListDataItemType || soap_fbase(t, SOAP_TYPE_ns1__GenListDataItemType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__GenListDataItemType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__GenListDataItemType *> *)p)[index] = *(ns1__GenListDataItemType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__GroupListDataItemType:
		if (t == SOAP_TYPE_ns1__GroupListDataItemType || soap_fbase(t, SOAP_TYPE_ns1__GroupListDataItemType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__GroupListDataItemType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__GroupListDataItemType *> *)p)[index] = *(ns1__GroupListDataItemType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__returnDataRowsPerSuperGroup:
		if (t == SOAP_TYPE_ns1__returnDataRowsPerSuperGroup || soap_fbase(t, SOAP_TYPE_ns1__returnDataRowsPerSuperGroup))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__returnDataRowsPerSuperGroup *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__returnDataRowsPerSuperGroup *> *)p)[index] = *(ns1__returnDataRowsPerSuperGroup **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__returnDataRowsPerGroup:
		if (t == SOAP_TYPE_ns1__returnDataRowsPerGroup || soap_fbase(t, SOAP_TYPE_ns1__returnDataRowsPerGroup))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__returnDataRowsPerGroup *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__returnDataRowsPerGroup *> *)p)[index] = *(ns1__returnDataRowsPerGroup **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DataItemRow:
		if (t == SOAP_TYPE_ns1__DataItemRow || soap_fbase(t, SOAP_TYPE_ns1__DataItemRow))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__DataItemRow *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__DataItemRow *> *)p)[index] = *(ns1__DataItemRow **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__BlockItemType:
		if (t == SOAP_TYPE_ns1__BlockItemType || soap_fbase(t, SOAP_TYPE_ns1__BlockItemType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__BlockItemType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__BlockItemType *> *)p)[index] = *(ns1__BlockItemType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DataItemType:
		if (t == SOAP_TYPE_ns1__DataItemType || soap_fbase(t, SOAP_TYPE_ns1__DataItemType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__DataItemType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__DataItemType *> *)p)[index] = *(ns1__DataItemType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfunsignedInt:
		if (t == SOAP_TYPE_unsignedInt)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<unsigned int>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<unsigned int> *)p)[index] = *(unsigned int *)q;
		}
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__RequestInfoHeaderType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RequestInfoHeaderType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RequestInfoHeaderType*)p = *(ns1__RequestInfoHeaderType*)q;
		break;
	case SOAP_TYPE_ns1__GenInfoRequestType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GenInfoRequestType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GenInfoRequestType*)p = *(ns1__GenInfoRequestType*)q;
		break;
	case SOAP_TYPE_ns1__ACDMultiRequestType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ACDMultiRequestType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ACDMultiRequestType*)p = *(ns1__ACDMultiRequestType*)q;
		break;
	case SOAP_TYPE_ns1__ACDRequestType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ACDRequestType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ACDRequestType*)p = *(ns1__ACDRequestType*)q;
		break;
	case SOAP_TYPE_ns1__TFRequestType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__TFRequestType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__TFRequestType*)p = *(ns1__TFRequestType*)q;
		break;
	case SOAP_TYPE_ns1__ChatResponseType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ChatResponseType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ChatResponseType*)p = *(ns1__ChatResponseType*)q;
		break;
	case SOAP_TYPE_ns1__ResponseInfoHeaderType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ResponseInfoHeaderType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ResponseInfoHeaderType*)p = *(ns1__ResponseInfoHeaderType*)q;
		break;
	case SOAP_TYPE_ns1__ResponseSaveReportType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ResponseSaveReportType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ResponseSaveReportType*)p = *(ns1__ResponseSaveReportType*)q;
		break;
	case SOAP_TYPE_ns1__DataItemType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DataItemType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DataItemType*)p = *(ns1__DataItemType*)q;
		break;
	case SOAP_TYPE_ns1__DataItemRow:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DataItemRow type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DataItemRow*)p = *(ns1__DataItemRow*)q;
		break;
	case SOAP_TYPE_ns1__BlockItemType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__BlockItemType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__BlockItemType*)p = *(ns1__BlockItemType*)q;
		break;
	case SOAP_TYPE_ns1__ReturnArrayDataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ReturnArrayDataType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ReturnArrayDataType*)p = *(ns1__ReturnArrayDataType*)q;
		break;
	case SOAP_TYPE_ns1__returnDataRowsPerGroup:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__returnDataRowsPerGroup type=%d location=%p object=%p\n", t, p, q));
		*(ns1__returnDataRowsPerGroup*)p = *(ns1__returnDataRowsPerGroup*)q;
		break;
	case SOAP_TYPE_ns1__ReturnMatrixDataTypePerGroup:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ReturnMatrixDataTypePerGroup type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ReturnMatrixDataTypePerGroup*)p = *(ns1__ReturnMatrixDataTypePerGroup*)q;
		break;
	case SOAP_TYPE_ns1__returnDataRowsPerSuperGroup:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__returnDataRowsPerSuperGroup type=%d location=%p object=%p\n", t, p, q));
		*(ns1__returnDataRowsPerSuperGroup*)p = *(ns1__returnDataRowsPerSuperGroup*)q;
		break;
	case SOAP_TYPE_ns1__ReturnMatrixDataTypePerSuperGroup:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ReturnMatrixDataTypePerSuperGroup type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ReturnMatrixDataTypePerSuperGroup*)p = *(ns1__ReturnMatrixDataTypePerSuperGroup*)q;
		break;
	case SOAP_TYPE_ns1__ReturnMatrixDataTypeBG:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ReturnMatrixDataTypeBG type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ReturnMatrixDataTypeBG*)p = *(ns1__ReturnMatrixDataTypeBG*)q;
		break;
	case SOAP_TYPE_ns1__LoginRequestType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__LoginRequestType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__LoginRequestType*)p = *(ns1__LoginRequestType*)q;
		break;
	case SOAP_TYPE_ns1__LoginReturnType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__LoginReturnType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__LoginReturnType*)p = *(ns1__LoginReturnType*)q;
		break;
	case SOAP_TYPE_ns1__GenRequestType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GenRequestType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GenRequestType*)p = *(ns1__GenRequestType*)q;
		break;
	case SOAP_TYPE_ns1__GroupListDataItemType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GroupListDataItemType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GroupListDataItemType*)p = *(ns1__GroupListDataItemType*)q;
		break;
	case SOAP_TYPE_ns1__GroupListReturnType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GroupListReturnType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GroupListReturnType*)p = *(ns1__GroupListReturnType*)q;
		break;
	case SOAP_TYPE_ns1__GenListDataItemType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GenListDataItemType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GenListDataItemType*)p = *(ns1__GenListDataItemType*)q;
		break;
	case SOAP_TYPE_ns1__GenListReturnType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GenListReturnType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GenListReturnType*)p = *(ns1__GenListReturnType*)q;
		break;
	case SOAP_TYPE_ns1__AgentsListDataItemType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__AgentsListDataItemType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__AgentsListDataItemType*)p = *(ns1__AgentsListDataItemType*)q;
		break;
	case SOAP_TYPE_ns1__AgentsListReturnType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__AgentsListReturnType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__AgentsListReturnType*)p = *(ns1__AgentsListReturnType*)q;
		break;
	case SOAP_TYPE_ns1__BriefInfoRequestType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__BriefInfoRequestType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__BriefInfoRequestType*)p = *(ns1__BriefInfoRequestType*)q;
		break;
	case SOAP_TYPE_ns1__DefaultWorkspaceRequestType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DefaultWorkspaceRequestType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DefaultWorkspaceRequestType*)p = *(ns1__DefaultWorkspaceRequestType*)q;
		break;
	case SOAP_TYPE_ns1__DefaultWorkspaceItemType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DefaultWorkspaceItemType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DefaultWorkspaceItemType*)p = *(ns1__DefaultWorkspaceItemType*)q;
		break;
	case SOAP_TYPE_ns1__DefaultWorkspaceReturnType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DefaultWorkspaceReturnType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DefaultWorkspaceReturnType*)p = *(ns1__DefaultWorkspaceReturnType*)q;
		break;
	case SOAP_TYPE_ns1__ReportListDataRequestType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ReportListDataRequestType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ReportListDataRequestType*)p = *(ns1__ReportListDataRequestType*)q;
		break;
	case SOAP_TYPE_ns1__ReportListDataItemType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ReportListDataItemType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ReportListDataItemType*)p = *(ns1__ReportListDataItemType*)q;
		break;
	case SOAP_TYPE_ns1__ReportListDataReturnType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ReportListDataReturnType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ReportListDataReturnType*)p = *(ns1__ReportListDataReturnType*)q;
		break;
	case SOAP_TYPE_ns1__DNISListDataItemType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DNISListDataItemType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DNISListDataItemType*)p = *(ns1__DNISListDataItemType*)q;
		break;
	case SOAP_TYPE_ns1__DNISListReturnType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DNISListReturnType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DNISListReturnType*)p = *(ns1__DNISListReturnType*)q;
		break;
	case SOAP_TYPE_ns1__BriefDNISInfoRequestType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__BriefDNISInfoRequestType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__BriefDNISInfoRequestType*)p = *(ns1__BriefDNISInfoRequestType*)q;
		break;
	case SOAP_TYPE_ns1__SuperGroupListDataItemType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SuperGroupListDataItemType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SuperGroupListDataItemType*)p = *(ns1__SuperGroupListDataItemType*)q;
		break;
	case SOAP_TYPE_ns1__SuperGroupListReturnType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SuperGroupListReturnType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SuperGroupListReturnType*)p = *(ns1__SuperGroupListReturnType*)q;
		break;
	case SOAP_TYPE_ns1__SaveWorkspaseRequestType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SaveWorkspaseRequestType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SaveWorkspaseRequestType*)p = *(ns1__SaveWorkspaseRequestType*)q;
		break;
	case SOAP_TYPE_ns1__RequestSaveReportType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RequestSaveReportType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RequestSaveReportType*)p = *(ns1__RequestSaveReportType*)q;
		break;
	case SOAP_TYPE_ns1__RequestDeleteReportType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RequestDeleteReportType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RequestDeleteReportType*)p = *(ns1__RequestDeleteReportType*)q;
		break;
	case SOAP_TYPE_ns1__LoginManagerRequestType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__LoginManagerRequestType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__LoginManagerRequestType*)p = *(ns1__LoginManagerRequestType*)q;
		break;
	case SOAP_TYPE_ns1__ApplicationRegisterRequestType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ApplicationRegisterRequestType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ApplicationRegisterRequestType*)p = *(ns1__ApplicationRegisterRequestType*)q;
		break;
	case SOAP_TYPE_ns1__ApplicationKeepAliveRequestType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ApplicationKeepAliveRequestType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ApplicationKeepAliveRequestType*)p = *(ns1__ApplicationKeepAliveRequestType*)q;
		break;
	case SOAP_TYPE_ns1__ApplicationReturnType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ApplicationReturnType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ApplicationReturnType*)p = *(ns1__ApplicationReturnType*)q;
		break;
	case SOAP_TYPE_ns1__StatRequestType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__StatRequestType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__StatRequestType*)p = *(ns1__StatRequestType*)q;
		break;
	case SOAP_TYPE_ns1__StatItemType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__StatItemType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__StatItemType*)p = *(ns1__StatItemType*)q;
		break;
	case SOAP_TYPE_ns1__StatReturnType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__StatReturnType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__StatReturnType*)p = *(ns1__StatReturnType*)q;
		break;
	case SOAP_TYPE___ns1__GroupDetailFullInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GroupDetailFullInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GroupDetailFullInfo*)p = *(struct __ns1__GroupDetailFullInfo*)q;
		break;
	case SOAP_TYPE___ns1__GroupQueInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GroupQueInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GroupQueInfo*)p = *(struct __ns1__GroupQueInfo*)q;
		break;
	case SOAP_TYPE___ns1__GroupAgentsInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GroupAgentsInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GroupAgentsInfo*)p = *(struct __ns1__GroupAgentsInfo*)q;
		break;
	case SOAP_TYPE___ns1__GroupAbndInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GroupAbndInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GroupAbndInfo*)p = *(struct __ns1__GroupAbndInfo*)q;
		break;
	case SOAP_TYPE___ns1__GroupIntOvfInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GroupIntOvfInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GroupIntOvfInfo*)p = *(struct __ns1__GroupIntOvfInfo*)q;
		break;
	case SOAP_TYPE___ns1__GroupShiftInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GroupShiftInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GroupShiftInfo*)p = *(struct __ns1__GroupShiftInfo*)q;
		break;
	case SOAP_TYPE___ns1__GroupGeneralInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GroupGeneralInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GroupGeneralInfo*)p = *(struct __ns1__GroupGeneralInfo*)q;
		break;
	case SOAP_TYPE___ns1__GroupPeriodInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GroupPeriodInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GroupPeriodInfo*)p = *(struct __ns1__GroupPeriodInfo*)q;
		break;
	case SOAP_TYPE___ns1__IvrApplInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__IvrApplInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__IvrApplInfo*)p = *(struct __ns1__IvrApplInfo*)q;
		break;
	case SOAP_TYPE___ns1__IvrPortInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__IvrPortInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__IvrPortInfo*)p = *(struct __ns1__IvrPortInfo*)q;
		break;
	case SOAP_TYPE___ns1__IvrGrpInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__IvrGrpInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__IvrGrpInfo*)p = *(struct __ns1__IvrGrpInfo*)q;
		break;
	case SOAP_TYPE___ns1__MailboxInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__MailboxInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__MailboxInfo*)p = *(struct __ns1__MailboxInfo*)q;
		break;
	case SOAP_TYPE___ns1__SuperGroupInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SuperGroupInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SuperGroupInfo*)p = *(struct __ns1__SuperGroupInfo*)q;
		break;
	case SOAP_TYPE___ns1__SuperGroupList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SuperGroupList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SuperGroupList*)p = *(struct __ns1__SuperGroupList*)q;
		break;
	case SOAP_TYPE___ns1__UserLogin:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UserLogin type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UserLogin*)p = *(struct __ns1__UserLogin*)q;
		break;
	case SOAP_TYPE___ns1__UserLogout:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UserLogout type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UserLogout*)p = *(struct __ns1__UserLogout*)q;
		break;
	case SOAP_TYPE___ns1__GroupList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GroupList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GroupList*)p = *(struct __ns1__GroupList*)q;
		break;
	case SOAP_TYPE___ns1__IvrPortGroupList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__IvrPortGroupList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__IvrPortGroupList*)p = *(struct __ns1__IvrPortGroupList*)q;
		break;
	case SOAP_TYPE___ns1__IvrAppList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__IvrAppList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__IvrAppList*)p = *(struct __ns1__IvrAppList*)q;
		break;
	case SOAP_TYPE___ns1__MailAccList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__MailAccList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__MailAccList*)p = *(struct __ns1__MailAccList*)q;
		break;
	case SOAP_TYPE___ns1__AgentsPerGroupInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__AgentsPerGroupInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__AgentsPerGroupInfo*)p = *(struct __ns1__AgentsPerGroupInfo*)q;
		break;
	case SOAP_TYPE___ns1__AgentsList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__AgentsList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__AgentsList*)p = *(struct __ns1__AgentsList*)q;
		break;
	case SOAP_TYPE___ns1__BriefAgents:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__BriefAgents type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__BriefAgents*)p = *(struct __ns1__BriefAgents*)q;
		break;
	case SOAP_TYPE___ns1__DefaultWorkspace:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DefaultWorkspace type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DefaultWorkspace*)p = *(struct __ns1__DefaultWorkspace*)q;
		break;
	case SOAP_TYPE___ns1__ReportListData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ReportListData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ReportListData*)p = *(struct __ns1__ReportListData*)q;
		break;
	case SOAP_TYPE___ns1__VoiceDNISList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__VoiceDNISList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__VoiceDNISList*)p = *(struct __ns1__VoiceDNISList*)q;
		break;
	case SOAP_TYPE___ns1__EmailDNISList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__EmailDNISList type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__EmailDNISList*)p = *(struct __ns1__EmailDNISList*)q;
		break;
	case SOAP_TYPE___ns1__BriefVoiceDNIS:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__BriefVoiceDNIS type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__BriefVoiceDNIS*)p = *(struct __ns1__BriefVoiceDNIS*)q;
		break;
	case SOAP_TYPE___ns1__BriefEmailDNIS:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__BriefEmailDNIS type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__BriefEmailDNIS*)p = *(struct __ns1__BriefEmailDNIS*)q;
		break;
	case SOAP_TYPE___ns1__CommandAgentLoginLogout:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CommandAgentLoginLogout type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CommandAgentLoginLogout*)p = *(struct __ns1__CommandAgentLoginLogout*)q;
		break;
	case SOAP_TYPE___ns1__CommandAgentReleaseResume:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CommandAgentReleaseResume type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CommandAgentReleaseResume*)p = *(struct __ns1__CommandAgentReleaseResume*)q;
		break;
	case SOAP_TYPE___ns1__CommandAgentStartChat:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CommandAgentStartChat type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CommandAgentStartChat*)p = *(struct __ns1__CommandAgentStartChat*)q;
		break;
	case SOAP_TYPE___ns1__CommandAgentStartRecord:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CommandAgentStartRecord type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CommandAgentStartRecord*)p = *(struct __ns1__CommandAgentStartRecord*)q;
		break;
	case SOAP_TYPE___ns1__CommandAgentTelephonyFeatures:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CommandAgentTelephonyFeatures type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CommandAgentTelephonyFeatures*)p = *(struct __ns1__CommandAgentTelephonyFeatures*)q;
		break;
	case SOAP_TYPE___ns1__SaveWorkspase:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SaveWorkspase type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SaveWorkspase*)p = *(struct __ns1__SaveWorkspase*)q;
		break;
	case SOAP_TYPE___ns1__SaveReport:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SaveReport type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SaveReport*)p = *(struct __ns1__SaveReport*)q;
		break;
	case SOAP_TYPE___ns1__DeleteReport:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DeleteReport type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DeleteReport*)p = *(struct __ns1__DeleteReport*)q;
		break;
	case SOAP_TYPE___ns1__LoginManagerAgentsPerGroup:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__LoginManagerAgentsPerGroup type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__LoginManagerAgentsPerGroup*)p = *(struct __ns1__LoginManagerAgentsPerGroup*)q;
		break;
	case SOAP_TYPE___ns1__LoginManagerGroupsPerAgent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__LoginManagerGroupsPerAgent type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__LoginManagerGroupsPerAgent*)p = *(struct __ns1__LoginManagerGroupsPerAgent*)q;
		break;
	case SOAP_TYPE___ns1__LoginManagerOneAgentToMultiGroups:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__LoginManagerOneAgentToMultiGroups type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__LoginManagerOneAgentToMultiGroups*)p = *(struct __ns1__LoginManagerOneAgentToMultiGroups*)q;
		break;
	case SOAP_TYPE___ns1__LoginManagerMultiAgentsToOneGroup:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__LoginManagerMultiAgentsToOneGroup type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__LoginManagerMultiAgentsToOneGroup*)p = *(struct __ns1__LoginManagerMultiAgentsToOneGroup*)q;
		break;
	case SOAP_TYPE___ns1__LoginManagerAvailableAgentsForGroup:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__LoginManagerAvailableAgentsForGroup type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__LoginManagerAvailableAgentsForGroup*)p = *(struct __ns1__LoginManagerAvailableAgentsForGroup*)q;
		break;
	case SOAP_TYPE___ns1__LoginManagerAvailableGroupsForAgent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__LoginManagerAvailableGroupsForAgent type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__LoginManagerAvailableGroupsForAgent*)p = *(struct __ns1__LoginManagerAvailableGroupsForAgent*)q;
		break;
	case SOAP_TYPE___ns1__ApplicationRegister:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ApplicationRegister type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ApplicationRegister*)p = *(struct __ns1__ApplicationRegister*)q;
		break;
	case SOAP_TYPE___ns1__ApplicationKeepAlive:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ApplicationKeepAlive type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ApplicationKeepAlive*)p = *(struct __ns1__ApplicationKeepAlive*)q;
		break;
	case SOAP_TYPE___ns1__TraceInternalStat:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__TraceInternalStat type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__TraceInternalStat*)p = *(struct __ns1__TraceInternalStat*)q;
		break;
	case SOAP_TYPE___ns1__AgentNeedHelp:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__AgentNeedHelp type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__AgentNeedHelp*)p = *(struct __ns1__AgentNeedHelp*)q;
		break;
	case SOAP_TYPE___ns1__GroupHourlyInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GroupHourlyInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GroupHourlyInfo*)p = *(struct __ns1__GroupHourlyInfo*)q;
		break;
	case SOAP_TYPE___ns1__GroupDailyBriefInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GroupDailyBriefInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GroupDailyBriefInfo*)p = *(struct __ns1__GroupDailyBriefInfo*)q;
		break;
	case SOAP_TYPE___ns1__GroupDailyDetailedInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GroupDailyDetailedInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GroupDailyDetailedInfo*)p = *(struct __ns1__GroupDailyDetailedInfo*)q;
		break;
	case SOAP_TYPE___ns1__SuperGroupHourlyInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SuperGroupHourlyInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SuperGroupHourlyInfo*)p = *(struct __ns1__SuperGroupHourlyInfo*)q;
		break;
	case SOAP_TYPE___ns1__SuperGroupDailyBriefInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SuperGroupDailyBriefInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SuperGroupDailyBriefInfo*)p = *(struct __ns1__SuperGroupDailyBriefInfo*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type = %d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_short(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{
	return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_short(struct soap *soap, const char *tag, short *a, const char *type)
{
	a = soap_inshort(soap, tag, a, type, SOAP_TYPE_short);
	return a;
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_new_short(struct soap *soap, int n)
{
	short *a = static_cast<short *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(short)));
	for (short *p = a; p && n--; ++p)
		soap_default_short(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_short(struct soap *soap, const short *a, const char *tag, const char *type)
{
	if (soap_out_short(soap, tag ? tag : "short", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_short(struct soap *soap, short *p, const char *tag, const char *type)
{
	if ((p = soap_in_short(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	a = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return a;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_new_unsignedInt(struct soap *soap, int n)
{
	unsigned int *a = static_cast<unsigned int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned int)));
	for (unsigned int *p = a; p && n--; ++p)
		soap_default_unsignedInt(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out_unsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	if (n < 0)
	{	p = SOAP_NEW(std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__string, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


//============[ ns1__StatReturnType::Implemented Methods ]=============
//ctor
ns1__StatReturnType::ns1__StatReturnType(): responseInfoHeader(), returnStatArray(), soap()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ctor of ns1__StatReturnType(" << address << ")" << LOG_TERMINATOR;
  ////DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__StatReturnType(addr:%s)\n", address));
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__StatReturnType(addr:%p)\n", (void*)this));
}

//dtor
ns1__StatReturnType::~ns1__StatReturnType()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "dtor of ns1__StatReturnType(" << address << ")" << LOG_TERMINATOR;
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "dtor ns1__StatReturnType(addr:%p)\n", (void*)this));
}

/*--------------------------[ soap_default ]-------------------------------*/
void ns1__StatReturnType::soap_default(struct soap *soap)
{
  this->soap = soap;
  this->ns1__StatReturnType::responseInfoHeader = NULL;
  soap_default_std__vectorTemplateOfPointerTons1__StatItemType(soap, &this->ns1__StatReturnType::returnStatArray);
  /* transient soap skipped */
}

/*--------------------------[ soap_serialize ]-----------------------------*/
void ns1__StatReturnType::soap_serialize(struct soap *soap) const
{
  (void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
  soap_serialize_PointerTons1__ResponseInfoHeaderType(soap, &this->ns1__StatReturnType::responseInfoHeader);
  soap_serialize_std__vectorTemplateOfPointerTons1__StatItemType(soap, &this->ns1__StatReturnType::returnStatArray);
#endif
}

/*--------------------------[ soap_out ]-----------------------------------*/
int ns1__StatReturnType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
  return soap_out_ns1__StatReturnType(soap, tag, id, this, type);
}

/*--------------------------[ soap_out_ns1__StatReturnType ]---------------*/
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StatReturnType(struct soap *soap, const char *tag, int id, const ns1__StatReturnType *a, const char *type)
{
  (void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StatReturnType), type))
    return soap->error;
  if (!a->ns1__StatReturnType::responseInfoHeader)
  {
    if (soap_element_empty(soap, "responseInfoHeader"))
      return soap->error;
  }
  else
    if (soap_out_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", -1, &a->ns1__StatReturnType::responseInfoHeader, ""))
      return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__StatItemType(soap, "returnStatArray", -1, &a->ns1__StatReturnType::returnStatArray, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

/*--------------------------[ soap_in ]------------------------------------*/
void *ns1__StatReturnType::soap_in(struct soap *soap, const char *tag, const char *type)
{
  return soap_in_ns1__StatReturnType(soap, tag, this, type);
}

/*--------------------------[ soap_in_ns1__StatReturnType ]----------------*/
SOAP_FMAC3 ns1__StatReturnType * SOAP_FMAC4 soap_in_ns1__StatReturnType(struct soap *soap, const char *tag, ns1__StatReturnType *a, const char *type)
{
  (void)tag; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (ns1__StatReturnType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StatReturnType, sizeof(ns1__StatReturnType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
  if (!a)
    return NULL;
  if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__StatReturnType)
  {
    soap_revert(soap);
    *soap->id = '\0';
    return (ns1__StatReturnType *)a->soap_in(soap, tag, type);
  }
  if (soap->alloced)
    a->soap_default(soap);
  size_t soap_flag_responseInfoHeader1 = 1;
  if (soap->body && *soap->href != '#')
  {
    for (;;)
    {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_responseInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", &a->ns1__StatReturnType::responseInfoHeader, "ns1:ResponseInfoHeaderType"))
        {
          soap_flag_responseInfoHeader1--;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_std__vectorTemplateOfPointerTons1__StatItemType(soap, "returnStatArray", &a->ns1__StatReturnType::returnStatArray, "ns1:StatItemType"))
          continue;
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
    if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__StatReturnType::responseInfoHeader))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }
  }
  else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
  {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  else
  {
    a = (ns1__StatReturnType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StatReturnType, SOAP_TYPE_ns1__StatReturnType, sizeof(ns1__StatReturnType), 0, soap_finsert, soap_fbase);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

/*----------------------[ soap_instantiate_ns1__StatReturnType ]-----------*/
SOAP_FMAC1 ns1__StatReturnType * SOAP_FMAC2 soap_instantiate_ns1__StatReturnType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__StatReturnType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
  (void)type; (void)arrayType; /* appease -Wall -Werror */
  ns1__StatReturnType *p;
  size_t k = sizeof(ns1__StatReturnType);
  if (n < 0)
  {
    p = SOAP_NEW(ns1__StatReturnType);
    if (p)
      ((ns1__StatReturnType*)p)->soap = soap;
  }
  else
  {
    p = SOAP_NEW_ARRAY(ns1__StatReturnType, n);
    k *= n;
    if (p)
      for (int i = 0; i < n; i++)
        ((ns1__StatReturnType*)p)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__StatReturnType location=%p n=%d\n", (void*)p, n));
  soap_link(soap, p, SOAP_TYPE_ns1__StatReturnType, n, soap_fdelete);
  if (size)
    *size = k;
  return p;
}

/*--------------------------[ soap_put ]-----------------------------------*/
int ns1__StatReturnType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
  if (soap_out_ns1__StatReturnType(soap, tag ? tag : "ns1:StatReturnType", -2, this, type))
    return soap->error;
  return soap_putindependent(soap);
}

/*--------------------------[ soap_get ]-----------------------------------*/
void *ns1__StatReturnType::soap_get(struct soap *soap, const char *tag, const char *type)
{
  return soap_get_ns1__StatReturnType(soap, this, tag, type);
}

/*--------------------------[ soap_get_ns1__StatReturnType ]---------------*/
SOAP_FMAC3 ns1__StatReturnType * SOAP_FMAC4 soap_get_ns1__StatReturnType(struct soap *soap, ns1__StatReturnType *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns1__StatReturnType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

/*--------------------------[ soap_dealloc ]-------------------------------*/
void ns1__StatReturnType::soap_dealloc()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ns1__StatReturnType::soap_dealloc(" << address << ")" << LOG_TERMINATOR;
  for(unsigned int i=0; i<returnStatArray.size(); i++)
  {
    //er_sprintf(address, "%p", returnStatArray[i]);
    //soap_obj_log_d << "ns1__StatReturnType::soap_dealloc - delete " << address << ")" << LOG_TERMINATOR;
    delete []returnStatArray[i];
  }
  returnStatArray.clear();
}



void ns1__StatItemType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__StatItemType::ipAddress);
	soap_default_std__string(soap, &this->ns1__StatItemType::applicationId);
	soap_default_unsignedInt(soap, &this->ns1__StatItemType::lastKeepAliveSecAgo);
	soap_default_unsignedInt(soap, &this->ns1__StatItemType::numOfVisors);
	soap_default_unsignedInt(soap, &this->ns1__StatItemType::numOfMonitors);
	soap_default_unsignedInt(soap, &this->ns1__StatItemType::numOfWebVisors);
	soap_default_unsignedInt(soap, &this->ns1__StatItemType::totalNumberOfSoapConnections);
	soap_default_unsignedInt(soap, &this->ns1__StatItemType::numberOfSoapConnectionsSinceLastStatRequest);
	soap_default_unsignedInt(soap, &this->ns1__StatItemType::CurrentNumberOfSoapConnections);
	soap_default_unsignedInt(soap, &this->ns1__StatItemType::LastError);
	/* transient soap skipped */
}

void ns1__StatItemType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__StatItemType::ipAddress);
	soap_serialize_std__string(soap, &this->ns1__StatItemType::applicationId);
	soap_embedded(soap, &this->ns1__StatItemType::lastKeepAliveSecAgo, SOAP_TYPE_unsignedInt);
	soap_embedded(soap, &this->ns1__StatItemType::numOfVisors, SOAP_TYPE_unsignedInt);
	soap_embedded(soap, &this->ns1__StatItemType::numOfMonitors, SOAP_TYPE_unsignedInt);
	soap_embedded(soap, &this->ns1__StatItemType::numOfWebVisors, SOAP_TYPE_unsignedInt);
	soap_embedded(soap, &this->ns1__StatItemType::totalNumberOfSoapConnections, SOAP_TYPE_unsignedInt);
	soap_embedded(soap, &this->ns1__StatItemType::numberOfSoapConnectionsSinceLastStatRequest, SOAP_TYPE_unsignedInt);
	soap_embedded(soap, &this->ns1__StatItemType::CurrentNumberOfSoapConnections, SOAP_TYPE_unsignedInt);
	soap_embedded(soap, &this->ns1__StatItemType::LastError, SOAP_TYPE_unsignedInt);
#endif
}

int ns1__StatItemType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__StatItemType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StatItemType(struct soap *soap, const char *tag, int id, const ns1__StatItemType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StatItemType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ipAddress", -1, &a->ns1__StatItemType::ipAddress, ""))
		return soap->error;
	if (soap_out_std__string(soap, "applicationId", -1, &a->ns1__StatItemType::applicationId, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "lastKeepAliveSecAgo", -1, &a->ns1__StatItemType::lastKeepAliveSecAgo, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "numOfVisors", -1, &a->ns1__StatItemType::numOfVisors, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "numOfMonitors", -1, &a->ns1__StatItemType::numOfMonitors, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "numOfWebVisors", -1, &a->ns1__StatItemType::numOfWebVisors, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "totalNumberOfSoapConnections", -1, &a->ns1__StatItemType::totalNumberOfSoapConnections, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "numberOfSoapConnectionsSinceLastStatRequest", -1, &a->ns1__StatItemType::numberOfSoapConnectionsSinceLastStatRequest, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "CurrentNumberOfSoapConnections", -1, &a->ns1__StatItemType::CurrentNumberOfSoapConnections, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "LastError", -1, &a->ns1__StatItemType::LastError, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__StatItemType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__StatItemType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__StatItemType * SOAP_FMAC4 soap_in_ns1__StatItemType(struct soap *soap, const char *tag, ns1__StatItemType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__StatItemType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StatItemType, sizeof(ns1__StatItemType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__StatItemType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__StatItemType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ipAddress1 = 1;
	size_t soap_flag_applicationId1 = 1;
	size_t soap_flag_lastKeepAliveSecAgo1 = 1;
	size_t soap_flag_numOfVisors1 = 1;
	size_t soap_flag_numOfMonitors1 = 1;
	size_t soap_flag_numOfWebVisors1 = 1;
	size_t soap_flag_totalNumberOfSoapConnections1 = 1;
	size_t soap_flag_numberOfSoapConnectionsSinceLastStatRequest1 = 1;
	size_t soap_flag_CurrentNumberOfSoapConnections1 = 1;
	size_t soap_flag_LastError1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ipAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ipAddress", &a->ns1__StatItemType::ipAddress, "xsd:string"))
				{	soap_flag_ipAddress1--;
					continue;
				}
			}
			if (soap_flag_applicationId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "applicationId", &a->ns1__StatItemType::applicationId, "xsd:string"))
				{	soap_flag_applicationId1--;
					continue;
				}
			}
			if (soap_flag_lastKeepAliveSecAgo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "lastKeepAliveSecAgo", &a->ns1__StatItemType::lastKeepAliveSecAgo, "xsd:unsignedInt"))
				{	soap_flag_lastKeepAliveSecAgo1--;
					continue;
				}
			}
			if (soap_flag_numOfVisors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "numOfVisors", &a->ns1__StatItemType::numOfVisors, "xsd:unsignedInt"))
				{	soap_flag_numOfVisors1--;
					continue;
				}
			}
			if (soap_flag_numOfMonitors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "numOfMonitors", &a->ns1__StatItemType::numOfMonitors, "xsd:unsignedInt"))
				{	soap_flag_numOfMonitors1--;
					continue;
				}
			}
			if (soap_flag_numOfWebVisors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "numOfWebVisors", &a->ns1__StatItemType::numOfWebVisors, "xsd:unsignedInt"))
				{	soap_flag_numOfWebVisors1--;
					continue;
				}
			}
			if (soap_flag_totalNumberOfSoapConnections1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "totalNumberOfSoapConnections", &a->ns1__StatItemType::totalNumberOfSoapConnections, "xsd:unsignedInt"))
				{	soap_flag_totalNumberOfSoapConnections1--;
					continue;
				}
			}
			if (soap_flag_numberOfSoapConnectionsSinceLastStatRequest1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "numberOfSoapConnectionsSinceLastStatRequest", &a->ns1__StatItemType::numberOfSoapConnectionsSinceLastStatRequest, "xsd:unsignedInt"))
				{	soap_flag_numberOfSoapConnectionsSinceLastStatRequest1--;
					continue;
				}
			}
			if (soap_flag_CurrentNumberOfSoapConnections1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "CurrentNumberOfSoapConnections", &a->ns1__StatItemType::CurrentNumberOfSoapConnections, "xsd:unsignedInt"))
				{	soap_flag_CurrentNumberOfSoapConnections1--;
					continue;
				}
			}
			if (soap_flag_LastError1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "LastError", &a->ns1__StatItemType::LastError, "xsd:unsignedInt"))
				{	soap_flag_LastError1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ipAddress1 > 0 || soap_flag_applicationId1 > 0 || soap_flag_lastKeepAliveSecAgo1 > 0 || soap_flag_numOfVisors1 > 0 || soap_flag_numOfMonitors1 > 0 || soap_flag_numOfWebVisors1 > 0 || soap_flag_totalNumberOfSoapConnections1 > 0 || soap_flag_numberOfSoapConnectionsSinceLastStatRequest1 > 0 || soap_flag_CurrentNumberOfSoapConnections1 > 0 || soap_flag_LastError1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__StatItemType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StatItemType, SOAP_TYPE_ns1__StatItemType, sizeof(ns1__StatItemType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__StatItemType * SOAP_FMAC2 soap_instantiate_ns1__StatItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__StatItemType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__StatItemType *p;
	size_t k = sizeof(ns1__StatItemType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__StatItemType);
		if (p)
			((ns1__StatItemType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__StatItemType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__StatItemType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__StatItemType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__StatItemType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__StatItemType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__StatItemType(soap, tag ? tag : "ns1:StatItemType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__StatItemType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__StatItemType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__StatItemType * SOAP_FMAC4 soap_get_ns1__StatItemType(struct soap *soap, ns1__StatItemType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StatItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__StatRequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_unsignedInt(soap, &this->ns1__StatRequestType::serviceReqId);
	/* transient soap skipped */
}

void ns1__StatRequestType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__StatRequestType::serviceReqId, SOAP_TYPE_unsignedInt);
#endif
}

int ns1__StatRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__StatRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StatRequestType(struct soap *soap, const char *tag, int id, const ns1__StatRequestType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StatRequestType), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "serviceReqId", -1, &a->ns1__StatRequestType::serviceReqId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__StatRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__StatRequestType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__StatRequestType * SOAP_FMAC4 soap_in_ns1__StatRequestType(struct soap *soap, const char *tag, ns1__StatRequestType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__StatRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StatRequestType, sizeof(ns1__StatRequestType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__StatRequestType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__StatRequestType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_serviceReqId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_serviceReqId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "serviceReqId", &a->ns1__StatRequestType::serviceReqId, "xsd:unsignedInt"))
				{	soap_flag_serviceReqId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_serviceReqId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__StatRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StatRequestType, SOAP_TYPE_ns1__StatRequestType, sizeof(ns1__StatRequestType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__StatRequestType * SOAP_FMAC2 soap_instantiate_ns1__StatRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__StatRequestType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__StatRequestType *p;
	size_t k = sizeof(ns1__StatRequestType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__StatRequestType);
		if (p)
			((ns1__StatRequestType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__StatRequestType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__StatRequestType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__StatRequestType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__StatRequestType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__StatRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__StatRequestType(soap, tag ? tag : "ns1:StatRequestType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__StatRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__StatRequestType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__StatRequestType * SOAP_FMAC4 soap_get_ns1__StatRequestType(struct soap *soap, ns1__StatRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StatRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ApplicationReturnType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ApplicationReturnType::responseInfoHeader = NULL;
	/* transient soap skipped */
}

void ns1__ApplicationReturnType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ResponseInfoHeaderType(soap, &this->ns1__ApplicationReturnType::responseInfoHeader);
#endif
}

int ns1__ApplicationReturnType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ApplicationReturnType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ApplicationReturnType(struct soap *soap, const char *tag, int id, const ns1__ApplicationReturnType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ApplicationReturnType), type))
		return soap->error;
	if (!a->ns1__ApplicationReturnType::responseInfoHeader)
	{	if (soap_element_empty(soap, "responseInfoHeader"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", -1, &a->ns1__ApplicationReturnType::responseInfoHeader, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ApplicationReturnType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ApplicationReturnType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ApplicationReturnType * SOAP_FMAC4 soap_in_ns1__ApplicationReturnType(struct soap *soap, const char *tag, ns1__ApplicationReturnType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ApplicationReturnType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ApplicationReturnType, sizeof(ns1__ApplicationReturnType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ApplicationReturnType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ApplicationReturnType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_responseInfoHeader1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_responseInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", &a->ns1__ApplicationReturnType::responseInfoHeader, "ns1:ResponseInfoHeaderType"))
				{	soap_flag_responseInfoHeader1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__ApplicationReturnType::responseInfoHeader))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ApplicationReturnType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ApplicationReturnType, SOAP_TYPE_ns1__ApplicationReturnType, sizeof(ns1__ApplicationReturnType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ApplicationReturnType * SOAP_FMAC2 soap_instantiate_ns1__ApplicationReturnType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ApplicationReturnType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ApplicationReturnType *p;
	size_t k = sizeof(ns1__ApplicationReturnType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ApplicationReturnType);
		if (p)
			((ns1__ApplicationReturnType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ApplicationReturnType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ApplicationReturnType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ApplicationReturnType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__ApplicationReturnType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ApplicationReturnType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ApplicationReturnType(soap, tag ? tag : "ns1:ApplicationReturnType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ApplicationReturnType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ApplicationReturnType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ApplicationReturnType * SOAP_FMAC4 soap_get_ns1__ApplicationReturnType(struct soap *soap, ns1__ApplicationReturnType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ApplicationReturnType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ApplicationKeepAliveRequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_unsignedInt(soap, &this->ns1__ApplicationKeepAliveRequestType::serviceReqId);
	soap_default_std__string(soap, &this->ns1__ApplicationKeepAliveRequestType::applicationId);
	/* transient soap skipped */
}

void ns1__ApplicationKeepAliveRequestType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__ApplicationKeepAliveRequestType::serviceReqId, SOAP_TYPE_unsignedInt);
	soap_serialize_std__string(soap, &this->ns1__ApplicationKeepAliveRequestType::applicationId);
#endif
}

int ns1__ApplicationKeepAliveRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ApplicationKeepAliveRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ApplicationKeepAliveRequestType(struct soap *soap, const char *tag, int id, const ns1__ApplicationKeepAliveRequestType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ApplicationKeepAliveRequestType), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "serviceReqId", -1, &a->ns1__ApplicationKeepAliveRequestType::serviceReqId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "applicationId", -1, &a->ns1__ApplicationKeepAliveRequestType::applicationId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ApplicationKeepAliveRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ApplicationKeepAliveRequestType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ApplicationKeepAliveRequestType * SOAP_FMAC4 soap_in_ns1__ApplicationKeepAliveRequestType(struct soap *soap, const char *tag, ns1__ApplicationKeepAliveRequestType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ApplicationKeepAliveRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ApplicationKeepAliveRequestType, sizeof(ns1__ApplicationKeepAliveRequestType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ApplicationKeepAliveRequestType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ApplicationKeepAliveRequestType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_serviceReqId1 = 1;
	size_t soap_flag_applicationId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_serviceReqId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "serviceReqId", &a->ns1__ApplicationKeepAliveRequestType::serviceReqId, "xsd:unsignedInt"))
				{	soap_flag_serviceReqId1--;
					continue;
				}
			}
			if (soap_flag_applicationId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "applicationId", &a->ns1__ApplicationKeepAliveRequestType::applicationId, "xsd:string"))
				{	soap_flag_applicationId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_serviceReqId1 > 0 || soap_flag_applicationId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ApplicationKeepAliveRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ApplicationKeepAliveRequestType, SOAP_TYPE_ns1__ApplicationKeepAliveRequestType, sizeof(ns1__ApplicationKeepAliveRequestType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ApplicationKeepAliveRequestType * SOAP_FMAC2 soap_instantiate_ns1__ApplicationKeepAliveRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ApplicationKeepAliveRequestType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ApplicationKeepAliveRequestType *p;
	size_t k = sizeof(ns1__ApplicationKeepAliveRequestType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ApplicationKeepAliveRequestType);
		if (p)
			((ns1__ApplicationKeepAliveRequestType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ApplicationKeepAliveRequestType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ApplicationKeepAliveRequestType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ApplicationKeepAliveRequestType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__ApplicationKeepAliveRequestType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ApplicationKeepAliveRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ApplicationKeepAliveRequestType(soap, tag ? tag : "ns1:ApplicationKeepAliveRequestType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ApplicationKeepAliveRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ApplicationKeepAliveRequestType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ApplicationKeepAliveRequestType * SOAP_FMAC4 soap_get_ns1__ApplicationKeepAliveRequestType(struct soap *soap, ns1__ApplicationKeepAliveRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ApplicationKeepAliveRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ApplicationRegisterRequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_unsignedInt(soap, &this->ns1__ApplicationRegisterRequestType::serviceReqId);
	soap_default_std__string(soap, &this->ns1__ApplicationRegisterRequestType::applicationId);
	/* transient soap skipped */
}

void ns1__ApplicationRegisterRequestType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__ApplicationRegisterRequestType::serviceReqId, SOAP_TYPE_unsignedInt);
	soap_serialize_std__string(soap, &this->ns1__ApplicationRegisterRequestType::applicationId);
#endif
}

int ns1__ApplicationRegisterRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ApplicationRegisterRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ApplicationRegisterRequestType(struct soap *soap, const char *tag, int id, const ns1__ApplicationRegisterRequestType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ApplicationRegisterRequestType), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "serviceReqId", -1, &a->ns1__ApplicationRegisterRequestType::serviceReqId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "applicationId", -1, &a->ns1__ApplicationRegisterRequestType::applicationId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ApplicationRegisterRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ApplicationRegisterRequestType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ApplicationRegisterRequestType * SOAP_FMAC4 soap_in_ns1__ApplicationRegisterRequestType(struct soap *soap, const char *tag, ns1__ApplicationRegisterRequestType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ApplicationRegisterRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ApplicationRegisterRequestType, sizeof(ns1__ApplicationRegisterRequestType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ApplicationRegisterRequestType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ApplicationRegisterRequestType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_serviceReqId1 = 1;
	size_t soap_flag_applicationId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_serviceReqId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "serviceReqId", &a->ns1__ApplicationRegisterRequestType::serviceReqId, "xsd:unsignedInt"))
				{	soap_flag_serviceReqId1--;
					continue;
				}
			}
			if (soap_flag_applicationId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "applicationId", &a->ns1__ApplicationRegisterRequestType::applicationId, "xsd:string"))
				{	soap_flag_applicationId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_serviceReqId1 > 0 || soap_flag_applicationId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ApplicationRegisterRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ApplicationRegisterRequestType, SOAP_TYPE_ns1__ApplicationRegisterRequestType, sizeof(ns1__ApplicationRegisterRequestType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ApplicationRegisterRequestType * SOAP_FMAC2 soap_instantiate_ns1__ApplicationRegisterRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ApplicationRegisterRequestType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ApplicationRegisterRequestType *p;
	size_t k = sizeof(ns1__ApplicationRegisterRequestType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ApplicationRegisterRequestType);
		if (p)
			((ns1__ApplicationRegisterRequestType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ApplicationRegisterRequestType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ApplicationRegisterRequestType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ApplicationRegisterRequestType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__ApplicationRegisterRequestType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ApplicationRegisterRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ApplicationRegisterRequestType(soap, tag ? tag : "ns1:ApplicationRegisterRequestType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ApplicationRegisterRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ApplicationRegisterRequestType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ApplicationRegisterRequestType * SOAP_FMAC4 soap_get_ns1__ApplicationRegisterRequestType(struct soap *soap, ns1__ApplicationRegisterRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ApplicationRegisterRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__LoginManagerRequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__LoginManagerRequestType::requestInfoHeader = NULL;
	soap_default_unsignedInt(soap, &this->ns1__LoginManagerRequestType::Id);
	/* transient soap skipped */
}

void ns1__LoginManagerRequestType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RequestInfoHeaderType(soap, &this->ns1__LoginManagerRequestType::requestInfoHeader);
	soap_embedded(soap, &this->ns1__LoginManagerRequestType::Id, SOAP_TYPE_unsignedInt);
#endif
}

int ns1__LoginManagerRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__LoginManagerRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LoginManagerRequestType(struct soap *soap, const char *tag, int id, const ns1__LoginManagerRequestType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LoginManagerRequestType), type))
		return soap->error;
	if (!a->ns1__LoginManagerRequestType::requestInfoHeader)
	{	if (soap_element_empty(soap, "requestInfoHeader"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", -1, &a->ns1__LoginManagerRequestType::requestInfoHeader, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "Id", -1, &a->ns1__LoginManagerRequestType::Id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__LoginManagerRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__LoginManagerRequestType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__LoginManagerRequestType * SOAP_FMAC4 soap_in_ns1__LoginManagerRequestType(struct soap *soap, const char *tag, ns1__LoginManagerRequestType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__LoginManagerRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LoginManagerRequestType, sizeof(ns1__LoginManagerRequestType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__LoginManagerRequestType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__LoginManagerRequestType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_requestInfoHeader1 = 1;
	size_t soap_flag_Id1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", &a->ns1__LoginManagerRequestType::requestInfoHeader, "ns1:RequestInfoHeaderType"))
				{	soap_flag_requestInfoHeader1--;
					continue;
				}
			}
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "Id", &a->ns1__LoginManagerRequestType::Id, "xsd:unsignedInt"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__LoginManagerRequestType::requestInfoHeader || soap_flag_Id1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__LoginManagerRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LoginManagerRequestType, SOAP_TYPE_ns1__LoginManagerRequestType, sizeof(ns1__LoginManagerRequestType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__LoginManagerRequestType * SOAP_FMAC2 soap_instantiate_ns1__LoginManagerRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__LoginManagerRequestType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__LoginManagerRequestType *p;
	size_t k = sizeof(ns1__LoginManagerRequestType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__LoginManagerRequestType);
		if (p)
			((ns1__LoginManagerRequestType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__LoginManagerRequestType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__LoginManagerRequestType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__LoginManagerRequestType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__LoginManagerRequestType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__LoginManagerRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__LoginManagerRequestType(soap, tag ? tag : "ns1:LoginManagerRequestType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__LoginManagerRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__LoginManagerRequestType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__LoginManagerRequestType * SOAP_FMAC4 soap_get_ns1__LoginManagerRequestType(struct soap *soap, ns1__LoginManagerRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LoginManagerRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RequestDeleteReportType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__RequestDeleteReportType::requestInfoHeader = NULL;
	soap_default_unsignedInt(soap, &this->ns1__RequestDeleteReportType::reportId);
	/* transient soap skipped */
}

void ns1__RequestDeleteReportType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RequestInfoHeaderType(soap, &this->ns1__RequestDeleteReportType::requestInfoHeader);
	soap_embedded(soap, &this->ns1__RequestDeleteReportType::reportId, SOAP_TYPE_unsignedInt);
#endif
}

int ns1__RequestDeleteReportType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RequestDeleteReportType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RequestDeleteReportType(struct soap *soap, const char *tag, int id, const ns1__RequestDeleteReportType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RequestDeleteReportType), type))
		return soap->error;
	if (!a->ns1__RequestDeleteReportType::requestInfoHeader)
	{	if (soap_element_empty(soap, "requestInfoHeader"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", -1, &a->ns1__RequestDeleteReportType::requestInfoHeader, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "reportId", -1, &a->ns1__RequestDeleteReportType::reportId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RequestDeleteReportType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__RequestDeleteReportType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RequestDeleteReportType * SOAP_FMAC4 soap_in_ns1__RequestDeleteReportType(struct soap *soap, const char *tag, ns1__RequestDeleteReportType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RequestDeleteReportType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RequestDeleteReportType, sizeof(ns1__RequestDeleteReportType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RequestDeleteReportType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RequestDeleteReportType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_requestInfoHeader1 = 1;
	size_t soap_flag_reportId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", &a->ns1__RequestDeleteReportType::requestInfoHeader, "ns1:RequestInfoHeaderType"))
				{	soap_flag_requestInfoHeader1--;
					continue;
				}
			}
			if (soap_flag_reportId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "reportId", &a->ns1__RequestDeleteReportType::reportId, "xsd:unsignedInt"))
				{	soap_flag_reportId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__RequestDeleteReportType::requestInfoHeader || soap_flag_reportId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RequestDeleteReportType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RequestDeleteReportType, SOAP_TYPE_ns1__RequestDeleteReportType, sizeof(ns1__RequestDeleteReportType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RequestDeleteReportType * SOAP_FMAC2 soap_instantiate_ns1__RequestDeleteReportType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RequestDeleteReportType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RequestDeleteReportType *p;
	size_t k = sizeof(ns1__RequestDeleteReportType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__RequestDeleteReportType);
		if (p)
			((ns1__RequestDeleteReportType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__RequestDeleteReportType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__RequestDeleteReportType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RequestDeleteReportType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__RequestDeleteReportType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__RequestDeleteReportType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RequestDeleteReportType(soap, tag ? tag : "ns1:RequestDeleteReportType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RequestDeleteReportType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RequestDeleteReportType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RequestDeleteReportType * SOAP_FMAC4 soap_get_ns1__RequestDeleteReportType(struct soap *soap, ns1__RequestDeleteReportType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RequestDeleteReportType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RequestSaveReportType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__RequestSaveReportType::requestInfoHeader = NULL;
	this->ns1__RequestSaveReportType::RequestItem = NULL;
	/* transient soap skipped */
}

void ns1__RequestSaveReportType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RequestInfoHeaderType(soap, &this->ns1__RequestSaveReportType::requestInfoHeader);
	soap_serialize_PointerTons1__ReportListDataItemType(soap, &this->ns1__RequestSaveReportType::RequestItem);
#endif
}

int ns1__RequestSaveReportType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RequestSaveReportType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RequestSaveReportType(struct soap *soap, const char *tag, int id, const ns1__RequestSaveReportType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RequestSaveReportType), type))
		return soap->error;
	if (!a->ns1__RequestSaveReportType::requestInfoHeader)
	{	if (soap_element_empty(soap, "requestInfoHeader"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", -1, &a->ns1__RequestSaveReportType::requestInfoHeader, ""))
		return soap->error;
	if (!a->ns1__RequestSaveReportType::RequestItem)
	{	if (soap_element_empty(soap, "RequestItem"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__ReportListDataItemType(soap, "RequestItem", -1, &a->ns1__RequestSaveReportType::RequestItem, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RequestSaveReportType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__RequestSaveReportType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RequestSaveReportType * SOAP_FMAC4 soap_in_ns1__RequestSaveReportType(struct soap *soap, const char *tag, ns1__RequestSaveReportType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RequestSaveReportType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RequestSaveReportType, sizeof(ns1__RequestSaveReportType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RequestSaveReportType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RequestSaveReportType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_requestInfoHeader1 = 1;
	size_t soap_flag_RequestItem1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", &a->ns1__RequestSaveReportType::requestInfoHeader, "ns1:RequestInfoHeaderType"))
				{	soap_flag_requestInfoHeader1--;
					continue;
				}
			}
			if (soap_flag_RequestItem1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ReportListDataItemType(soap, "RequestItem", &a->ns1__RequestSaveReportType::RequestItem, "ns1:ReportListDataItemType"))
				{	soap_flag_RequestItem1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__RequestSaveReportType::requestInfoHeader || !a->ns1__RequestSaveReportType::RequestItem))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RequestSaveReportType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RequestSaveReportType, SOAP_TYPE_ns1__RequestSaveReportType, sizeof(ns1__RequestSaveReportType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RequestSaveReportType * SOAP_FMAC2 soap_instantiate_ns1__RequestSaveReportType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RequestSaveReportType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RequestSaveReportType *p;
	size_t k = sizeof(ns1__RequestSaveReportType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__RequestSaveReportType);
		if (p)
			((ns1__RequestSaveReportType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__RequestSaveReportType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__RequestSaveReportType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RequestSaveReportType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__RequestSaveReportType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__RequestSaveReportType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RequestSaveReportType(soap, tag ? tag : "ns1:RequestSaveReportType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RequestSaveReportType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RequestSaveReportType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RequestSaveReportType * SOAP_FMAC4 soap_get_ns1__RequestSaveReportType(struct soap *soap, ns1__RequestSaveReportType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RequestSaveReportType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


//============[ ns1__SaveWorkspaseRequestType::Implemented Methods ]=========
//ctor
ns1__SaveWorkspaseRequestType::ns1__SaveWorkspaseRequestType(): requestInfoHeader(), RequestArray(), soap()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ctor of ns1__SaveWorkspaseRequestType(" << address << ")" << LOG_TERMINATOR;
  ////DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__SaveWorkspaseRequestType(addr:%s)\n", address));
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__SaveWorkspaseRequestType(addr:%p)\n", (void*)this));
}

//dtor
ns1__SaveWorkspaseRequestType::~ns1__SaveWorkspaseRequestType()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "dtor of ns1__SaveWorkspaseRequestType(" << address << ")" << LOG_TERMINATOR;
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "dtor ns1__SaveWorkspaseRequestType(addr:%p)\n", (void*)this));
}

/*--------------------------[ soap_default ]-------------------------------*/
void ns1__SaveWorkspaseRequestType::soap_default(struct soap *soap)
{
  this->soap = soap;
  this->ns1__SaveWorkspaseRequestType::requestInfoHeader = NULL;
  soap_default_std__vectorTemplateOfPointerTons1__DefaultWorkspaceItemType(soap, &this->ns1__SaveWorkspaseRequestType::RequestArray);
  soap_default_std__string(soap, &this->ns1__SaveWorkspaseRequestType::fontSize);
  soap_default_std__string(soap, &this->ns1__SaveWorkspaseRequestType::language);
  /* transient soap skipped */
}

/*--------------------------[ soap_serialize ]-----------------------------*/
void ns1__SaveWorkspaseRequestType::soap_serialize(struct soap *soap) const
{
  (void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
  soap_serialize_PointerTons1__RequestInfoHeaderType(soap, &this->ns1__SaveWorkspaseRequestType::requestInfoHeader);
  soap_serialize_std__vectorTemplateOfPointerTons1__DefaultWorkspaceItemType(soap, &this->ns1__SaveWorkspaseRequestType::RequestArray);
  soap_serialize_std__string(soap, &this->ns1__SaveWorkspaseRequestType::fontSize);
  soap_serialize_std__string(soap, &this->ns1__SaveWorkspaseRequestType::language);
#endif
}

/*--------------------------[ soap_out ]-----------------------------------*/
int ns1__SaveWorkspaseRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
  return soap_out_ns1__SaveWorkspaseRequestType(soap, tag, id, this, type);
}

/*--------------------[ soap_out_ns1__SaveWorkspaseRequestType ]-----------*/
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SaveWorkspaseRequestType(struct soap *soap, const char *tag, int id, const ns1__SaveWorkspaseRequestType *a, const char *type)
{
  (void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SaveWorkspaseRequestType), type))
    return soap->error;
  if (!a->ns1__SaveWorkspaseRequestType::requestInfoHeader)
  {
    if (soap_element_empty(soap, "requestInfoHeader"))
      return soap->error;
  }
  else
    if (soap_out_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", -1, &a->ns1__SaveWorkspaseRequestType::requestInfoHeader, ""))
      return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__DefaultWorkspaceItemType(soap, "RequestArray", -1, &a->ns1__SaveWorkspaseRequestType::RequestArray, ""))
    return soap->error;
  if (soap_out_std__string(soap, "fontSize", -1, &a->ns1__SaveWorkspaseRequestType::fontSize, ""))
    return soap->error;
  if (soap_out_std__string(soap, "language", -1, &a->ns1__SaveWorkspaseRequestType::language, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

/*--------------------------[ soap_in ]------------------------------------*/
void *ns1__SaveWorkspaseRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{
  return soap_in_ns1__SaveWorkspaseRequestType(soap, tag, this, type);
}

/*--------------------[ soap_in_ns1__SaveWorkspaseRequestType ]------------*/
SOAP_FMAC3 ns1__SaveWorkspaseRequestType * SOAP_FMAC4 soap_in_ns1__SaveWorkspaseRequestType(struct soap *soap, const char *tag, ns1__SaveWorkspaseRequestType *a, const char *type)
{
  (void)tag; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (ns1__SaveWorkspaseRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SaveWorkspaseRequestType, sizeof(ns1__SaveWorkspaseRequestType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
  if (!a)
    return NULL;
  if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SaveWorkspaseRequestType)
  {
    soap_revert(soap);
    *soap->id = '\0';
    return (ns1__SaveWorkspaseRequestType *)a->soap_in(soap, tag, type);
  }
  if (soap->alloced)
    a->soap_default(soap);
  size_t soap_flag_requestInfoHeader1 = 1;
  size_t soap_flag_fontSize1 = 1;
  size_t soap_flag_language1 = 1;
  if (soap->body && *soap->href != '#')
  {
    for (;;)
    {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_requestInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", &a->ns1__SaveWorkspaseRequestType::requestInfoHeader, "ns1:RequestInfoHeaderType"))
        {
          soap_flag_requestInfoHeader1--;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_std__vectorTemplateOfPointerTons1__DefaultWorkspaceItemType(soap, "RequestArray", &a->ns1__SaveWorkspaseRequestType::RequestArray, "ns1:DefaultWorkspaceItemType"))
          continue;
      }
      if (soap_flag_fontSize1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
      {
        if (soap_in_std__string(soap, "fontSize", &a->ns1__SaveWorkspaseRequestType::fontSize, "xsd:string"))
        {
          soap_flag_fontSize1--;
          continue;
        }
      }
      if (soap_flag_language1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
      {
        if (soap_in_std__string(soap, "language", &a->ns1__SaveWorkspaseRequestType::language, "xsd:string"))
        {
          soap_flag_language1--;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
    if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__SaveWorkspaseRequestType::requestInfoHeader || soap_flag_fontSize1 > 0 || soap_flag_language1 > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }
  }
  else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
  {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  else
  {
    a = (ns1__SaveWorkspaseRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SaveWorkspaseRequestType, SOAP_TYPE_ns1__SaveWorkspaseRequestType, sizeof(ns1__SaveWorkspaseRequestType), 0, soap_finsert, soap_fbase);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

/*-----------------[ soap_instantiate_ns1__SaveWorkspaseRequestType ]------*/
SOAP_FMAC1 ns1__SaveWorkspaseRequestType * SOAP_FMAC2 soap_instantiate_ns1__SaveWorkspaseRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SaveWorkspaseRequestType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
  (void)type; (void)arrayType; /* appease -Wall -Werror */
  ns1__SaveWorkspaseRequestType *p;
  size_t k = sizeof(ns1__SaveWorkspaseRequestType);
  if (n < 0)
  {
    p = SOAP_NEW(ns1__SaveWorkspaseRequestType);
    if (p)
      ((ns1__SaveWorkspaseRequestType*)p)->soap = soap;
  }
  else
  {
    p = SOAP_NEW_ARRAY(ns1__SaveWorkspaseRequestType, n);
    k *= n;
    if (p)
      for (int i = 0; i < n; i++)
        ((ns1__SaveWorkspaseRequestType*)p)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SaveWorkspaseRequestType location=%p n=%d\n", (void*)p, n));
  soap_link(soap, p, SOAP_TYPE_ns1__SaveWorkspaseRequestType, n, soap_fdelete);
  if (size)
    *size = k;
  return p;
}

/*--------------------------[ soap_put ]-----------------------------------*/
int ns1__SaveWorkspaseRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
  if (soap_out_ns1__SaveWorkspaseRequestType(soap, tag ? tag : "ns1:SaveWorkspaseRequestType", -2, this, type))
    return soap->error;
  return soap_putindependent(soap);
}

/*--------------------------[ soap_get ]-----------------------------------*/
void *ns1__SaveWorkspaseRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
  return soap_get_ns1__SaveWorkspaseRequestType(soap, this, tag, type);
}

/*--------------------------[ soap_get_ns1__SaveWorkspaseRequestType ]-----*/
SOAP_FMAC3 ns1__SaveWorkspaseRequestType * SOAP_FMAC4 soap_get_ns1__SaveWorkspaseRequestType(struct soap *soap, ns1__SaveWorkspaseRequestType *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns1__SaveWorkspaseRequestType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

/*--------------------------[ soap_dealloc ]-------------------------------*/
void ns1__SaveWorkspaseRequestType::soap_dealloc()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ns1__SaveWorkspaseRequestType::soap_dealloc(" << address << ")" << LOG_TERMINATOR;
  for(unsigned int i=0; i<RequestArray.size(); i++)
  {
    //er_sprintf(address, "%p", RequestArray[i]);
    //soap_obj_log_d << "ns1__SaveWorkspaseRequestType::soap_dealloc - delete " << address << ")" << LOG_TERMINATOR;
    delete []RequestArray[i];
  }
  RequestArray.clear();
}


//============[ ns1__SuperGroupListReturnType::Implemented Methods ]=======
/*--------------------------[ soap_default ]-------------------------------*/
void ns1__SuperGroupListReturnType::soap_default(struct soap *soap)
{
  this->soap = soap;
  this->ns1__SuperGroupListReturnType::responseInfoHeader = NULL;
  soap_default_std__vectorTemplateOfPointerTons1__SuperGroupListDataItemType(soap, &this->ns1__SuperGroupListReturnType::returnArray);
  /* transient soap skipped */
}

/*--------------------------[ soap_serialize ]-----------------------------*/
void ns1__SuperGroupListReturnType::soap_serialize(struct soap *soap) const
{
  (void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
  soap_serialize_PointerTons1__ResponseInfoHeaderType(soap, &this->ns1__SuperGroupListReturnType::responseInfoHeader);
  soap_serialize_std__vectorTemplateOfPointerTons1__SuperGroupListDataItemType(soap, &this->ns1__SuperGroupListReturnType::returnArray);
#endif
}

/*--------------------------[ soap_out ]-----------------------------------*/
int ns1__SuperGroupListReturnType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
  return soap_out_ns1__SuperGroupListReturnType(soap, tag, id, this, type);
}

/*--------------------[ soap_out_ns1__SuperGroupListReturnType ]-----------*/
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SuperGroupListReturnType(struct soap *soap, const char *tag, int id, const ns1__SuperGroupListReturnType *a, const char *type)
{
  (void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SuperGroupListReturnType), type))
    return soap->error;
  if (!a->ns1__SuperGroupListReturnType::responseInfoHeader)
  {
    if (soap_element_empty(soap, "responseInfoHeader"))
      return soap->error;
  }
  else
    if (soap_out_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", -1, &a->ns1__SuperGroupListReturnType::responseInfoHeader, ""))
      return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__SuperGroupListDataItemType(soap, "returnArray", -1, &a->ns1__SuperGroupListReturnType::returnArray, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

/*--------------------------[ soap_in ]------------------------------------*/
void *ns1__SuperGroupListReturnType::soap_in(struct soap *soap, const char *tag, const char *type)
{
  return soap_in_ns1__SuperGroupListReturnType(soap, tag, this, type);
}

/*--------------------[ soap_in_ns1__SuperGroupListReturnType ]------------*/
SOAP_FMAC3 ns1__SuperGroupListReturnType * SOAP_FMAC4 soap_in_ns1__SuperGroupListReturnType(struct soap *soap, const char *tag, ns1__SuperGroupListReturnType *a, const char *type)
{
  (void)tag; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (ns1__SuperGroupListReturnType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SuperGroupListReturnType, sizeof(ns1__SuperGroupListReturnType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
  if (!a)
    return NULL;
  if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SuperGroupListReturnType)
  {
    soap_revert(soap);
    *soap->id = '\0';
    return (ns1__SuperGroupListReturnType *)a->soap_in(soap, tag, type);
  }
  if (soap->alloced)
    a->soap_default(soap);
  size_t soap_flag_responseInfoHeader1 = 1;
  if (soap->body && *soap->href != '#')
  {
    for (;;)
    {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_responseInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", &a->ns1__SuperGroupListReturnType::responseInfoHeader, "ns1:ResponseInfoHeaderType"))
        {
          soap_flag_responseInfoHeader1--;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_std__vectorTemplateOfPointerTons1__SuperGroupListDataItemType(soap, "returnArray", &a->ns1__SuperGroupListReturnType::returnArray, "ns1:SuperGroupListDataItemType"))
          continue;
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
    if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__SuperGroupListReturnType::responseInfoHeader || a->ns1__SuperGroupListReturnType::returnArray.size() < 1))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }
  }
  else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
  {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  else
  {
    a = (ns1__SuperGroupListReturnType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SuperGroupListReturnType, SOAP_TYPE_ns1__SuperGroupListReturnType, sizeof(ns1__SuperGroupListReturnType), 0, soap_finsert, soap_fbase);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

/*-----------------[ soap_instantiate_ns1__SuperGroupListReturnType ]------*/
SOAP_FMAC1 ns1__SuperGroupListReturnType * SOAP_FMAC2 soap_instantiate_ns1__SuperGroupListReturnType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SuperGroupListReturnType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
  (void)type; (void)arrayType; /* appease -Wall -Werror */
  ns1__SuperGroupListReturnType *p;
  size_t k = sizeof(ns1__SuperGroupListReturnType);
  if (n < 0)
  {
    p = SOAP_NEW(ns1__SuperGroupListReturnType);
    if (p)
      ((ns1__SuperGroupListReturnType*)p)->soap = soap;
  }
  else
  {
    p = SOAP_NEW_ARRAY(ns1__SuperGroupListReturnType, n);
    k *= n;
    if (p)
      for (int i = 0; i < n; i++)
        ((ns1__SuperGroupListReturnType*)p)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SuperGroupListReturnType location=%p n=%d\n", (void*)p, n));
  soap_link(soap, p, SOAP_TYPE_ns1__SuperGroupListReturnType, n, soap_fdelete);
  if (size)
    *size = k;
  return p;
}

/*--------------------------[ soap_put ]-----------------------------------*/
int ns1__SuperGroupListReturnType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
  if (soap_out_ns1__SuperGroupListReturnType(soap, tag ? tag : "ns1:SuperGroupListReturnType", -2, this, type))
    return soap->error;
  return soap_putindependent(soap);
}

/*--------------------------[ soap_get ]-----------------------------------*/
void *ns1__SuperGroupListReturnType::soap_get(struct soap *soap, const char *tag, const char *type)
{
  return soap_get_ns1__SuperGroupListReturnType(soap, this, tag, type);
}

/*--------------------------[ soap_get_ns1__SuperGroupListReturnType ]-----*/
SOAP_FMAC3 ns1__SuperGroupListReturnType * SOAP_FMAC4 soap_get_ns1__SuperGroupListReturnType(struct soap *soap, ns1__SuperGroupListReturnType *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns1__SuperGroupListReturnType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

//1-Jun-2021 YR BZ#54502
/*--------------------------[ soap_dealloc ]-------------------------------*/
void ns1__SuperGroupListReturnType::soap_dealloc()
{
  for(unsigned int i=0; i<returnArray.size(); i++)
  {
    returnArray[i]->soap_dealloc();
    //char address[20];
    //er_sprintf(address, "%p", returnArray[i]);
    //soap_obj_log_d << "ns1__SuperGroupListReturnType::soap_dealloc - delete " << address << ")" << LOG_TERMINATOR;
    delete []returnArray[i];
  }
  returnArray.clear();
}



//============[ ns1__SuperGroupListDataItemType::Implemented Methods ]=======
/*--------------------------[ soap_default ]-------------------------------*/
void ns1__SuperGroupListDataItemType::soap_default(struct soap *soap)
{
  this->soap = soap;
  soap_default_unsignedInt(soap, &this->ns1__SuperGroupListDataItemType::superGroupId);
  soap_default_std__string(soap, &this->ns1__SuperGroupListDataItemType::superGroupName);
  soap_default_std__vectorTemplateOfPointerTons1__GroupListDataItemType(soap, &this->ns1__SuperGroupListDataItemType::returnArray);
  /* transient soap skipped */
}

/*--------------------------[ soap_serialize ]-----------------------------*/
void ns1__SuperGroupListDataItemType::soap_serialize(struct soap *soap) const
{
  (void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
  soap_embedded(soap, &this->ns1__SuperGroupListDataItemType::superGroupId, SOAP_TYPE_unsignedInt);
  soap_serialize_std__string(soap, &this->ns1__SuperGroupListDataItemType::superGroupName);
  soap_serialize_std__vectorTemplateOfPointerTons1__GroupListDataItemType(soap, &this->ns1__SuperGroupListDataItemType::returnArray);
#endif
}

/*--------------------------[ soap_out ]-----------------------------------*/
int ns1__SuperGroupListDataItemType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
  return soap_out_ns1__SuperGroupListDataItemType(soap, tag, id, this, type);
}

/*--------------------[ soap_out_ns1__SuperGroupListDataItemType ]---------*/
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SuperGroupListDataItemType(struct soap *soap, const char *tag, int id, const ns1__SuperGroupListDataItemType *a, const char *type)
{
  (void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SuperGroupListDataItemType), type))
    return soap->error;
  if (soap_out_unsignedInt(soap, "superGroupId", -1, &a->ns1__SuperGroupListDataItemType::superGroupId, ""))
    return soap->error;
  if (soap_out_std__string(soap, "superGroupName", -1, &a->ns1__SuperGroupListDataItemType::superGroupName, ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__GroupListDataItemType(soap, "returnArray", -1, &a->ns1__SuperGroupListDataItemType::returnArray, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

/*--------------------------[ soap_in ]------------------------------------*/
void *ns1__SuperGroupListDataItemType::soap_in(struct soap *soap, const char *tag, const char *type)
{
  return soap_in_ns1__SuperGroupListDataItemType(soap, tag, this, type);
}

/*--------------------[ soap_in_ns1__SuperGroupListDataItemType ]----------*/
SOAP_FMAC3 ns1__SuperGroupListDataItemType * SOAP_FMAC4 soap_in_ns1__SuperGroupListDataItemType(struct soap *soap, const char *tag, ns1__SuperGroupListDataItemType *a, const char *type)
{
  (void)tag; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (ns1__SuperGroupListDataItemType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SuperGroupListDataItemType, sizeof(ns1__SuperGroupListDataItemType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
  if (!a)
    return NULL;
  if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SuperGroupListDataItemType)
  {
    soap_revert(soap);
    *soap->id = '\0';
    return (ns1__SuperGroupListDataItemType *)a->soap_in(soap, tag, type);
  }
  if (soap->alloced)
    a->soap_default(soap);
  size_t soap_flag_superGroupId1 = 1;
  size_t soap_flag_superGroupName1 = 1;
  if (soap->body && *soap->href != '#')
  {
    for (;;)
    {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_superGroupId1 && soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_unsignedInt(soap, "superGroupId", &a->ns1__SuperGroupListDataItemType::superGroupId, "xsd:unsignedInt"))
        {
          soap_flag_superGroupId1--;
          continue;
        }
      }
      if (soap_flag_superGroupName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
      {
        if (soap_in_std__string(soap, "superGroupName", &a->ns1__SuperGroupListDataItemType::superGroupName, "xsd:string"))
        {	soap_flag_superGroupName1--;
        continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_std__vectorTemplateOfPointerTons1__GroupListDataItemType(soap, "returnArray", &a->ns1__SuperGroupListDataItemType::returnArray, "ns1:GroupListDataItemType"))
          continue;
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_superGroupId1 > 0 || soap_flag_superGroupName1 > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }
  }
  else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
  {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  else
  {
    a = (ns1__SuperGroupListDataItemType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SuperGroupListDataItemType, SOAP_TYPE_ns1__SuperGroupListDataItemType, sizeof(ns1__SuperGroupListDataItemType), 0, soap_finsert, soap_fbase);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

/*-----------------[ soap_instantiate_ns1__SuperGroupListDataItemType ]------*/
SOAP_FMAC1 ns1__SuperGroupListDataItemType * SOAP_FMAC2 soap_instantiate_ns1__SuperGroupListDataItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SuperGroupListDataItemType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
  (void)type; (void)arrayType; /* appease -Wall -Werror */
  ns1__SuperGroupListDataItemType *p;
  size_t k = sizeof(ns1__SuperGroupListDataItemType);
  if (n < 0)
  {
    p = SOAP_NEW(ns1__SuperGroupListDataItemType);
    if (p)
      ((ns1__SuperGroupListDataItemType*)p)->soap = soap;
  }
  else
  {
    p = SOAP_NEW_ARRAY(ns1__SuperGroupListDataItemType, n);
    k *= n;
    if (p)
      for (int i = 0; i < n; i++)
        ((ns1__SuperGroupListDataItemType*)p)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SuperGroupListDataItemType location=%p n=%d\n", (void*)p, n));
  soap_link(soap, p, SOAP_TYPE_ns1__SuperGroupListDataItemType, n, soap_fdelete);
  if (size)
    *size = k;
  return p;
}

/*--------------------------[ soap_put ]-----------------------------------*/
int ns1__SuperGroupListDataItemType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
  if (soap_out_ns1__SuperGroupListDataItemType(soap, tag ? tag : "ns1:SuperGroupListDataItemType", -2, this, type))
    return soap->error;
  return soap_putindependent(soap);
}

/*--------------------------[ soap_get ]-----------------------------------*/
void *ns1__SuperGroupListDataItemType::soap_get(struct soap *soap, const char *tag, const char *type)
{
  return soap_get_ns1__SuperGroupListDataItemType(soap, this, tag, type);
}

/*--------------------------[ soap_get_ns1__SuperGroupListDataItemType ]---*/
SOAP_FMAC3 ns1__SuperGroupListDataItemType * SOAP_FMAC4 soap_get_ns1__SuperGroupListDataItemType(struct soap *soap, ns1__SuperGroupListDataItemType *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns1__SuperGroupListDataItemType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

//1-Jun-2021 YR BZ#54502
/*--------------------------[ soap_dealloc ]-------------------------------*/
void ns1__SuperGroupListDataItemType::soap_dealloc()
{
  for(unsigned int i=0; i<returnArray.size(); i++)
  {
    //char address[20];
    //er_sprintf(address, "%p", returnArray[i]);
    //soap_obj_log_d << "ns1__SuperGroupListDataItemType::soap_dealloc - delete " << address << ")" << LOG_TERMINATOR;
    delete []returnArray[i];
  }
  returnArray.clear();
}


//============[ ns1__BriefDNISInfoRequestType::Implemented Methods ]=======
void ns1__BriefDNISInfoRequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BriefDNISInfoRequestType::requestInfoHeader = NULL;
	/* transient soap skipped */
}

void ns1__BriefDNISInfoRequestType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RequestInfoHeaderType(soap, &this->ns1__BriefDNISInfoRequestType::requestInfoHeader);
#endif
}

int ns1__BriefDNISInfoRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__BriefDNISInfoRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BriefDNISInfoRequestType(struct soap *soap, const char *tag, int id, const ns1__BriefDNISInfoRequestType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BriefDNISInfoRequestType), type))
		return soap->error;
	if (!a->ns1__BriefDNISInfoRequestType::requestInfoHeader)
	{	if (soap_element_empty(soap, "requestInfoHeader"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", -1, &a->ns1__BriefDNISInfoRequestType::requestInfoHeader, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__BriefDNISInfoRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__BriefDNISInfoRequestType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__BriefDNISInfoRequestType * SOAP_FMAC4 soap_in_ns1__BriefDNISInfoRequestType(struct soap *soap, const char *tag, ns1__BriefDNISInfoRequestType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__BriefDNISInfoRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BriefDNISInfoRequestType, sizeof(ns1__BriefDNISInfoRequestType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__BriefDNISInfoRequestType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__BriefDNISInfoRequestType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_requestInfoHeader1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", &a->ns1__BriefDNISInfoRequestType::requestInfoHeader, "ns1:RequestInfoHeaderType"))
				{	soap_flag_requestInfoHeader1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__BriefDNISInfoRequestType::requestInfoHeader))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__BriefDNISInfoRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BriefDNISInfoRequestType, SOAP_TYPE_ns1__BriefDNISInfoRequestType, sizeof(ns1__BriefDNISInfoRequestType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__BriefDNISInfoRequestType * SOAP_FMAC2 soap_instantiate_ns1__BriefDNISInfoRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BriefDNISInfoRequestType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__BriefDNISInfoRequestType *p;
	size_t k = sizeof(ns1__BriefDNISInfoRequestType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__BriefDNISInfoRequestType);
		if (p)
			((ns1__BriefDNISInfoRequestType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__BriefDNISInfoRequestType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__BriefDNISInfoRequestType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__BriefDNISInfoRequestType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__BriefDNISInfoRequestType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__BriefDNISInfoRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__BriefDNISInfoRequestType(soap, tag ? tag : "ns1:BriefDNISInfoRequestType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__BriefDNISInfoRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__BriefDNISInfoRequestType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__BriefDNISInfoRequestType * SOAP_FMAC4 soap_get_ns1__BriefDNISInfoRequestType(struct soap *soap, ns1__BriefDNISInfoRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BriefDNISInfoRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}



//============[ ns1__DNISListReturnType::Implemented Methods ]===============
//ctor
ns1__DNISListReturnType::ns1__DNISListReturnType(): responseInfoHeader(), returnArray(), soap()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ctor of ns1__DNISListReturnType(" << address << ")" << LOG_TERMINATOR;
  ////DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__DNISListReturnType(addr:%s)\n", address));
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__DNISListReturnType(addr:%p)\n", (void*)this));
}

//dtor
ns1__DNISListReturnType::~ns1__DNISListReturnType()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "dtor of ns1__DNISListReturnType(" << address << ")" << LOG_TERMINATOR;
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "dtor ns1__DNISListReturnType(addr:%p)\n", (void*)this));
}

/*--------------------------[ soap_default ]-------------------------------*/
void ns1__DNISListReturnType::soap_default(struct soap *soap)
{
  this->soap = soap;
  this->ns1__DNISListReturnType::responseInfoHeader = NULL;
  soap_default_std__vectorTemplateOfPointerTons1__DNISListDataItemType(soap, &this->ns1__DNISListReturnType::returnArray);
  /* transient soap skipped */
}

/*--------------------------[ soap_serialize ]-----------------------------*/
void ns1__DNISListReturnType::soap_serialize(struct soap *soap) const
{
  (void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
  soap_serialize_PointerTons1__ResponseInfoHeaderType(soap, &this->ns1__DNISListReturnType::responseInfoHeader);
  soap_serialize_std__vectorTemplateOfPointerTons1__DNISListDataItemType(soap, &this->ns1__DNISListReturnType::returnArray);
#endif
}

/*--------------------------[ soap_out ]-----------------------------------*/
int ns1__DNISListReturnType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
  return soap_out_ns1__DNISListReturnType(soap, tag, id, this, type);
}

/*--------------------[ soap_out_ns1__DNISListReturnType ]-----------------*/
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DNISListReturnType(struct soap *soap, const char *tag, int id, const ns1__DNISListReturnType *a, const char *type)
{
  (void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DNISListReturnType), type))
    return soap->error;
  if (!a->ns1__DNISListReturnType::responseInfoHeader)
  {
    if (soap_element_empty(soap, "responseInfoHeader"))
      return soap->error;
  }
  else
    if (soap_out_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", -1, &a->ns1__DNISListReturnType::responseInfoHeader, ""))
      return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__DNISListDataItemType(soap, "returnArray", -1, &a->ns1__DNISListReturnType::returnArray, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

/*--------------------------[ soap_in ]------------------------------------*/
void *ns1__DNISListReturnType::soap_in(struct soap *soap, const char *tag, const char *type)
{
  return soap_in_ns1__DNISListReturnType(soap, tag, this, type);
}

/*--------------------[ soap_in_ns1__DNISListReturnType ]------------------*/
SOAP_FMAC3 ns1__DNISListReturnType * SOAP_FMAC4 soap_in_ns1__DNISListReturnType(struct soap *soap, const char *tag, ns1__DNISListReturnType *a, const char *type)
{
  (void)tag; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (ns1__DNISListReturnType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DNISListReturnType, sizeof(ns1__DNISListReturnType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
  if (!a)
    return NULL;
  if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__DNISListReturnType)
  {
    soap_revert(soap);
    *soap->id = '\0';
    return (ns1__DNISListReturnType *)a->soap_in(soap, tag, type);
  }
  if (soap->alloced)
    a->soap_default(soap);
  size_t soap_flag_responseInfoHeader1 = 1;
  if (soap->body && *soap->href != '#')
  {
    for (;;)
    {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_responseInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", &a->ns1__DNISListReturnType::responseInfoHeader, "ns1:ResponseInfoHeaderType"))
        {
          soap_flag_responseInfoHeader1--;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_std__vectorTemplateOfPointerTons1__DNISListDataItemType(soap, "returnArray", &a->ns1__DNISListReturnType::returnArray, "ns1:DNISListDataItemType"))
          continue;
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
    if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__DNISListReturnType::responseInfoHeader || a->ns1__DNISListReturnType::returnArray.size() < 1))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }
  }
  else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
  {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  else
  {
    a = (ns1__DNISListReturnType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DNISListReturnType, SOAP_TYPE_ns1__DNISListReturnType, sizeof(ns1__DNISListReturnType), 0, soap_finsert, soap_fbase);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

/*-----------------[ soap_instantiate_ns1__DNISListReturnType ]------------*/
SOAP_FMAC1 ns1__DNISListReturnType * SOAP_FMAC2 soap_instantiate_ns1__DNISListReturnType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DNISListReturnType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
  (void)type; (void)arrayType; /* appease -Wall -Werror */
  ns1__DNISListReturnType *p;
  size_t k = sizeof(ns1__DNISListReturnType);
  if (n < 0)
  {
    p = SOAP_NEW(ns1__DNISListReturnType);
    if (p)
      ((ns1__DNISListReturnType*)p)->soap = soap;
  }
  else
  {
    p = SOAP_NEW_ARRAY(ns1__DNISListReturnType, n);
    k *= n;
    if (p)
      for (int i = 0; i < n; i++)
        ((ns1__DNISListReturnType*)p)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DNISListReturnType location=%p n=%d\n", (void*)p, n));
  soap_link(soap, p, SOAP_TYPE_ns1__DNISListReturnType, n, soap_fdelete);
  if (size)
    *size = k;
  return p;
}

/*--------------------------[ soap_put ]-----------------------------------*/
int ns1__DNISListReturnType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
  if (soap_out_ns1__DNISListReturnType(soap, tag ? tag : "ns1:DNISListReturnType", -2, this, type))
    return soap->error;
  return soap_putindependent(soap);
}

/*--------------------------[ soap_get ]-----------------------------------*/
void *ns1__DNISListReturnType::soap_get(struct soap *soap, const char *tag, const char *type)
{
  return soap_get_ns1__DNISListReturnType(soap, this, tag, type);
}

/*--------------------------[ soap_get_ns1__DNISListReturnType ]-----------*/
SOAP_FMAC3 ns1__DNISListReturnType * SOAP_FMAC4 soap_get_ns1__DNISListReturnType(struct soap *soap, ns1__DNISListReturnType *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns1__DNISListReturnType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

/*--------------------------[ soap_dealloc ]-------------------------------*/
void ns1__DNISListReturnType::soap_dealloc()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ns1__DNISListReturnType::soap_dealloc(" << address << ")" << LOG_TERMINATOR;
  for(unsigned int i=0; i<returnArray.size(); i++)
  {
    //er_sprintf(address, "%p", returnArray[i]);
    //soap_obj_log_d << "ns1__DNISListReturnType::soap_dealloc - delete " << address << ")" << LOG_TERMINATOR;
    delete []returnArray[i];
  }
  returnArray.clear();
}


//============[ ns1__DNISListDataItemType::Implemented Methods ]=============
//ctor
ns1__DNISListDataItemType::ns1__DNISListDataItemType(): dnisId(), dnisName(), dnisNumber(), dnisType(), soap()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ctor of ns1__DNISListDataItemType(" << address << ")" << LOG_TERMINATOR;
  ////DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__DNISListReturnType(addr:%s)\n", address));
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__DNISListDataItemType(addr:%p)\n", (void*)this));
}

//dtor
ns1__DNISListDataItemType::~ns1__DNISListDataItemType()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "dtor of ns1__DNISListDataItemType(" << address << ")" << LOG_TERMINATOR;
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "dtor ns1__DNISListDataItemType(addr:%p)\n", (void*)this));
}

/*--------------------------[ soap_default ]-------------------------------*/
void ns1__DNISListDataItemType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_unsignedInt(soap, &this->ns1__DNISListDataItemType::dnisId);
	soap_default_std__string(soap, &this->ns1__DNISListDataItemType::dnisName);
	soap_default_std__string(soap, &this->ns1__DNISListDataItemType::dnisNumber);
	soap_default_unsignedInt(soap, &this->ns1__DNISListDataItemType::dnisType);
	/* transient soap skipped */
}

/*--------------------------[ soap_serialize ]-----------------------------*/
void ns1__DNISListDataItemType::soap_serialize(struct soap *soap) const
{
  (void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
  soap_embedded(soap, &this->ns1__DNISListDataItemType::dnisId, SOAP_TYPE_unsignedInt);
  soap_serialize_std__string(soap, &this->ns1__DNISListDataItemType::dnisName);
  soap_serialize_std__string(soap, &this->ns1__DNISListDataItemType::dnisNumber);
  soap_embedded(soap, &this->ns1__DNISListDataItemType::dnisType, SOAP_TYPE_unsignedInt);
#endif
}

/*--------------------------[ soap_out ]-----------------------------------*/
int ns1__DNISListDataItemType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
  return soap_out_ns1__DNISListDataItemType(soap, tag, id, this, type);
}

/*--------------------[ soap_out_ns1__DNISListDataItemType ]---------------*/
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DNISListDataItemType(struct soap *soap, const char *tag, int id, const ns1__DNISListDataItemType *a, const char *type)
{
  (void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DNISListDataItemType), type))
    return soap->error;
  if (soap_out_unsignedInt(soap, "dnisId", -1, &a->ns1__DNISListDataItemType::dnisId, ""))
    return soap->error;
  if (soap_out_std__string(soap, "dnisName", -1, &a->ns1__DNISListDataItemType::dnisName, ""))
    return soap->error;
  if (soap_out_std__string(soap, "dnisNumber", -1, &a->ns1__DNISListDataItemType::dnisNumber, ""))
    return soap->error;
  if (soap_out_unsignedInt(soap, "dnisType", -1, &a->ns1__DNISListDataItemType::dnisType, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

/*--------------------------[ soap_in ]------------------------------------*/
void *ns1__DNISListDataItemType::soap_in(struct soap *soap, const char *tag, const char *type)
{
  return soap_in_ns1__DNISListDataItemType(soap, tag, this, type);
}

/*--------------------[ soap_in_ns1__DNISListDataItemType ]----------------*/
SOAP_FMAC3 ns1__DNISListDataItemType * SOAP_FMAC4 soap_in_ns1__DNISListDataItemType(struct soap *soap, const char *tag, ns1__DNISListDataItemType *a, const char *type)
{
  (void)tag; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (ns1__DNISListDataItemType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DNISListDataItemType, sizeof(ns1__DNISListDataItemType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
  if (!a)
    return NULL;
  if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__DNISListDataItemType)
  {
    soap_revert(soap);
    *soap->id = '\0';
    return (ns1__DNISListDataItemType *)a->soap_in(soap, tag, type);
  }
  if (soap->alloced)
    a->soap_default(soap);
  size_t soap_flag_dnisId1 = 1;
  size_t soap_flag_dnisName1 = 1;
  size_t soap_flag_dnisNumber1 = 1;
  size_t soap_flag_dnisType1 = 1;
  if (soap->body && *soap->href != '#')
  {
    for (;;)
    {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_dnisId1 && soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_unsignedInt(soap, "dnisId", &a->ns1__DNISListDataItemType::dnisId, "xsd:unsignedInt"))
        {
          soap_flag_dnisId1--;
          continue;
        }
      }
      if (soap_flag_dnisName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
      {
        if (soap_in_std__string(soap, "dnisName", &a->ns1__DNISListDataItemType::dnisName, "xsd:string"))
        {
          soap_flag_dnisName1--;
          continue;
        }
      }
      if (soap_flag_dnisNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
      {
        if (soap_in_std__string(soap, "dnisNumber", &a->ns1__DNISListDataItemType::dnisNumber, "xsd:string"))
        {
          soap_flag_dnisNumber1--;
          continue;
        }
      }
      if (soap_flag_dnisType1 && soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_unsignedInt(soap, "dnisType", &a->ns1__DNISListDataItemType::dnisType, "xsd:unsignedInt"))
        {
          soap_flag_dnisType1--;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dnisId1 > 0 || soap_flag_dnisName1 > 0 || soap_flag_dnisNumber1 > 0 || soap_flag_dnisType1 > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }
  }
  else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
  {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  else
  {
    a = (ns1__DNISListDataItemType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DNISListDataItemType, SOAP_TYPE_ns1__DNISListDataItemType, sizeof(ns1__DNISListDataItemType), 0, soap_finsert, soap_fbase);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}


/*-----------------[ soap_instantiate_ns1__DNISListDataItemType ]----------*/
SOAP_FMAC1 ns1__DNISListDataItemType * SOAP_FMAC2 soap_instantiate_ns1__DNISListDataItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DNISListDataItemType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
  (void)type; (void)arrayType; /* appease -Wall -Werror */
  ns1__DNISListDataItemType *p;
  size_t k = sizeof(ns1__DNISListDataItemType);
  if (n < 0)
  {
    p = SOAP_NEW(ns1__DNISListDataItemType);
    if (p)
      ((ns1__DNISListDataItemType*)p)->soap = soap;
  }
  else
  {
    p = SOAP_NEW_ARRAY(ns1__DNISListDataItemType, n);
    k *= n;
    if (p)
      for (int i = 0; i < n; i++)
        ((ns1__DNISListDataItemType*)p)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DNISListDataItemType location=%p n=%d\n", (void*)p, n));
  soap_link(soap, p, SOAP_TYPE_ns1__DNISListDataItemType, n, soap_fdelete);
  if (size)
    *size = k;
  return p;
}

/*--------------------------[ soap_put ]-----------------------------------*/
int ns1__DNISListDataItemType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
  if (soap_out_ns1__DNISListDataItemType(soap, tag ? tag : "ns1:DNISListDataItemType", -2, this, type))
    return soap->error;
  return soap_putindependent(soap);
}

/*--------------------------[ soap_get ]-----------------------------------*/
void *ns1__DNISListDataItemType::soap_get(struct soap *soap, const char *tag, const char *type)
{
  return soap_get_ns1__DNISListDataItemType(soap, this, tag, type);
}

/*--------------------------[ soap_get_ns1__DNISListDataItemType ]---------*/
SOAP_FMAC3 ns1__DNISListDataItemType * SOAP_FMAC4 soap_get_ns1__DNISListDataItemType(struct soap *soap, ns1__DNISListDataItemType *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns1__DNISListDataItemType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}


//============[ ns1__ReportListDataReturnType::Implemented Methods ]=========
//ctor
ns1__ReportListDataReturnType::ns1__ReportListDataReturnType(): responseInfoHeader(), returnArray(), soap()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ctor of ns1__ReportListDataReturnType(" << address << ")" << LOG_TERMINATOR;
  ////DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__ReportListDataReturnType(addr:%s)\n", address));
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__ReportListDataReturnType(addr:%p)\n", (void*)this));
}

//dtor
ns1__ReportListDataReturnType::~ns1__ReportListDataReturnType()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "dtor of ns1__ReportListDataReturnType(" << address << ")" << LOG_TERMINATOR;
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "dtor ns1__ReportListDataReturnType(addr:%p)\n", (void*)this));
}

/*--------------------------[ soap_default ]-------------------------------*/
void ns1__ReportListDataReturnType::soap_default(struct soap *soap)
{
  this->soap = soap;
  this->ns1__ReportListDataReturnType::responseInfoHeader = NULL;
  soap_default_std__vectorTemplateOfPointerTons1__ReportListDataItemType(soap, &this->ns1__ReportListDataReturnType::returnArray);
  /* transient soap skipped */
}

/*--------------------------[ soap_serialize ]-----------------------------*/
void ns1__ReportListDataReturnType::soap_serialize(struct soap *soap) const
{
  (void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
  soap_serialize_PointerTons1__ResponseInfoHeaderType(soap, &this->ns1__ReportListDataReturnType::responseInfoHeader);
  soap_serialize_std__vectorTemplateOfPointerTons1__ReportListDataItemType(soap, &this->ns1__ReportListDataReturnType::returnArray);
#endif
}

/*--------------------------[ soap_out ]-----------------------------------*/
int ns1__ReportListDataReturnType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
  return soap_out_ns1__ReportListDataReturnType(soap, tag, id, this, type);
}

/*--------------------[ soap_out_ns1__ReportListDataReturnType ]-----------*/
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ReportListDataReturnType(struct soap *soap, const char *tag, int id, const ns1__ReportListDataReturnType *a, const char *type)
{
  (void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ReportListDataReturnType), type))
    return soap->error;
  if (!a->ns1__ReportListDataReturnType::responseInfoHeader)
  {
    if (soap_element_empty(soap, "responseInfoHeader"))
      return soap->error;
  }
  else
    if (soap_out_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", -1, &a->ns1__ReportListDataReturnType::responseInfoHeader, ""))
      return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__ReportListDataItemType(soap, "returnArray", -1, &a->ns1__ReportListDataReturnType::returnArray, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

/*--------------------------[ soap_in ]------------------------------------*/
void *ns1__ReportListDataReturnType::soap_in(struct soap *soap, const char *tag, const char *type)
{
  return soap_in_ns1__ReportListDataReturnType(soap, tag, this, type);
}

/*--------------------[ soap_in_ns1__ReportListDataReturnType ]------------*/
SOAP_FMAC3 ns1__ReportListDataReturnType * SOAP_FMAC4 soap_in_ns1__ReportListDataReturnType(struct soap *soap, const char *tag, ns1__ReportListDataReturnType *a, const char *type)
{
  (void)tag; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (ns1__ReportListDataReturnType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ReportListDataReturnType, sizeof(ns1__ReportListDataReturnType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
  if (!a)
    return NULL;
  if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ReportListDataReturnType)
  {
    soap_revert(soap);
    *soap->id = '\0';
    return (ns1__ReportListDataReturnType *)a->soap_in(soap, tag, type);
  }
  if (soap->alloced)
    a->soap_default(soap);
  size_t soap_flag_responseInfoHeader1 = 1;
  if (soap->body && *soap->href != '#')
  {
    for (;;)
    {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_responseInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", &a->ns1__ReportListDataReturnType::responseInfoHeader, "ns1:ResponseInfoHeaderType"))
        {
          soap_flag_responseInfoHeader1--;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_std__vectorTemplateOfPointerTons1__ReportListDataItemType(soap, "returnArray", &a->ns1__ReportListDataReturnType::returnArray, "ns1:ReportListDataItemType"))
          continue;
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
    if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__ReportListDataReturnType::responseInfoHeader))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }
  }
  else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
  {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  else
  {
    a = (ns1__ReportListDataReturnType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ReportListDataReturnType, SOAP_TYPE_ns1__ReportListDataReturnType, sizeof(ns1__ReportListDataReturnType), 0, soap_finsert, soap_fbase);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

/*-----------------[ soap_instantiate_ns1__ReportListDataReturnType ]------*/
SOAP_FMAC1 ns1__ReportListDataReturnType * SOAP_FMAC2 soap_instantiate_ns1__ReportListDataReturnType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ReportListDataReturnType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
  (void)type; (void)arrayType; /* appease -Wall -Werror */
  ns1__ReportListDataReturnType *p;
  size_t k = sizeof(ns1__ReportListDataReturnType);
  if (n < 0)
  {
    p = SOAP_NEW(ns1__ReportListDataReturnType);
    if (p)
      ((ns1__ReportListDataReturnType*)p)->soap = soap;
  }
  else
  {
    p = SOAP_NEW_ARRAY(ns1__ReportListDataReturnType, n);
    k *= n;
    if (p)
      for (int i = 0; i < n; i++)
        ((ns1__ReportListDataReturnType*)p)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ReportListDataReturnType location=%p n=%d\n", (void*)p, n));
  soap_link(soap, p, SOAP_TYPE_ns1__ReportListDataReturnType, n, soap_fdelete);
  if (size)
    *size = k;
  return p;
}

/*--------------------------[ soap_put ]-----------------------------------*/
int ns1__ReportListDataReturnType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
  if (soap_out_ns1__ReportListDataReturnType(soap, tag ? tag : "ns1:ReportListDataReturnType", -2, this, type))
    return soap->error;
  return soap_putindependent(soap);
}

/*--------------------------[ soap_get ]-----------------------------------*/
void *ns1__ReportListDataReturnType::soap_get(struct soap *soap, const char *tag, const char *type)
{
  return soap_get_ns1__ReportListDataReturnType(soap, this, tag, type);
}

/*--------------------------[ soap_get_ns1__ReportListDataReturnType ]-----*/
SOAP_FMAC3 ns1__ReportListDataReturnType * SOAP_FMAC4 soap_get_ns1__ReportListDataReturnType(struct soap *soap, ns1__ReportListDataReturnType *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns1__ReportListDataReturnType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

/*--------------------------[ soap_dealloc ]-------------------------------*/
void ns1__ReportListDataReturnType::soap_dealloc()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ns1__ReportListDataReturnType::soap_dealloc(" << address << ")" << LOG_TERMINATOR;
  for(unsigned int i=0; i<returnArray.size(); i++)
  {
    //er_sprintf(address, "%p", returnArray[i]);
    //soap_obj_log_d << "ns1__ReportListDataReturnType::soap_dealloc - delete " << address << ")" << LOG_TERMINATOR;
    delete []returnArray[i];
  }
  returnArray.clear();
}


//============[ ns1__ReportListDataItemType::Implemented Methods ]=========
//ctor
ns1__ReportListDataItemType::ns1__ReportListDataItemType(): reportId(), isPublic(), reportName(), renderName(), params(), soap()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ctor of ns1__ReportListDataItemType(" << address << ")" << LOG_TERMINATOR;
  ////DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__ReportListDataItemType(addr:%s)\n", address));
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__ReportListDataItemType(addr:%p)\n", (void*)this));
}

//dtor
ns1__ReportListDataItemType::~ns1__ReportListDataItemType()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "dtor of ns1__ReportListDataItemType(" << address << ")" << LOG_TERMINATOR;
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "dtor ns1__ReportListDataItemType(addr:%p)\n", (void*)this));
}


void ns1__ReportListDataItemType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_unsignedInt(soap, &this->ns1__ReportListDataItemType::reportId);
	soap_default_unsignedInt(soap, &this->ns1__ReportListDataItemType::isPublic);
	soap_default_std__string(soap, &this->ns1__ReportListDataItemType::reportName);
	soap_default_std__string(soap, &this->ns1__ReportListDataItemType::renderName);
	soap_default_std__string(soap, &this->ns1__ReportListDataItemType::params);
	/* transient soap skipped */
}

void ns1__ReportListDataItemType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__ReportListDataItemType::reportId, SOAP_TYPE_unsignedInt);
	soap_embedded(soap, &this->ns1__ReportListDataItemType::isPublic, SOAP_TYPE_unsignedInt);
	soap_serialize_std__string(soap, &this->ns1__ReportListDataItemType::reportName);
	soap_serialize_std__string(soap, &this->ns1__ReportListDataItemType::renderName);
	soap_serialize_std__string(soap, &this->ns1__ReportListDataItemType::params);
#endif
}

int ns1__ReportListDataItemType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ReportListDataItemType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ReportListDataItemType(struct soap *soap, const char *tag, int id, const ns1__ReportListDataItemType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ReportListDataItemType), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "reportId", -1, &a->ns1__ReportListDataItemType::reportId, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "isPublic", -1, &a->ns1__ReportListDataItemType::isPublic, ""))
		return soap->error;
	if (soap_out_std__string(soap, "reportName", -1, &a->ns1__ReportListDataItemType::reportName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "renderName", -1, &a->ns1__ReportListDataItemType::renderName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "params", -1, &a->ns1__ReportListDataItemType::params, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ReportListDataItemType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ReportListDataItemType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ReportListDataItemType * SOAP_FMAC4 soap_in_ns1__ReportListDataItemType(struct soap *soap, const char *tag, ns1__ReportListDataItemType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ReportListDataItemType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ReportListDataItemType, sizeof(ns1__ReportListDataItemType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ReportListDataItemType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ReportListDataItemType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reportId1 = 1;
	size_t soap_flag_isPublic1 = 1;
	size_t soap_flag_reportName1 = 1;
	size_t soap_flag_renderName1 = 1;
	size_t soap_flag_params1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reportId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "reportId", &a->ns1__ReportListDataItemType::reportId, "xsd:unsignedInt"))
				{	soap_flag_reportId1--;
					continue;
				}
			}
			if (soap_flag_isPublic1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "isPublic", &a->ns1__ReportListDataItemType::isPublic, "xsd:unsignedInt"))
				{	soap_flag_isPublic1--;
					continue;
				}
			}
			if (soap_flag_reportName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "reportName", &a->ns1__ReportListDataItemType::reportName, "xsd:string"))
				{	soap_flag_reportName1--;
					continue;
				}
			}
			if (soap_flag_renderName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "renderName", &a->ns1__ReportListDataItemType::renderName, "xsd:string"))
				{	soap_flag_renderName1--;
					continue;
				}
			}
			if (soap_flag_params1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "params", &a->ns1__ReportListDataItemType::params, "xsd:string"))
				{	soap_flag_params1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reportId1 > 0 || soap_flag_isPublic1 > 0 || soap_flag_reportName1 > 0 || soap_flag_renderName1 > 0 || soap_flag_params1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ReportListDataItemType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ReportListDataItemType, SOAP_TYPE_ns1__ReportListDataItemType, sizeof(ns1__ReportListDataItemType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ReportListDataItemType * SOAP_FMAC2 soap_instantiate_ns1__ReportListDataItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ReportListDataItemType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ReportListDataItemType *p;
	size_t k = sizeof(ns1__ReportListDataItemType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ReportListDataItemType);
		if (p)
			((ns1__ReportListDataItemType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ReportListDataItemType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ReportListDataItemType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ReportListDataItemType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__ReportListDataItemType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ReportListDataItemType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ReportListDataItemType(soap, tag ? tag : "ns1:ReportListDataItemType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ReportListDataItemType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ReportListDataItemType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ReportListDataItemType * SOAP_FMAC4 soap_get_ns1__ReportListDataItemType(struct soap *soap, ns1__ReportListDataItemType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ReportListDataItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ReportListDataRequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ReportListDataRequestType::requestInfoHeader = NULL;
	/* transient soap skipped */
}

void ns1__ReportListDataRequestType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RequestInfoHeaderType(soap, &this->ns1__ReportListDataRequestType::requestInfoHeader);
#endif
}

int ns1__ReportListDataRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ReportListDataRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ReportListDataRequestType(struct soap *soap, const char *tag, int id, const ns1__ReportListDataRequestType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ReportListDataRequestType), type))
		return soap->error;
	if (!a->ns1__ReportListDataRequestType::requestInfoHeader)
	{	if (soap_element_empty(soap, "requestInfoHeader"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", -1, &a->ns1__ReportListDataRequestType::requestInfoHeader, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ReportListDataRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ReportListDataRequestType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ReportListDataRequestType * SOAP_FMAC4 soap_in_ns1__ReportListDataRequestType(struct soap *soap, const char *tag, ns1__ReportListDataRequestType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ReportListDataRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ReportListDataRequestType, sizeof(ns1__ReportListDataRequestType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ReportListDataRequestType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ReportListDataRequestType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_requestInfoHeader1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", &a->ns1__ReportListDataRequestType::requestInfoHeader, "ns1:RequestInfoHeaderType"))
				{	soap_flag_requestInfoHeader1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__ReportListDataRequestType::requestInfoHeader))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ReportListDataRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ReportListDataRequestType, SOAP_TYPE_ns1__ReportListDataRequestType, sizeof(ns1__ReportListDataRequestType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ReportListDataRequestType * SOAP_FMAC2 soap_instantiate_ns1__ReportListDataRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ReportListDataRequestType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ReportListDataRequestType *p;
	size_t k = sizeof(ns1__ReportListDataRequestType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ReportListDataRequestType);
		if (p)
			((ns1__ReportListDataRequestType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ReportListDataRequestType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ReportListDataRequestType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ReportListDataRequestType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__ReportListDataRequestType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ReportListDataRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ReportListDataRequestType(soap, tag ? tag : "ns1:ReportListDataRequestType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ReportListDataRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ReportListDataRequestType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ReportListDataRequestType * SOAP_FMAC4 soap_get_ns1__ReportListDataRequestType(struct soap *soap, ns1__ReportListDataRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ReportListDataRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}



//============[ ns1__DefaultWorkspaceReturnType::Implemented Methods ]=======
//ctor
ns1__DefaultWorkspaceReturnType::ns1__DefaultWorkspaceReturnType(): responseInfoHeader(), returnArray(), soap()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ctor of ns1__DefaultWorkspaceReturnType(" << address << ")" << LOG_TERMINATOR;
  ////DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__ReturnArrayDataType(addr:%s)\n", address));
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__DefaultWorkspaceReturnType(addr:%p)\n", (void*)this));
}

//dtor
ns1__DefaultWorkspaceReturnType::~ns1__DefaultWorkspaceReturnType()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "dtor of ns1__DefaultWorkspaceReturnType(" << address << ")" << LOG_TERMINATOR;
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "dtor ns1__DefaultWorkspaceReturnType(addr:%p)\n", (void*)this));
}

/*--------------------------[ soap_default ]-------------------------------*/
void ns1__DefaultWorkspaceReturnType::soap_default(struct soap *soap)
{
  this->soap = soap;
  this->ns1__DefaultWorkspaceReturnType::responseInfoHeader = NULL;
  soap_default_std__vectorTemplateOfPointerTons1__DefaultWorkspaceItemType(soap, &this->ns1__DefaultWorkspaceReturnType::returnArray);
  soap_default_std__string(soap, &this->ns1__DefaultWorkspaceReturnType::fontSize);
  soap_default_std__string(soap, &this->ns1__DefaultWorkspaceReturnType::language);
  /* transient soap skipped */
}

/*--------------------------[ soap_serialize ]-----------------------------*/
void ns1__DefaultWorkspaceReturnType::soap_serialize(struct soap *soap) const
{
  (void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
  soap_serialize_PointerTons1__ResponseInfoHeaderType(soap, &this->ns1__DefaultWorkspaceReturnType::responseInfoHeader);
  soap_serialize_std__vectorTemplateOfPointerTons1__DefaultWorkspaceItemType(soap, &this->ns1__DefaultWorkspaceReturnType::returnArray);
  soap_serialize_std__string(soap, &this->ns1__DefaultWorkspaceReturnType::fontSize);
  soap_serialize_std__string(soap, &this->ns1__DefaultWorkspaceReturnType::language);
#endif
}

/*--------------------------[ soap_out ]-----------------------------------*/
int ns1__DefaultWorkspaceReturnType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
  return soap_out_ns1__DefaultWorkspaceReturnType(soap, tag, id, this, type);
}

/*--------------------[ soap_out_ns1__DefaultWorkspaceReturnType ]---------*/
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DefaultWorkspaceReturnType(struct soap *soap, const char *tag, int id, const ns1__DefaultWorkspaceReturnType *a, const char *type)
{
  (void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DefaultWorkspaceReturnType), type))
    return soap->error;
  if (!a->ns1__DefaultWorkspaceReturnType::responseInfoHeader)
  {
    if (soap_element_empty(soap, "responseInfoHeader"))
      return soap->error;
  }
  else
    if (soap_out_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", -1, &a->ns1__DefaultWorkspaceReturnType::responseInfoHeader, ""))
      return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__DefaultWorkspaceItemType(soap, "returnArray", -1, &a->ns1__DefaultWorkspaceReturnType::returnArray, ""))
    return soap->error;
  if (soap_out_std__string(soap, "fontSize", -1, &a->ns1__DefaultWorkspaceReturnType::fontSize, ""))
    return soap->error;
  if (soap_out_std__string(soap, "language", -1, &a->ns1__DefaultWorkspaceReturnType::language, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

/*--------------------------[ soap_in ]------------------------------------*/
void *ns1__DefaultWorkspaceReturnType::soap_in(struct soap *soap, const char *tag, const char *type)
{
  return soap_in_ns1__DefaultWorkspaceReturnType(soap, tag, this, type);
}

/*--------------------[ soap_in_ns1__DefaultWorkspaceReturnType ]----------*/
SOAP_FMAC3 ns1__DefaultWorkspaceReturnType * SOAP_FMAC4 soap_in_ns1__DefaultWorkspaceReturnType(struct soap *soap, const char *tag, ns1__DefaultWorkspaceReturnType *a, const char *type)
{
  (void)tag; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (ns1__DefaultWorkspaceReturnType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DefaultWorkspaceReturnType, sizeof(ns1__DefaultWorkspaceReturnType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
  if (!a)
    return NULL;
  if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__DefaultWorkspaceReturnType)
  {
    soap_revert(soap);
    *soap->id = '\0';
    return (ns1__DefaultWorkspaceReturnType *)a->soap_in(soap, tag, type);
  }
  if (soap->alloced)
    a->soap_default(soap);
  size_t soap_flag_responseInfoHeader1 = 1;
  size_t soap_flag_fontSize1 = 1;
  size_t soap_flag_language1 = 1;
  if (soap->body && *soap->href != '#')
  {
    for (;;)
    {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_responseInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", &a->ns1__DefaultWorkspaceReturnType::responseInfoHeader, "ns1:ResponseInfoHeaderType"))
        {
          soap_flag_responseInfoHeader1--;
        continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_std__vectorTemplateOfPointerTons1__DefaultWorkspaceItemType(soap, "returnArray", &a->ns1__DefaultWorkspaceReturnType::returnArray, "ns1:DefaultWorkspaceItemType"))
          continue;
      }
      if (soap_flag_fontSize1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
      {
        if (soap_in_std__string(soap, "fontSize", &a->ns1__DefaultWorkspaceReturnType::fontSize, "xsd:string"))
        {
          soap_flag_fontSize1--;
          continue;
        }
      }
      if (soap_flag_language1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
      {
        if (soap_in_std__string(soap, "language", &a->ns1__DefaultWorkspaceReturnType::language, "xsd:string"))
        {
          soap_flag_language1--;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
    if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__DefaultWorkspaceReturnType::responseInfoHeader || soap_flag_fontSize1 > 0 || soap_flag_language1 > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }
  }
  else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
  {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  else
  {
    a = (ns1__DefaultWorkspaceReturnType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DefaultWorkspaceReturnType, SOAP_TYPE_ns1__DefaultWorkspaceReturnType, sizeof(ns1__DefaultWorkspaceReturnType), 0, soap_finsert, soap_fbase);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

/*-----------------[ soap_instantiate_ns1__DefaultWorkspaceReturnType ]----*/
SOAP_FMAC1 ns1__DefaultWorkspaceReturnType * SOAP_FMAC2 soap_instantiate_ns1__DefaultWorkspaceReturnType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DefaultWorkspaceReturnType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
  (void)type; (void)arrayType; /* appease -Wall -Werror */
  ns1__DefaultWorkspaceReturnType *p;
  size_t k = sizeof(ns1__DefaultWorkspaceReturnType);
  if (n < 0)
  {
    p = SOAP_NEW(ns1__DefaultWorkspaceReturnType);
    if (p)
      ((ns1__DefaultWorkspaceReturnType*)p)->soap = soap;
  }
  else
  {
    p = SOAP_NEW_ARRAY(ns1__DefaultWorkspaceReturnType, n);
    k *= n;
    if (p)
      for (int i = 0; i < n; i++)
        ((ns1__DefaultWorkspaceReturnType*)p)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DefaultWorkspaceReturnType location=%p n=%d\n", (void*)p, n));
  soap_link(soap, p, SOAP_TYPE_ns1__DefaultWorkspaceReturnType, n, soap_fdelete);
  if (size)
    *size = k;
  return p;
}

/*--------------------------[ soap_put ]-----------------------------------*/
int ns1__DefaultWorkspaceReturnType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
  if (soap_out_ns1__DefaultWorkspaceReturnType(soap, tag ? tag : "ns1:DefaultWorkspaceReturnType", -2, this, type))
    return soap->error;
  return soap_putindependent(soap);
}

/*--------------------------[ soap_get ]-----------------------------------*/
void *ns1__DefaultWorkspaceReturnType::soap_get(struct soap *soap, const char *tag, const char *type)
{
  return soap_get_ns1__DefaultWorkspaceReturnType(soap, this, tag, type);
}

/*--------------------------[ soap_get_ns1__DefaultWorkspaceReturnType ]---*/
SOAP_FMAC3 ns1__DefaultWorkspaceReturnType * SOAP_FMAC4 soap_get_ns1__DefaultWorkspaceReturnType(struct soap *soap, ns1__DefaultWorkspaceReturnType *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns1__DefaultWorkspaceReturnType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

/*--------------------------[ soap_dealloc ]-------------------------------*/
void ns1__DefaultWorkspaceReturnType::soap_dealloc()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ns1__DefaultWorkspaceReturnType::soap_dealloc(" << address << ")" << LOG_TERMINATOR;
  for(unsigned int i=0; i<returnArray.size(); i++)
  {
    //er_sprintf(address, "%p", returnArray[i]);
    //soap_obj_log_d << "ns1__DefaultWorkspaceReturnType::soap_dealloc - delete " << address << ")" << LOG_TERMINATOR;
    delete []returnArray[i];
  }
  returnArray.clear();
}



//============[ ns1__DefaultWorkspaceItemType::Implemented Methods ]=========
//ctor
ns1__DefaultWorkspaceItemType::ns1__DefaultWorkspaceItemType(): reportId(), x(), y(), width(), height(), soap()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ctor of ns1__DefaultWorkspaceItemType(" << address << ")" << LOG_TERMINATOR;
  ////DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__ReturnArrayDataType(addr:%s)\n", address));
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__DefaultWorkspaceItemType(addr:%p)\n", (void*)this));
}

//dtor
ns1__DefaultWorkspaceItemType::~ns1__DefaultWorkspaceItemType()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "dtor of ns1__DefaultWorkspaceItemType(" << address << ")" << LOG_TERMINATOR;
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "dtor ns1__DefaultWorkspaceItemType(addr:%p)\n", (void*)this));
}

/*--------------------------[ soap_default ]-------------------------------*/
void ns1__DefaultWorkspaceItemType::soap_default(struct soap *soap)
{
  this->soap = soap;
  soap_default_unsignedInt(soap, &this->ns1__DefaultWorkspaceItemType::reportId);
  soap_default_short(soap, &this->ns1__DefaultWorkspaceItemType::x);
  soap_default_short(soap, &this->ns1__DefaultWorkspaceItemType::y);
  soap_default_unsignedInt(soap, &this->ns1__DefaultWorkspaceItemType::width);
  soap_default_unsignedInt(soap, &this->ns1__DefaultWorkspaceItemType::height);
  /* transient soap skipped */
}

/*--------------------------[ soap_serialize ]-----------------------------*/
void ns1__DefaultWorkspaceItemType::soap_serialize(struct soap *soap) const
{
  (void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
  soap_embedded(soap, &this->ns1__DefaultWorkspaceItemType::reportId, SOAP_TYPE_unsignedInt);
  soap_embedded(soap, &this->ns1__DefaultWorkspaceItemType::width, SOAP_TYPE_unsignedInt);
  soap_embedded(soap, &this->ns1__DefaultWorkspaceItemType::height, SOAP_TYPE_unsignedInt);
#endif
}

/*--------------------------[ soap_out ]-----------------------------------*/
int ns1__DefaultWorkspaceItemType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
  return soap_out_ns1__DefaultWorkspaceItemType(soap, tag, id, this, type);
}

/*--------------------[ soap_out_ns1__DefaultWorkspaceItemType ]-----------*/
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DefaultWorkspaceItemType(struct soap *soap, const char *tag, int id, const ns1__DefaultWorkspaceItemType *a, const char *type)
{
  (void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DefaultWorkspaceItemType), type))
    return soap->error;
  if (soap_out_unsignedInt(soap, "reportId", -1, &a->ns1__DefaultWorkspaceItemType::reportId, ""))
    return soap->error;
  if (soap_out_short(soap, "x", -1, &a->ns1__DefaultWorkspaceItemType::x, ""))
    return soap->error;
  if (soap_out_short(soap, "y", -1, &a->ns1__DefaultWorkspaceItemType::y, ""))
    return soap->error;
  if (soap_out_unsignedInt(soap, "width", -1, &a->ns1__DefaultWorkspaceItemType::width, ""))
    return soap->error;
  if (soap_out_unsignedInt(soap, "height", -1, &a->ns1__DefaultWorkspaceItemType::height, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

/*--------------------------[ soap_in ]------------------------------------*/
void *ns1__DefaultWorkspaceItemType::soap_in(struct soap *soap, const char *tag, const char *type)
{
  return soap_in_ns1__DefaultWorkspaceItemType(soap, tag, this, type);
}

/*--------------------[ soap_in_ns1__DefaultWorkspaceItemType ]------------*/
SOAP_FMAC3 ns1__DefaultWorkspaceItemType * SOAP_FMAC4 soap_in_ns1__DefaultWorkspaceItemType(struct soap *soap, const char *tag, ns1__DefaultWorkspaceItemType *a, const char *type)
{
  (void)tag; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (ns1__DefaultWorkspaceItemType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DefaultWorkspaceItemType, sizeof(ns1__DefaultWorkspaceItemType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
  if (!a)
    return NULL;
  if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__DefaultWorkspaceItemType)
  {
    soap_revert(soap);
    *soap->id = '\0';
    return (ns1__DefaultWorkspaceItemType *)a->soap_in(soap, tag, type);
  }
  if (soap->alloced)
    a->soap_default(soap);
  size_t soap_flag_reportId1 = 1;
  size_t soap_flag_x1 = 1;
  size_t soap_flag_y1 = 1;
  size_t soap_flag_width1 = 1;
  size_t soap_flag_height1 = 1;
  if (soap->body && *soap->href != '#')
  {
    for (;;)
    {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_reportId1 && soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_unsignedInt(soap, "reportId", &a->ns1__DefaultWorkspaceItemType::reportId, "xsd:unsignedInt"))
        {
          soap_flag_reportId1--;
          continue;
        }
      }
      if (soap_flag_x1 && soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_short(soap, "x", &a->ns1__DefaultWorkspaceItemType::x, "xsd:short"))
        {
          soap_flag_x1--;
          continue;
        }
      }
      if (soap_flag_y1 && soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_short(soap, "y", &a->ns1__DefaultWorkspaceItemType::y, "xsd:short"))
        {
          soap_flag_y1--;
          continue;
        }
      }
      if (soap_flag_width1 && soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_unsignedInt(soap, "width", &a->ns1__DefaultWorkspaceItemType::width, "xsd:unsignedInt"))
        {
          soap_flag_width1--;
          continue;
        }
      }
      if (soap_flag_height1 && soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_unsignedInt(soap, "height", &a->ns1__DefaultWorkspaceItemType::height, "xsd:unsignedInt"))
        {
          soap_flag_height1--;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reportId1 > 0 || soap_flag_x1 > 0 || soap_flag_y1 > 0 || soap_flag_width1 > 0 || soap_flag_height1 > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }
  }
  else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
  {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  else
  {
    a = (ns1__DefaultWorkspaceItemType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DefaultWorkspaceItemType, SOAP_TYPE_ns1__DefaultWorkspaceItemType, sizeof(ns1__DefaultWorkspaceItemType), 0, soap_finsert, soap_fbase);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

/*-----------------[ soap_instantiate_ns1__DefaultWorkspaceItemType ]------*/
SOAP_FMAC1 ns1__DefaultWorkspaceItemType * SOAP_FMAC2 soap_instantiate_ns1__DefaultWorkspaceItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DefaultWorkspaceItemType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
  (void)type; (void)arrayType; /* appease -Wall -Werror */
  ns1__DefaultWorkspaceItemType *p;
  size_t k = sizeof(ns1__DefaultWorkspaceItemType);
  if (n < 0)
  {
    p = SOAP_NEW(ns1__DefaultWorkspaceItemType);
    if (p)
      ((ns1__DefaultWorkspaceItemType*)p)->soap = soap;
  }
  else
  {
    p = SOAP_NEW_ARRAY(ns1__DefaultWorkspaceItemType, n);
    k *= n;
    if (p)
      for (int i = 0; i < n; i++)
        ((ns1__DefaultWorkspaceItemType*)p)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DefaultWorkspaceItemType location=%p n=%d\n", (void*)p, n));
  soap_link(soap, p, SOAP_TYPE_ns1__DefaultWorkspaceItemType, n, soap_fdelete);
  if (size)
    *size = k;
  return p;
}

/*--------------------------[ soap_put ]-----------------------------------*/
int ns1__DefaultWorkspaceItemType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
  if (soap_out_ns1__DefaultWorkspaceItemType(soap, tag ? tag : "ns1:DefaultWorkspaceItemType", -2, this, type))
    return soap->error;
  return soap_putindependent(soap);
}

/*--------------------------[ soap_get ]-----------------------------------*/
void *ns1__DefaultWorkspaceItemType::soap_get(struct soap *soap, const char *tag, const char *type)
{
  return soap_get_ns1__DefaultWorkspaceItemType(soap, this, tag, type);
}

/*--------------------------[ soap_get_ns1__DefaultWorkspaceItemType ]-----*/
SOAP_FMAC3 ns1__DefaultWorkspaceItemType * SOAP_FMAC4 soap_get_ns1__DefaultWorkspaceItemType(struct soap *soap, ns1__DefaultWorkspaceItemType *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns1__DefaultWorkspaceItemType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}


//============[ ns1__DefaultWorkspaceRequestType::Implemented Methods ]======
/*--------------------------[ soap_default ]-------------------------------*/
void ns1__DefaultWorkspaceRequestType::soap_default(struct soap *soap)
{
  this->soap = soap;
  this->ns1__DefaultWorkspaceRequestType::requestInfoHeader = NULL;
  /* transient soap skipped */
}

/*--------------------------[ soap_serialize ]-----------------------------*/
void ns1__DefaultWorkspaceRequestType::soap_serialize(struct soap *soap) const
{
  (void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
  soap_serialize_PointerTons1__RequestInfoHeaderType(soap, &this->ns1__DefaultWorkspaceRequestType::requestInfoHeader);
#endif
}

/*--------------------------[ soap_out ]-----------------------------------*/
int ns1__DefaultWorkspaceRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
  return soap_out_ns1__DefaultWorkspaceRequestType(soap, tag, id, this, type);
}

/*--------------------[ soap_out_ns1__SaveWorkspaseRequestType ]-----------*/
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DefaultWorkspaceRequestType(struct soap *soap, const char *tag, int id, const ns1__DefaultWorkspaceRequestType *a, const char *type)
{
  (void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DefaultWorkspaceRequestType), type))
    return soap->error;
  if (!a->ns1__DefaultWorkspaceRequestType::requestInfoHeader)
  {
    if (soap_element_empty(soap, "requestInfoHeader"))
      return soap->error;
  }
  else
    if (soap_out_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", -1, &a->ns1__DefaultWorkspaceRequestType::requestInfoHeader, ""))
      return soap->error;
  return soap_element_end_out(soap, tag);
}

/*--------------------------[ soap_in ]------------------------------------*/
void *ns1__DefaultWorkspaceRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{
  return soap_in_ns1__DefaultWorkspaceRequestType(soap, tag, this, type);
}

/*--------------------------[ soap_in_ns1__DefaultWorkspaceRequestType ]---*/
SOAP_FMAC3 ns1__DefaultWorkspaceRequestType * SOAP_FMAC4 soap_in_ns1__DefaultWorkspaceRequestType(struct soap *soap, const char *tag, ns1__DefaultWorkspaceRequestType *a, const char *type)
{
  (void)tag; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (ns1__DefaultWorkspaceRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DefaultWorkspaceRequestType, sizeof(ns1__DefaultWorkspaceRequestType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
  if (!a)
    return NULL;
  if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__DefaultWorkspaceRequestType)
  {
    soap_revert(soap);
    *soap->id = '\0';
    return (ns1__DefaultWorkspaceRequestType *)a->soap_in(soap, tag, type);
  }
  if (soap->alloced)
    a->soap_default(soap);
  size_t soap_flag_requestInfoHeader1 = 1;
  if (soap->body && *soap->href != '#')
  {
    for (;;)
    {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_requestInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", &a->ns1__DefaultWorkspaceRequestType::requestInfoHeader, "ns1:RequestInfoHeaderType"))
        {
          soap_flag_requestInfoHeader1--;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
    if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__DefaultWorkspaceRequestType::requestInfoHeader))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }
  }
  else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
  {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  else
  {
    a = (ns1__DefaultWorkspaceRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DefaultWorkspaceRequestType, SOAP_TYPE_ns1__DefaultWorkspaceRequestType, sizeof(ns1__DefaultWorkspaceRequestType), 0, soap_finsert, soap_fbase);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

/*---------------------[ soap_instantiate_ns1__DefaultWorkspaceRequestType ]---*/
SOAP_FMAC1 ns1__DefaultWorkspaceRequestType * SOAP_FMAC2 soap_instantiate_ns1__DefaultWorkspaceRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DefaultWorkspaceRequestType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
  (void)type; (void)arrayType; /* appease -Wall -Werror */
  ns1__DefaultWorkspaceRequestType *p;
  size_t k = sizeof(ns1__DefaultWorkspaceRequestType);
  if (n < 0)
  {
    p = SOAP_NEW(ns1__DefaultWorkspaceRequestType);
    if (p)
      ((ns1__DefaultWorkspaceRequestType*)p)->soap = soap;
  }
  else
  {
    p = SOAP_NEW_ARRAY(ns1__DefaultWorkspaceRequestType, n);
    k *= n;
    if (p)
      for (int i = 0; i < n; i++)
        ((ns1__DefaultWorkspaceRequestType*)p)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DefaultWorkspaceRequestType location=%p n=%d\n", (void*)p, n));
  soap_link(soap, p, SOAP_TYPE_ns1__DefaultWorkspaceRequestType, n, soap_fdelete);
  if (size)
    *size = k;
  return p;
}

/*--------------------------[ soap_put ]-----------------------------------*/
int ns1__DefaultWorkspaceRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
  if (soap_out_ns1__DefaultWorkspaceRequestType(soap, tag ? tag : "ns1:DefaultWorkspaceRequestType", -2, this, type))
    return soap->error;
  return soap_putindependent(soap);
}

/*--------------------------[ soap_get ]-----------------------------------*/
void *ns1__DefaultWorkspaceRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
  return soap_get_ns1__DefaultWorkspaceRequestType(soap, this, tag, type);
}

/*---------------------[ soap_get_ns1__DefaultWorkspaceRequestType ]-------*/
SOAP_FMAC3 ns1__DefaultWorkspaceRequestType * SOAP_FMAC4 soap_get_ns1__DefaultWorkspaceRequestType(struct soap *soap, ns1__DefaultWorkspaceRequestType *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns1__DefaultWorkspaceRequestType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}


//============[ ns1__BriefInfoRequestType::Implemented Methods ]============
/*--------------------------[ soap_default ]-------------------------------*/
void ns1__BriefInfoRequestType::soap_default(struct soap *soap)
{
  this->soap = soap;
  this->ns1__BriefInfoRequestType::requestInfoHeader = NULL;
  /* transient soap skipped */
}

void ns1__BriefInfoRequestType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RequestInfoHeaderType(soap, &this->ns1__BriefInfoRequestType::requestInfoHeader);
#endif
}

int ns1__BriefInfoRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__BriefInfoRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BriefInfoRequestType(struct soap *soap, const char *tag, int id, const ns1__BriefInfoRequestType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BriefInfoRequestType), type))
		return soap->error;
	if (!a->ns1__BriefInfoRequestType::requestInfoHeader)
	{	if (soap_element_empty(soap, "requestInfoHeader"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", -1, &a->ns1__BriefInfoRequestType::requestInfoHeader, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__BriefInfoRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__BriefInfoRequestType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__BriefInfoRequestType * SOAP_FMAC4 soap_in_ns1__BriefInfoRequestType(struct soap *soap, const char *tag, ns1__BriefInfoRequestType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__BriefInfoRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BriefInfoRequestType, sizeof(ns1__BriefInfoRequestType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__BriefInfoRequestType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__BriefInfoRequestType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_requestInfoHeader1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", &a->ns1__BriefInfoRequestType::requestInfoHeader, "ns1:RequestInfoHeaderType"))
				{	soap_flag_requestInfoHeader1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__BriefInfoRequestType::requestInfoHeader))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__BriefInfoRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BriefInfoRequestType, SOAP_TYPE_ns1__BriefInfoRequestType, sizeof(ns1__BriefInfoRequestType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__BriefInfoRequestType * SOAP_FMAC2 soap_instantiate_ns1__BriefInfoRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BriefInfoRequestType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__BriefInfoRequestType *p;
	size_t k = sizeof(ns1__BriefInfoRequestType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__BriefInfoRequestType);
		if (p)
			((ns1__BriefInfoRequestType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__BriefInfoRequestType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__BriefInfoRequestType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__BriefInfoRequestType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__BriefInfoRequestType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__BriefInfoRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__BriefInfoRequestType(soap, tag ? tag : "ns1:BriefInfoRequestType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__BriefInfoRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__BriefInfoRequestType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__BriefInfoRequestType * SOAP_FMAC4 soap_get_ns1__BriefInfoRequestType(struct soap *soap, ns1__BriefInfoRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BriefInfoRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}



//============[ ns1__AgentsListReturnType::Implemented Methods ]=============
//ctor
ns1__AgentsListReturnType::ns1__AgentsListReturnType(): responseInfoHeader(), returnArray(), soap()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ctor of ns1__AgentsListReturnType(" << address << ")" << LOG_TERMINATOR;
  ////DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__AgentsListReturnType(addr:%s)\n", address));
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__AgentsListReturnType(addr:%p)\n", (void*)this));
}

//dtor
ns1__AgentsListReturnType::~ns1__AgentsListReturnType()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "dtor of ns1__AgentsListReturnType(" << address << ")" << LOG_TERMINATOR;
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "dtor ns1__AgentsListReturnType(addr:%p)\n", (void*)this));
}

/*--------------------------[ soap_default ]-------------------------------*/
void ns1__AgentsListReturnType::soap_default(struct soap *soap)
{
  this->soap = soap;
  this->ns1__AgentsListReturnType::responseInfoHeader = NULL;
  soap_default_std__vectorTemplateOfPointerTons1__AgentsListDataItemType(soap, &this->ns1__AgentsListReturnType::returnArray);
  /* transient soap skipped */
}

/*--------------------------[ soap_serialize ]-----------------------------*/
void ns1__AgentsListReturnType::soap_serialize(struct soap *soap) const
{
  (void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
  soap_serialize_PointerTons1__ResponseInfoHeaderType(soap, &this->ns1__AgentsListReturnType::responseInfoHeader);
  soap_serialize_std__vectorTemplateOfPointerTons1__AgentsListDataItemType(soap, &this->ns1__AgentsListReturnType::returnArray);
#endif
}

/*--------------------------[ soap_out ]-----------------------------------*/
int ns1__AgentsListReturnType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
  return soap_out_ns1__AgentsListReturnType(soap, tag, id, this, type);
}

/*--------------------[ soap_out_ns1__AgentsListReturnType ]---------------*/
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AgentsListReturnType(struct soap *soap, const char *tag, int id, const ns1__AgentsListReturnType *a, const char *type)
{
  (void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AgentsListReturnType), type))
    return soap->error;
  if (!a->ns1__AgentsListReturnType::responseInfoHeader)
  {
    if (soap_element_empty(soap, "responseInfoHeader"))
      return soap->error;
  }
  else
    if (soap_out_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", -1, &a->ns1__AgentsListReturnType::responseInfoHeader, ""))
      return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__AgentsListDataItemType(soap, "returnArray", -1, &a->ns1__AgentsListReturnType::returnArray, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

/*--------------------------[ soap_in ]------------------------------------*/
void *ns1__AgentsListReturnType::soap_in(struct soap *soap, const char *tag, const char *type)
{
  return soap_in_ns1__AgentsListReturnType(soap, tag, this, type);
}

/*--------------------[ soap_in_ns1__AgentsListReturnType ]----------------*/
SOAP_FMAC3 ns1__AgentsListReturnType * SOAP_FMAC4 soap_in_ns1__AgentsListReturnType(struct soap *soap, const char *tag, ns1__AgentsListReturnType *a, const char *type)
{
  (void)tag; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (ns1__AgentsListReturnType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AgentsListReturnType, sizeof(ns1__AgentsListReturnType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
  if (!a)
    return NULL;
  if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__AgentsListReturnType)
  {
    soap_revert(soap);
    *soap->id = '\0';
    return (ns1__AgentsListReturnType *)a->soap_in(soap, tag, type);
  }
  if (soap->alloced)
    a->soap_default(soap);
  size_t soap_flag_responseInfoHeader1 = 1;
  if (soap->body && *soap->href != '#')
  {
    for (;;)
    {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_responseInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", &a->ns1__AgentsListReturnType::responseInfoHeader, "ns1:ResponseInfoHeaderType"))
        {
          soap_flag_responseInfoHeader1--;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_std__vectorTemplateOfPointerTons1__AgentsListDataItemType(soap, "returnArray", &a->ns1__AgentsListReturnType::returnArray, "ns1:AgentsListDataItemType"))
          continue;
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
    if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__AgentsListReturnType::responseInfoHeader || a->ns1__AgentsListReturnType::returnArray.size() < 1))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }
  }
  else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
  {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  else
  {
    a = (ns1__AgentsListReturnType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AgentsListReturnType, SOAP_TYPE_ns1__AgentsListReturnType, sizeof(ns1__AgentsListReturnType), 0, soap_finsert, soap_fbase);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

/*-----------------[ soap_instantiate_ns1__AgentsListReturnType ]----------*/
SOAP_FMAC1 ns1__AgentsListReturnType * SOAP_FMAC2 soap_instantiate_ns1__AgentsListReturnType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AgentsListReturnType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
  (void)type; (void)arrayType; /* appease -Wall -Werror */
  ns1__AgentsListReturnType *p;
  size_t k = sizeof(ns1__AgentsListReturnType);
  if (n < 0)
  {
    p = SOAP_NEW(ns1__AgentsListReturnType);
    if (p)
      ((ns1__AgentsListReturnType*)p)->soap = soap;
  }
  else
  {
    p = SOAP_NEW_ARRAY(ns1__AgentsListReturnType, n);
    k *= n;
    if (p)
      for (int i = 0; i < n; i++)
        ((ns1__AgentsListReturnType*)p)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__AgentsListReturnType location=%p n=%d\n", (void*)p, n));
  soap_link(soap, p, SOAP_TYPE_ns1__AgentsListReturnType, n, soap_fdelete);
  if (size)
    *size = k;
  return p;
}

/*--------------------------[ soap_put ]-----------------------------------*/
int ns1__AgentsListReturnType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
  if (soap_out_ns1__AgentsListReturnType(soap, tag ? tag : "ns1:AgentsListReturnType", -2, this, type))
    return soap->error;
  return soap_putindependent(soap);
}

/*--------------------------[ soap_get ]-----------------------------------*/
void *ns1__AgentsListReturnType::soap_get(struct soap *soap, const char *tag, const char *type)
{
  return soap_get_ns1__AgentsListReturnType(soap, this, tag, type);
}

/*--------------------------[ soap_get_ns1__AgentsListReturnType ]---------*/
SOAP_FMAC3 ns1__AgentsListReturnType * SOAP_FMAC4 soap_get_ns1__AgentsListReturnType(struct soap *soap, ns1__AgentsListReturnType *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns1__AgentsListReturnType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

/*--------------------------[ soap_dealloc ]-------------------------------*/
void ns1__AgentsListReturnType::soap_dealloc()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ns1__AgentsListReturnType::soap_dealloc(" << address << ")" << LOG_TERMINATOR;
  for(unsigned int i=0; i<returnArray.size(); i++)
  {
    //er_sprintf(address, "%p", returnArray[i]);
    //soap_obj_log_d << "ns1__AgentsListReturnType::soap_dealloc - delete " << address << ")" << LOG_TERMINATOR;
    delete []returnArray[i];
  }
  returnArray.clear();
}



void ns1__AgentsListDataItemType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_unsignedInt(soap, &this->ns1__AgentsListDataItemType::agentId);
	soap_default_std__string(soap, &this->ns1__AgentsListDataItemType::agentName);
	soap_default_std__string(soap, &this->ns1__AgentsListDataItemType::agentNumber);
	/* transient soap skipped */
}

void ns1__AgentsListDataItemType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__AgentsListDataItemType::agentId, SOAP_TYPE_unsignedInt);
	soap_serialize_std__string(soap, &this->ns1__AgentsListDataItemType::agentName);
	soap_serialize_std__string(soap, &this->ns1__AgentsListDataItemType::agentNumber);
#endif
}

int ns1__AgentsListDataItemType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AgentsListDataItemType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AgentsListDataItemType(struct soap *soap, const char *tag, int id, const ns1__AgentsListDataItemType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AgentsListDataItemType), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "agentId", -1, &a->ns1__AgentsListDataItemType::agentId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "agentName", -1, &a->ns1__AgentsListDataItemType::agentName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "agentNumber", -1, &a->ns1__AgentsListDataItemType::agentNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__AgentsListDataItemType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AgentsListDataItemType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AgentsListDataItemType * SOAP_FMAC4 soap_in_ns1__AgentsListDataItemType(struct soap *soap, const char *tag, ns1__AgentsListDataItemType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AgentsListDataItemType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AgentsListDataItemType, sizeof(ns1__AgentsListDataItemType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__AgentsListDataItemType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__AgentsListDataItemType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_agentId1 = 1;
	size_t soap_flag_agentName1 = 1;
	size_t soap_flag_agentNumber1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_agentId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "agentId", &a->ns1__AgentsListDataItemType::agentId, "xsd:unsignedInt"))
				{	soap_flag_agentId1--;
					continue;
				}
			}
			if (soap_flag_agentName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "agentName", &a->ns1__AgentsListDataItemType::agentName, "xsd:string"))
				{	soap_flag_agentName1--;
					continue;
				}
			}
			if (soap_flag_agentNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "agentNumber", &a->ns1__AgentsListDataItemType::agentNumber, "xsd:string"))
				{	soap_flag_agentNumber1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_agentId1 > 0 || soap_flag_agentName1 > 0 || soap_flag_agentNumber1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__AgentsListDataItemType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AgentsListDataItemType, SOAP_TYPE_ns1__AgentsListDataItemType, sizeof(ns1__AgentsListDataItemType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__AgentsListDataItemType * SOAP_FMAC2 soap_instantiate_ns1__AgentsListDataItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AgentsListDataItemType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__AgentsListDataItemType *p;
	size_t k = sizeof(ns1__AgentsListDataItemType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__AgentsListDataItemType);
		if (p)
			((ns1__AgentsListDataItemType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__AgentsListDataItemType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__AgentsListDataItemType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__AgentsListDataItemType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__AgentsListDataItemType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__AgentsListDataItemType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__AgentsListDataItemType(soap, tag ? tag : "ns1:AgentsListDataItemType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__AgentsListDataItemType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AgentsListDataItemType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AgentsListDataItemType * SOAP_FMAC4 soap_get_ns1__AgentsListDataItemType(struct soap *soap, ns1__AgentsListDataItemType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AgentsListDataItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


//============[ ns1__GenListReturnType::Implemented Methods ]================
//ctor
ns1__GenListReturnType::ns1__GenListReturnType(): responseInfoHeader(), returnArray(), soap()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ctor of ns1__GenListReturnType(" << address << ")" << LOG_TERMINATOR;
  ////DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__ReturnArrayDataType(addr:%s)\n", address));
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__GenListReturnType(addr:%p)\n", (void*)this));
}

//dtor
ns1__GenListReturnType::~ns1__GenListReturnType()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "dtor of ns1__GenListReturnType(" << address << ")" << LOG_TERMINATOR;
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "dtor ns1__GenListReturnType(addr:%p)\n", (void*)this));
}

/*--------------------------[ soap_default ]-------------------------------*/
void ns1__GenListReturnType::soap_default(struct soap *soap)
{
  this->soap = soap;
  this->ns1__GenListReturnType::responseInfoHeader = NULL;
  soap_default_std__vectorTemplateOfPointerTons1__GenListDataItemType(soap, &this->ns1__GenListReturnType::returnArray);
  /* transient soap skipped */
}

/*--------------------------[ soap_serialize ]-----------------------------*/
void ns1__GenListReturnType::soap_serialize(struct soap *soap) const
{
  (void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
  soap_serialize_PointerTons1__ResponseInfoHeaderType(soap, &this->ns1__GenListReturnType::responseInfoHeader);
  soap_serialize_std__vectorTemplateOfPointerTons1__GenListDataItemType(soap, &this->ns1__GenListReturnType::returnArray);
#endif
}

/*--------------------------[ soap_out ]-----------------------------------*/
int ns1__GenListReturnType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
  return soap_out_ns1__GenListReturnType(soap, tag, id, this, type);
}

/*--------------------[ soap_out_ns1__GenListReturnType ]------------------*/
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GenListReturnType(struct soap *soap, const char *tag, int id, const ns1__GenListReturnType *a, const char *type)
{
  (void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GenListReturnType), type))
    return soap->error;
  if (!a->ns1__GenListReturnType::responseInfoHeader)
  {
    if (soap_element_empty(soap, "responseInfoHeader"))
      return soap->error;
  }
  else
    if (soap_out_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", -1, &a->ns1__GenListReturnType::responseInfoHeader, ""))
      return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__GenListDataItemType(soap, "returnArray", -1, &a->ns1__GenListReturnType::returnArray, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

/*--------------------------[ soap_in ]------------------------------------*/
void *ns1__GenListReturnType::soap_in(struct soap *soap, const char *tag, const char *type)
{
  return soap_in_ns1__GenListReturnType(soap, tag, this, type);
}

/*--------------------[ soap_in_ns1__GenListReturnType ]-------------------*/
SOAP_FMAC3 ns1__GenListReturnType * SOAP_FMAC4 soap_in_ns1__GenListReturnType(struct soap *soap, const char *tag, ns1__GenListReturnType *a, const char *type)
{
  (void)tag; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (ns1__GenListReturnType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GenListReturnType, sizeof(ns1__GenListReturnType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
  if (!a)
    return NULL;
  if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GenListReturnType)
  {
    soap_revert(soap);
    *soap->id = '\0';
    return (ns1__GenListReturnType *)a->soap_in(soap, tag, type);
  }
  if (soap->alloced)
    a->soap_default(soap);
  size_t soap_flag_responseInfoHeader1 = 1;
  if (soap->body && *soap->href != '#')
  {
    for (;;)
    {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_responseInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", &a->ns1__GenListReturnType::responseInfoHeader, "ns1:ResponseInfoHeaderType"))
        {
          soap_flag_responseInfoHeader1--;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_std__vectorTemplateOfPointerTons1__GenListDataItemType(soap, "returnArray", &a->ns1__GenListReturnType::returnArray, "ns1:GenListDataItemType"))
          continue;
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
    if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__GenListReturnType::responseInfoHeader))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }
  }
  else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
  {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  else
  {
    a = (ns1__GenListReturnType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GenListReturnType, SOAP_TYPE_ns1__GenListReturnType, sizeof(ns1__GenListReturnType), 0, soap_finsert, soap_fbase);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

/*-----------------[ soap_instantiate_ns1__GenListReturnType ]-------------*/
SOAP_FMAC1 ns1__GenListReturnType * SOAP_FMAC2 soap_instantiate_ns1__GenListReturnType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GenListReturnType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
  (void)type; (void)arrayType; /* appease -Wall -Werror */
  ns1__GenListReturnType *p;
  size_t k = sizeof(ns1__GenListReturnType);
  if (n < 0)
  {
    p = SOAP_NEW(ns1__GenListReturnType);
    if (p)
      ((ns1__GenListReturnType*)p)->soap = soap;
  }
  else
  {
    p = SOAP_NEW_ARRAY(ns1__GenListReturnType, n);
    k *= n;
    if (p)
      for (int i = 0; i < n; i++)
        ((ns1__GenListReturnType*)p)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GenListReturnType location=%p n=%d\n", (void*)p, n));
  soap_link(soap, p, SOAP_TYPE_ns1__GenListReturnType, n, soap_fdelete);
  if (size)
    *size = k;
  return p;
}

/*--------------------------[ soap_put ]-----------------------------------*/
int ns1__GenListReturnType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
  if (soap_out_ns1__GenListReturnType(soap, tag ? tag : "ns1:GenListReturnType", -2, this, type))
    return soap->error;
  return soap_putindependent(soap);
}

/*--------------------------[ soap_get ]-----------------------------------*/
void *ns1__GenListReturnType::soap_get(struct soap *soap, const char *tag, const char *type)
{
  return soap_get_ns1__GenListReturnType(soap, this, tag, type);
}

/*--------------------------[ soap_get_ns1__GenListReturnType ]------------*/
SOAP_FMAC3 ns1__GenListReturnType * SOAP_FMAC4 soap_get_ns1__GenListReturnType(struct soap *soap, ns1__GenListReturnType *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns1__GenListReturnType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

/*--------------------------[ soap_dealloc ]-------------------------------*/
void ns1__GenListReturnType::soap_dealloc()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ns1__GenListReturnType::soap_dealloc(" << address << ")" << LOG_TERMINATOR;
  for(unsigned int i=0; i<returnArray.size(); i++)
  {
    //er_sprintf(address, "%p", returnArray[i]);
    //soap_obj_log_d << "ns1__GenListReturnType::soap_dealloc - delete " << address << ")" << LOG_TERMINATOR;
    delete []returnArray[i];
  }
  returnArray.clear();
}



void ns1__GenListDataItemType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_unsignedInt(soap, &this->ns1__GenListDataItemType::Id);
	soap_default_std__string(soap, &this->ns1__GenListDataItemType::Name);
	/* transient soap skipped */
}

void ns1__GenListDataItemType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__GenListDataItemType::Id, SOAP_TYPE_unsignedInt);
	soap_serialize_std__string(soap, &this->ns1__GenListDataItemType::Name);
#endif
}

int ns1__GenListDataItemType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GenListDataItemType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GenListDataItemType(struct soap *soap, const char *tag, int id, const ns1__GenListDataItemType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GenListDataItemType), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "Id", -1, &a->ns1__GenListDataItemType::Id, ""))
		return soap->error;
	if (soap_out_std__string(soap, "Name", -1, &a->ns1__GenListDataItemType::Name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GenListDataItemType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__GenListDataItemType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GenListDataItemType * SOAP_FMAC4 soap_in_ns1__GenListDataItemType(struct soap *soap, const char *tag, ns1__GenListDataItemType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GenListDataItemType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GenListDataItemType, sizeof(ns1__GenListDataItemType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GenListDataItemType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__GenListDataItemType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Name1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "Id", &a->ns1__GenListDataItemType::Id, "xsd:unsignedInt"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "Name", &a->ns1__GenListDataItemType::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_Name1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__GenListDataItemType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GenListDataItemType, SOAP_TYPE_ns1__GenListDataItemType, sizeof(ns1__GenListDataItemType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GenListDataItemType * SOAP_FMAC2 soap_instantiate_ns1__GenListDataItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GenListDataItemType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__GenListDataItemType *p;
	size_t k = sizeof(ns1__GenListDataItemType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__GenListDataItemType);
		if (p)
			((ns1__GenListDataItemType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__GenListDataItemType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__GenListDataItemType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GenListDataItemType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__GenListDataItemType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__GenListDataItemType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GenListDataItemType(soap, tag ? tag : "ns1:GenListDataItemType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GenListDataItemType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GenListDataItemType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GenListDataItemType * SOAP_FMAC4 soap_get_ns1__GenListDataItemType(struct soap *soap, ns1__GenListDataItemType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GenListDataItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


//============[ ns1__GroupListReturnType::Implemented Methods ]==============
//ctor
ns1__GroupListReturnType::ns1__GroupListReturnType(): responseInfoHeader(), returnArray(), soap()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ctor of ns1__GroupListReturnType(" << address << ")" << LOG_TERMINATOR;
  ////DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__GroupListReturnType(addr:%s)\n", address));
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__GroupListReturnType(addr:%p)\n", (void*)this));
}

//dtor
ns1__GroupListReturnType::~ns1__GroupListReturnType()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "dtor of ns1__GroupListReturnType(" << address << ")" << LOG_TERMINATOR;
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "dtor ns1__GroupListReturnType(addr:%p)\n", (void*)this));
}

/*--------------------------[ soap_default ]-------------------------------*/
void ns1__GroupListReturnType::soap_default(struct soap *soap)
{
  this->soap = soap;
  this->ns1__GroupListReturnType::responseInfoHeader = NULL;
  soap_default_std__vectorTemplateOfPointerTons1__GroupListDataItemType(soap, &this->ns1__GroupListReturnType::returnArray);
  /* transient soap skipped */
}

/*--------------------------[ soap_serialize ]-----------------------------*/
void ns1__GroupListReturnType::soap_serialize(struct soap *soap) const
{
  (void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
  soap_serialize_PointerTons1__ResponseInfoHeaderType(soap, &this->ns1__GroupListReturnType::responseInfoHeader);
  soap_serialize_std__vectorTemplateOfPointerTons1__GroupListDataItemType(soap, &this->ns1__GroupListReturnType::returnArray);
#endif
}

/*--------------------------[ soap_out ]-----------------------------------*/
int ns1__GroupListReturnType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
  return soap_out_ns1__GroupListReturnType(soap, tag, id, this, type);
}

/*--------------------[ soap_out_ns1__GroupListReturnType ]----------------*/
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GroupListReturnType(struct soap *soap, const char *tag, int id, const ns1__GroupListReturnType *a, const char *type)
{
  (void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GroupListReturnType), type))
    return soap->error;
  if (!a->ns1__GroupListReturnType::responseInfoHeader)
  {
    if (soap_element_empty(soap, "responseInfoHeader"))
      return soap->error;
  }
  else
    if (soap_out_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", -1, &a->ns1__GroupListReturnType::responseInfoHeader, ""))
      return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__GroupListDataItemType(soap, "returnArray", -1, &a->ns1__GroupListReturnType::returnArray, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

/*--------------------------[ soap_in ]------------------------------------*/
void *ns1__GroupListReturnType::soap_in(struct soap *soap, const char *tag, const char *type)
{
  return soap_in_ns1__GroupListReturnType(soap, tag, this, type);
}

/*--------------------[ soap_in_ns1__GroupListReturnType ]-----------------*/
SOAP_FMAC3 ns1__GroupListReturnType * SOAP_FMAC4 soap_in_ns1__GroupListReturnType(struct soap *soap, const char *tag, ns1__GroupListReturnType *a, const char *type)
{
  (void)tag; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (ns1__GroupListReturnType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GroupListReturnType, sizeof(ns1__GroupListReturnType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
  if (!a)
    return NULL;
  if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GroupListReturnType)
  {
    soap_revert(soap);
    *soap->id = '\0';
    return (ns1__GroupListReturnType *)a->soap_in(soap, tag, type);
  }
  if (soap->alloced)
    a->soap_default(soap);
  size_t soap_flag_responseInfoHeader1 = 1;
  if (soap->body && *soap->href != '#')
  {
    for (;;)
    {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_responseInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", &a->ns1__GroupListReturnType::responseInfoHeader, "ns1:ResponseInfoHeaderType"))
        {
          soap_flag_responseInfoHeader1--;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_std__vectorTemplateOfPointerTons1__GroupListDataItemType(soap, "returnArray", &a->ns1__GroupListReturnType::returnArray, "ns1:GroupListDataItemType"))
          continue;
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
    if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__GroupListReturnType::responseInfoHeader || a->ns1__GroupListReturnType::returnArray.size() < 1))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }
  }
  else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
  {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  else
  {
    a = (ns1__GroupListReturnType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GroupListReturnType, SOAP_TYPE_ns1__GroupListReturnType, sizeof(ns1__GroupListReturnType), 0, soap_finsert, soap_fbase);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

/*-----------------[ soap_instantiate_ns1__GroupListReturnType ]-----------*/
SOAP_FMAC1 ns1__GroupListReturnType * SOAP_FMAC2 soap_instantiate_ns1__GroupListReturnType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GroupListReturnType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
  (void)type; (void)arrayType; /* appease -Wall -Werror */
  ns1__GroupListReturnType *p;
  size_t k = sizeof(ns1__GroupListReturnType);
  if (n < 0)
  {
    p = SOAP_NEW(ns1__GroupListReturnType);
    if (p)
      ((ns1__GroupListReturnType*)p)->soap = soap;
  }
  else
  {
    p = SOAP_NEW_ARRAY(ns1__GroupListReturnType, n);
    k *= n;
    if (p)
      for (int i = 0; i < n; i++)
        ((ns1__GroupListReturnType*)p)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GroupListReturnType location=%p n=%d\n", (void*)p, n));
  soap_link(soap, p, SOAP_TYPE_ns1__GroupListReturnType, n, soap_fdelete);
  if (size)
    *size = k;
  return p;
}

/*--------------------------[ soap_put ]-----------------------------------*/
int ns1__GroupListReturnType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
  if (soap_out_ns1__GroupListReturnType(soap, tag ? tag : "ns1:GroupListReturnType", -2, this, type))
    return soap->error;
  return soap_putindependent(soap);
}

/*--------------------------[ soap_get ]-----------------------------------*/
void *ns1__GroupListReturnType::soap_get(struct soap *soap, const char *tag, const char *type)
{
  return soap_get_ns1__GroupListReturnType(soap, this, tag, type);
}

/*--------------------------[ soap_get_ns1__GroupListReturnType ]---------*/
SOAP_FMAC3 ns1__GroupListReturnType * SOAP_FMAC4 soap_get_ns1__GroupListReturnType(struct soap *soap, ns1__GroupListReturnType *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns1__GroupListReturnType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

/*--------------------------[ soap_dealloc ]-------------------------------*/
void ns1__GroupListReturnType::soap_dealloc()
{
  for(unsigned int i=0; i<returnArray.size(); i++)
  {
    //char address[20];
    //er_sprintf(address, "%p", returnArray[i]);
    //soap_obj_log_d << "ns1__GroupListReturnType::soap_dealloc - delete " << address << ")" << LOG_TERMINATOR;
    delete []returnArray[i];
  }
  returnArray.clear();
}




void ns1__GroupListDataItemType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_unsignedInt(soap, &this->ns1__GroupListDataItemType::grpId);
	soap_default_std__string(soap, &this->ns1__GroupListDataItemType::grpName);
	soap_default_std__string(soap, &this->ns1__GroupListDataItemType::grpNumber);
	soap_default_unsignedInt(soap, &this->ns1__GroupListDataItemType::grpEmailEnable);
	/* transient soap skipped */
}

void ns1__GroupListDataItemType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__GroupListDataItemType::grpId, SOAP_TYPE_unsignedInt);
	soap_serialize_std__string(soap, &this->ns1__GroupListDataItemType::grpName);
	soap_serialize_std__string(soap, &this->ns1__GroupListDataItemType::grpNumber);
	soap_embedded(soap, &this->ns1__GroupListDataItemType::grpEmailEnable, SOAP_TYPE_unsignedInt);
#endif
}

int ns1__GroupListDataItemType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GroupListDataItemType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GroupListDataItemType(struct soap *soap, const char *tag, int id, const ns1__GroupListDataItemType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GroupListDataItemType), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "grpId", -1, &a->ns1__GroupListDataItemType::grpId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "grpName", -1, &a->ns1__GroupListDataItemType::grpName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "grpNumber", -1, &a->ns1__GroupListDataItemType::grpNumber, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "grpEmailEnable", -1, &a->ns1__GroupListDataItemType::grpEmailEnable, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GroupListDataItemType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__GroupListDataItemType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GroupListDataItemType * SOAP_FMAC4 soap_in_ns1__GroupListDataItemType(struct soap *soap, const char *tag, ns1__GroupListDataItemType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GroupListDataItemType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GroupListDataItemType, sizeof(ns1__GroupListDataItemType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GroupListDataItemType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__GroupListDataItemType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_grpId1 = 1;
	size_t soap_flag_grpName1 = 1;
	size_t soap_flag_grpNumber1 = 1;
	size_t soap_flag_grpEmailEnable1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_grpId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "grpId", &a->ns1__GroupListDataItemType::grpId, "xsd:unsignedInt"))
				{	soap_flag_grpId1--;
					continue;
				}
			}
			if (soap_flag_grpName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "grpName", &a->ns1__GroupListDataItemType::grpName, "xsd:string"))
				{	soap_flag_grpName1--;
					continue;
				}
			}
			if (soap_flag_grpNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "grpNumber", &a->ns1__GroupListDataItemType::grpNumber, "xsd:string"))
				{	soap_flag_grpNumber1--;
					continue;
				}
			}
			if (soap_flag_grpEmailEnable1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "grpEmailEnable", &a->ns1__GroupListDataItemType::grpEmailEnable, "xsd:unsignedInt"))
				{	soap_flag_grpEmailEnable1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_grpId1 > 0 || soap_flag_grpName1 > 0 || soap_flag_grpNumber1 > 0 || soap_flag_grpEmailEnable1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__GroupListDataItemType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GroupListDataItemType, SOAP_TYPE_ns1__GroupListDataItemType, sizeof(ns1__GroupListDataItemType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GroupListDataItemType * SOAP_FMAC2 soap_instantiate_ns1__GroupListDataItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GroupListDataItemType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__GroupListDataItemType *p;
	size_t k = sizeof(ns1__GroupListDataItemType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__GroupListDataItemType);
		if (p)
			((ns1__GroupListDataItemType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__GroupListDataItemType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__GroupListDataItemType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GroupListDataItemType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__GroupListDataItemType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__GroupListDataItemType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GroupListDataItemType(soap, tag ? tag : "ns1:GroupListDataItemType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GroupListDataItemType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GroupListDataItemType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GroupListDataItemType * SOAP_FMAC4 soap_get_ns1__GroupListDataItemType(struct soap *soap, ns1__GroupListDataItemType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GroupListDataItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__GenRequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__GenRequestType::requestInfoHeader = NULL;
	/* transient soap skipped */
}

void ns1__GenRequestType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RequestInfoHeaderType(soap, &this->ns1__GenRequestType::requestInfoHeader);
#endif
}

int ns1__GenRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GenRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GenRequestType(struct soap *soap, const char *tag, int id, const ns1__GenRequestType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GenRequestType), type))
		return soap->error;
	if (!a->ns1__GenRequestType::requestInfoHeader)
	{	if (soap_element_empty(soap, "requestInfoHeader"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", -1, &a->ns1__GenRequestType::requestInfoHeader, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GenRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__GenRequestType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GenRequestType * SOAP_FMAC4 soap_in_ns1__GenRequestType(struct soap *soap, const char *tag, ns1__GenRequestType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GenRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GenRequestType, sizeof(ns1__GenRequestType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GenRequestType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__GenRequestType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_requestInfoHeader1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", &a->ns1__GenRequestType::requestInfoHeader, "ns1:RequestInfoHeaderType"))
				{	soap_flag_requestInfoHeader1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__GenRequestType::requestInfoHeader))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__GenRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GenRequestType, SOAP_TYPE_ns1__GenRequestType, sizeof(ns1__GenRequestType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GenRequestType * SOAP_FMAC2 soap_instantiate_ns1__GenRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GenRequestType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__GenRequestType *p;
	size_t k = sizeof(ns1__GenRequestType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__GenRequestType);
		if (p)
			((ns1__GenRequestType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__GenRequestType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__GenRequestType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GenRequestType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__GenRequestType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__GenRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GenRequestType(soap, tag ? tag : "ns1:GenRequestType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GenRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GenRequestType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GenRequestType * SOAP_FMAC4 soap_get_ns1__GenRequestType(struct soap *soap, ns1__GenRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GenRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__LoginReturnType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__LoginReturnType::responseInfoHeader = NULL;
	soap_default_std__string(soap, &this->ns1__LoginReturnType::ticket);
	soap_default_unsignedInt(soap, &this->ns1__LoginReturnType::loginEnable);
	soap_default_unsignedInt(soap, &this->ns1__LoginReturnType::supLevel);
	/* transient soap skipped */
}

void ns1__LoginReturnType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ResponseInfoHeaderType(soap, &this->ns1__LoginReturnType::responseInfoHeader);
	soap_serialize_std__string(soap, &this->ns1__LoginReturnType::ticket);
	soap_embedded(soap, &this->ns1__LoginReturnType::loginEnable, SOAP_TYPE_unsignedInt);
	soap_embedded(soap, &this->ns1__LoginReturnType::supLevel, SOAP_TYPE_unsignedInt);
#endif
}

int ns1__LoginReturnType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__LoginReturnType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LoginReturnType(struct soap *soap, const char *tag, int id, const ns1__LoginReturnType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LoginReturnType), type))
		return soap->error;
	if (!a->ns1__LoginReturnType::responseInfoHeader)
	{	if (soap_element_empty(soap, "responseInfoHeader"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", -1, &a->ns1__LoginReturnType::responseInfoHeader, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ticket", -1, &a->ns1__LoginReturnType::ticket, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "loginEnable", -1, &a->ns1__LoginReturnType::loginEnable, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "supLevel", -1, &a->ns1__LoginReturnType::supLevel, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__LoginReturnType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__LoginReturnType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__LoginReturnType * SOAP_FMAC4 soap_in_ns1__LoginReturnType(struct soap *soap, const char *tag, ns1__LoginReturnType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__LoginReturnType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LoginReturnType, sizeof(ns1__LoginReturnType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__LoginReturnType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__LoginReturnType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_responseInfoHeader1 = 1;
	size_t soap_flag_ticket1 = 1;
	size_t soap_flag_loginEnable1 = 1;
	size_t soap_flag_supLevel1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_responseInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", &a->ns1__LoginReturnType::responseInfoHeader, "ns1:ResponseInfoHeaderType"))
				{	soap_flag_responseInfoHeader1--;
					continue;
				}
			}
			if (soap_flag_ticket1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ticket", &a->ns1__LoginReturnType::ticket, "xsd:string"))
				{	soap_flag_ticket1--;
					continue;
				}
			}
			if (soap_flag_loginEnable1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "loginEnable", &a->ns1__LoginReturnType::loginEnable, "xsd:unsignedInt"))
				{	soap_flag_loginEnable1--;
					continue;
				}
			}
			if (soap_flag_supLevel1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "supLevel", &a->ns1__LoginReturnType::supLevel, "xsd:unsignedInt"))
				{	soap_flag_supLevel1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__LoginReturnType::responseInfoHeader || soap_flag_ticket1 > 0 || soap_flag_loginEnable1 > 0 || soap_flag_supLevel1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__LoginReturnType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LoginReturnType, SOAP_TYPE_ns1__LoginReturnType, sizeof(ns1__LoginReturnType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__LoginReturnType * SOAP_FMAC2 soap_instantiate_ns1__LoginReturnType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__LoginReturnType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__LoginReturnType *p;
	size_t k = sizeof(ns1__LoginReturnType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__LoginReturnType);
		if (p)
			((ns1__LoginReturnType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__LoginReturnType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__LoginReturnType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__LoginReturnType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__LoginReturnType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__LoginReturnType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__LoginReturnType(soap, tag ? tag : "ns1:LoginReturnType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__LoginReturnType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__LoginReturnType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__LoginReturnType * SOAP_FMAC4 soap_get_ns1__LoginReturnType(struct soap *soap, ns1__LoginReturnType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LoginReturnType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__LoginRequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_unsignedInt(soap, &this->ns1__LoginRequestType::serviceReqId);
	soap_default_std__string(soap, &this->ns1__LoginRequestType::applicationId);
	soap_default_std__string(soap, &this->ns1__LoginRequestType::name);
	soap_default_std__string(soap, &this->ns1__LoginRequestType::pass);
	soap_default_std__string(soap, &this->ns1__LoginRequestType::session_id);
	soap_default_std__string(soap, &this->ns1__LoginRequestType::ip_address);
	/* transient soap skipped */
}

void ns1__LoginRequestType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__LoginRequestType::serviceReqId, SOAP_TYPE_unsignedInt);
	soap_serialize_std__string(soap, &this->ns1__LoginRequestType::applicationId);
	soap_serialize_std__string(soap, &this->ns1__LoginRequestType::name);
	soap_serialize_std__string(soap, &this->ns1__LoginRequestType::pass);
	soap_serialize_std__string(soap, &this->ns1__LoginRequestType::session_id);
	soap_serialize_std__string(soap, &this->ns1__LoginRequestType::ip_address);
#endif
}

int ns1__LoginRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__LoginRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LoginRequestType(struct soap *soap, const char *tag, int id, const ns1__LoginRequestType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LoginRequestType), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "serviceReqId", -1, &a->ns1__LoginRequestType::serviceReqId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "applicationId", -1, &a->ns1__LoginRequestType::applicationId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &a->ns1__LoginRequestType::name, ""))
		return soap->error;
	if (soap_out_std__string(soap, "pass", -1, &a->ns1__LoginRequestType::pass, ""))
		return soap->error;
	if (soap_out_std__string(soap, "session_id", -1, &a->ns1__LoginRequestType::session_id, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ip_address", -1, &a->ns1__LoginRequestType::ip_address, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__LoginRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__LoginRequestType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__LoginRequestType * SOAP_FMAC4 soap_in_ns1__LoginRequestType(struct soap *soap, const char *tag, ns1__LoginRequestType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__LoginRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LoginRequestType, sizeof(ns1__LoginRequestType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__LoginRequestType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__LoginRequestType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_serviceReqId1 = 1;
	size_t soap_flag_applicationId1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_pass1 = 1;
	size_t soap_flag_session_id1 = 1;
	size_t soap_flag_ip_address1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_serviceReqId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "serviceReqId", &a->ns1__LoginRequestType::serviceReqId, "xsd:unsignedInt"))
				{	soap_flag_serviceReqId1--;
					continue;
				}
			}
			if (soap_flag_applicationId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "applicationId", &a->ns1__LoginRequestType::applicationId, "xsd:string"))
				{	soap_flag_applicationId1--;
					continue;
				}
			}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "name", &a->ns1__LoginRequestType::name, "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			}
			if (soap_flag_pass1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "pass", &a->ns1__LoginRequestType::pass, "xsd:string"))
				{	soap_flag_pass1--;
					continue;
				}
			}

			if (soap_flag_session_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "session_id", &a->ns1__LoginRequestType::session_id, "xsd:string"))
				{	soap_flag_session_id1--;
					continue;
				}
			}
			if (soap_flag_ip_address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ip_address", &a->ns1__LoginRequestType::ip_address, "xsd:string"))
				{	soap_flag_ip_address1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_serviceReqId1 > 0 || soap_flag_applicationId1 > 0 || soap_flag_name1 > 0 || soap_flag_pass1 > 0 || soap_flag_session_id1 > 0 || soap_flag_ip_address1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__LoginRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LoginRequestType, SOAP_TYPE_ns1__LoginRequestType, sizeof(ns1__LoginRequestType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__LoginRequestType * SOAP_FMAC2 soap_instantiate_ns1__LoginRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__LoginRequestType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__LoginRequestType *p;
	size_t k = sizeof(ns1__LoginRequestType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__LoginRequestType);
		if (p)
			((ns1__LoginRequestType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__LoginRequestType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__LoginRequestType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__LoginRequestType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__LoginRequestType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__LoginRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__LoginRequestType(soap, tag ? tag : "ns1:LoginRequestType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__LoginRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__LoginRequestType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__LoginRequestType * SOAP_FMAC4 soap_get_ns1__LoginRequestType(struct soap *soap, ns1__LoginRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LoginRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}



//============[ ns1__ReturnMatrixDataTypeBG::Implemented Methods ]===========
//ctor
ns1__ReturnMatrixDataTypeBG::ns1__ReturnMatrixDataTypeBG(): responseInfoHeader(), returnMatrix(), soap()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ctor of ns1__ReturnMatrixDataTypeBG(" << address << ")" << LOG_TERMINATOR;
  ////DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__ReturnArrayDataType(addr:%s)\n", address));
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__ReturnMatrixDataTypeBG(addr:%p)\n", (void*)this));
}

//dtor
ns1__ReturnMatrixDataTypeBG::~ns1__ReturnMatrixDataTypeBG()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "dtor of ns1__ReturnMatrixDataTypeBG(" << address << ")" << LOG_TERMINATOR;
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "dtor ns1__ReturnMatrixDataTypeBG(addr:%p)\n", (void*)this));
}

/*--------------------------[ soap_default ]-------------------------------*/
void ns1__ReturnMatrixDataTypeBG::soap_default(struct soap *soap)
{
  this->soap = soap;
  this->ns1__ReturnMatrixDataTypeBG::responseInfoHeader = NULL;
  soap_default_std__vectorTemplateOfPointerTons1__DataItemRow(soap, &this->ns1__ReturnMatrixDataTypeBG::returnMatrix);
  /* transient soap skipped */
}

/*--------------------------[ soap_serialize ]-----------------------------*/
void ns1__ReturnMatrixDataTypeBG::soap_serialize(struct soap *soap) const
{
  (void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
  soap_serialize_PointerTons1__ResponseInfoHeaderType(soap, &this->ns1__ReturnMatrixDataTypeBG::responseInfoHeader);
  soap_serialize_std__vectorTemplateOfPointerTons1__DataItemRow(soap, &this->ns1__ReturnMatrixDataTypeBG::returnMatrix);
#endif
}

/*--------------------------[ soap_out ]-----------------------------------*/
int ns1__ReturnMatrixDataTypeBG::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
  return soap_out_ns1__ReturnMatrixDataTypeBG(soap, tag, id, this, type);
}

/*--------------------[ soap_out_ns1__ReturnMatrixDataTypeBG ]-------------*/
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ReturnMatrixDataTypeBG(struct soap *soap, const char *tag, int id, const ns1__ReturnMatrixDataTypeBG *a, const char *type)
{
  (void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ReturnMatrixDataTypeBG), type))
    return soap->error;
  if (!a->ns1__ReturnMatrixDataTypeBG::responseInfoHeader)
  {
    if (soap_element_empty(soap, "responseInfoHeader"))
      return soap->error;
  }
  else
    if (soap_out_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", -1, &a->ns1__ReturnMatrixDataTypeBG::responseInfoHeader, ""))
      return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__DataItemRow(soap, "returnMatrix", -1, &a->ns1__ReturnMatrixDataTypeBG::returnMatrix, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

/*--------------------------[ soap_in ]------------------------------------*/
void *ns1__ReturnMatrixDataTypeBG::soap_in(struct soap *soap, const char *tag, const char *type)
{
  return soap_in_ns1__ReturnMatrixDataTypeBG(soap, tag, this, type);
}

/*--------------------[ soap_in_ns1__ReturnMatrixDataTypeBG ]--------------*/
SOAP_FMAC3 ns1__ReturnMatrixDataTypeBG * SOAP_FMAC4 soap_in_ns1__ReturnMatrixDataTypeBG(struct soap *soap, const char *tag, ns1__ReturnMatrixDataTypeBG *a, const char *type)
{
  (void)tag; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (ns1__ReturnMatrixDataTypeBG *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ReturnMatrixDataTypeBG, sizeof(ns1__ReturnMatrixDataTypeBG), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
  if (!a)
    return NULL;
  if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ReturnMatrixDataTypeBG)
  {
    soap_revert(soap);
    *soap->id = '\0';
    return (ns1__ReturnMatrixDataTypeBG *)a->soap_in(soap, tag, type);
  }
  if (soap->alloced)
    a->soap_default(soap);
  size_t soap_flag_responseInfoHeader1 = 1;
  if (soap->body && *soap->href != '#')
  {
    for (;;)
    {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_responseInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", &a->ns1__ReturnMatrixDataTypeBG::responseInfoHeader, "ns1:ResponseInfoHeaderType"))
        {
          soap_flag_responseInfoHeader1--;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_std__vectorTemplateOfPointerTons1__DataItemRow(soap, "returnMatrix", &a->ns1__ReturnMatrixDataTypeBG::returnMatrix, "ns1:DataItemRow"))
          continue;
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
    if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__ReturnMatrixDataTypeBG::responseInfoHeader))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }
  }
  else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
  {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  else
  {
    a = (ns1__ReturnMatrixDataTypeBG *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ReturnMatrixDataTypeBG, SOAP_TYPE_ns1__ReturnMatrixDataTypeBG, sizeof(ns1__ReturnMatrixDataTypeBG), 0, soap_finsert, soap_fbase);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

/*-----------------[ soap_instantiate_ns1__ReturnMatrixDataTypeBG ]---------*/
SOAP_FMAC1 ns1__ReturnMatrixDataTypeBG * SOAP_FMAC2 soap_instantiate_ns1__ReturnMatrixDataTypeBG(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ReturnMatrixDataTypeBG(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
  (void)type; (void)arrayType; /* appease -Wall -Werror */
  ns1__ReturnMatrixDataTypeBG *p;
  size_t k = sizeof(ns1__ReturnMatrixDataTypeBG);
  if (n < 0)
  {
    p = SOAP_NEW(ns1__ReturnMatrixDataTypeBG);
    if (p)
      ((ns1__ReturnMatrixDataTypeBG*)p)->soap = soap;
  }
  else
  {
    p = SOAP_NEW_ARRAY(ns1__ReturnMatrixDataTypeBG, n);
    k *= n;
    if (p)
      for (int i = 0; i < n; i++)
        ((ns1__ReturnMatrixDataTypeBG*)p)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ReturnMatrixDataTypeBG location=%p n=%d\n", (void*)p, n));
  soap_link(soap, p, SOAP_TYPE_ns1__ReturnMatrixDataTypeBG, n, soap_fdelete);
  if (size)
    *size = k;
  return p;
}

/*--------------------------[ soap_put ]-----------------------------------*/
int ns1__ReturnMatrixDataTypeBG::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
  if (soap_out_ns1__ReturnMatrixDataTypeBG(soap, tag ? tag : "ns1:ReturnMatrixDataTypeBG", -2, this, type))
    return soap->error;
  return soap_putindependent(soap);
}

/*--------------------------[ soap_get ]-----------------------------------*/
void *ns1__ReturnMatrixDataTypeBG::soap_get(struct soap *soap, const char *tag, const char *type)
{
  return soap_get_ns1__ReturnMatrixDataTypeBG(soap, this, tag, type);
}

/*--------------------------[ soap_get_ns1__ReturnMatrixDataTypeBG ]-------*/
SOAP_FMAC3 ns1__ReturnMatrixDataTypeBG * SOAP_FMAC4 soap_get_ns1__ReturnMatrixDataTypeBG(struct soap *soap, ns1__ReturnMatrixDataTypeBG *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns1__ReturnMatrixDataTypeBG(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

/*--------------------------[ soap_dealloc ]-------------------------------*/
void ns1__ReturnMatrixDataTypeBG::soap_dealloc()
{
  for(unsigned int i=0; i<returnMatrix.size(); i++)
  {
    //char address[20];
    returnMatrix[i]->soap_dealloc();
    //er_sprintf(address, "%p", returnMatrix[i]);
    //soap_obj_log_d << "ns1__ReturnMatrixDataTypeBG::soap_dealloc - delete " << address << ")" << LOG_TERMINATOR;
    delete []returnMatrix[i];
  }
  returnMatrix.clear();
}


//============[ ns1__ReturnMatrixDataTypePerSuperGroup::Implemented Methods ]=====
/*--------------------------[ soap_default ]-------------------------------*/
void ns1__ReturnMatrixDataTypePerSuperGroup::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ReturnMatrixDataTypePerSuperGroup::responseInfoHeader = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__returnDataRowsPerSuperGroup(soap, &this->ns1__ReturnMatrixDataTypePerSuperGroup::returnDataRowsPerSuperGroup);
	/* transient soap skipped */
}

/*--------------------------[ soap_serialize ]----------------------------------*/
void ns1__ReturnMatrixDataTypePerSuperGroup::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ResponseInfoHeaderType(soap, &this->ns1__ReturnMatrixDataTypePerSuperGroup::responseInfoHeader);
	soap_serialize_std__vectorTemplateOfPointerTons1__returnDataRowsPerSuperGroup(soap, &this->ns1__ReturnMatrixDataTypePerSuperGroup::returnDataRowsPerSuperGroup);
#endif
}

/*--------------------------[ soap_out ]-----------------------------------------*/
int ns1__ReturnMatrixDataTypePerSuperGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ReturnMatrixDataTypePerSuperGroup(soap, tag, id, this, type);
}

/*--------------------------[ soap_out_ns1__ReturnMatrixDataTypePerSuperGroup ]---*/
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ReturnMatrixDataTypePerSuperGroup(struct soap *soap, const char *tag, int id, const ns1__ReturnMatrixDataTypePerSuperGroup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ReturnMatrixDataTypePerSuperGroup), type))
		return soap->error;
	if (!a->ns1__ReturnMatrixDataTypePerSuperGroup::responseInfoHeader)
	{	if (soap_element_empty(soap, "responseInfoHeader"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", -1, &a->ns1__ReturnMatrixDataTypePerSuperGroup::responseInfoHeader, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__returnDataRowsPerSuperGroup(soap, "returnDataRowsPerSuperGroup", -1, &a->ns1__ReturnMatrixDataTypePerSuperGroup::returnDataRowsPerSuperGroup, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

/*--------------------------[ soap_in ]-------------------------------------*/
void *ns1__ReturnMatrixDataTypePerSuperGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ReturnMatrixDataTypePerSuperGroup(soap, tag, this, type);
}

/*--------------------------[ soap_in_ns1__ReturnMatrixDataTypePerSuperGroup ]-----*/
SOAP_FMAC3 ns1__ReturnMatrixDataTypePerSuperGroup * SOAP_FMAC4 soap_in_ns1__ReturnMatrixDataTypePerSuperGroup(struct soap *soap, const char *tag, ns1__ReturnMatrixDataTypePerSuperGroup *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ReturnMatrixDataTypePerSuperGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ReturnMatrixDataTypePerSuperGroup, sizeof(ns1__ReturnMatrixDataTypePerSuperGroup), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ReturnMatrixDataTypePerSuperGroup)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ReturnMatrixDataTypePerSuperGroup *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_responseInfoHeader1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_responseInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", &a->ns1__ReturnMatrixDataTypePerSuperGroup::responseInfoHeader, "ns1:ResponseInfoHeaderType"))
				{	soap_flag_responseInfoHeader1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__returnDataRowsPerSuperGroup(soap, "returnDataRowsPerSuperGroup", &a->ns1__ReturnMatrixDataTypePerSuperGroup::returnDataRowsPerSuperGroup, "ns1:returnDataRowsPerSuperGroup"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__ReturnMatrixDataTypePerSuperGroup::responseInfoHeader || a->ns1__ReturnMatrixDataTypePerSuperGroup::returnDataRowsPerSuperGroup.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ReturnMatrixDataTypePerSuperGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ReturnMatrixDataTypePerSuperGroup, SOAP_TYPE_ns1__ReturnMatrixDataTypePerSuperGroup, sizeof(ns1__ReturnMatrixDataTypePerSuperGroup), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

/*--------------------------[ soap_instantiate_ns1__ReturnMatrixDataTypePerSuperGroup ]-----*/
SOAP_FMAC1 ns1__ReturnMatrixDataTypePerSuperGroup * SOAP_FMAC2 soap_instantiate_ns1__ReturnMatrixDataTypePerSuperGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ReturnMatrixDataTypePerSuperGroup(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ReturnMatrixDataTypePerSuperGroup *p;
	size_t k = sizeof(ns1__ReturnMatrixDataTypePerSuperGroup);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ReturnMatrixDataTypePerSuperGroup);
		if (p)
			((ns1__ReturnMatrixDataTypePerSuperGroup*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ReturnMatrixDataTypePerSuperGroup, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ReturnMatrixDataTypePerSuperGroup*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ReturnMatrixDataTypePerSuperGroup location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__ReturnMatrixDataTypePerSuperGroup, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

/*--------------------------[ soap_put ]-----------------------------------*/
int ns1__ReturnMatrixDataTypePerSuperGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ReturnMatrixDataTypePerSuperGroup(soap, tag ? tag : "ns1:ReturnMatrixDataTypePerSuperGroup", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

/*--------------------------[ soap_get ]-----------------------------------*/
void *ns1__ReturnMatrixDataTypePerSuperGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ReturnMatrixDataTypePerSuperGroup(soap, this, tag, type);
}

/*--------------------------[ ns1__ReturnMatrixDataTypePerSuperGroup ]-----*/
SOAP_FMAC3 ns1__ReturnMatrixDataTypePerSuperGroup * SOAP_FMAC4 soap_get_ns1__ReturnMatrixDataTypePerSuperGroup(struct soap *soap, ns1__ReturnMatrixDataTypePerSuperGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ReturnMatrixDataTypePerSuperGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

/*--------------------------[ soap_dealloc ]-------------------------------*/
void ns1__ReturnMatrixDataTypePerSuperGroup::soap_dealloc()
{
  for(unsigned int i=0; i<returnDataRowsPerSuperGroup.size(); i++)
  {
    //char address[20];
    returnDataRowsPerSuperGroup[i]->soap_dealloc();
    //er_sprintf(address, "%p", returnDataRowsPerSuperGroup[i]);
    //soap_obj_log_d << "ns1__ReturnMatrixDataTypePerSuperGroup::soap_dealloc - delete " << address << ")" << LOG_TERMINATOR;
    delete []returnDataRowsPerSuperGroup[i];
  }
  returnDataRowsPerSuperGroup.clear();
}


//============[ ns1__ReturnMatrixDataTypePerGroup::Implemented Methods ]=====
/*--------------------------[ soap_default ]-------------------------------*/
void ns1__returnDataRowsPerSuperGroup::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_unsignedInt(soap, &this->ns1__returnDataRowsPerSuperGroup::Id);
	soap_default_std__string(soap, &this->ns1__returnDataRowsPerSuperGroup::Name);
	soap_default_std__vectorTemplateOfPointerTons1__DataItemRow(soap, &this->ns1__returnDataRowsPerSuperGroup::returnMatrix);
	/* transient soap skipped */
}

/*--------------------------[ soap_serialize ]-----------------------------*/
void ns1__returnDataRowsPerSuperGroup::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__returnDataRowsPerSuperGroup::Id, SOAP_TYPE_unsignedInt);
	soap_serialize_std__string(soap, &this->ns1__returnDataRowsPerSuperGroup::Name);
	soap_serialize_std__vectorTemplateOfPointerTons1__DataItemRow(soap, &this->ns1__returnDataRowsPerSuperGroup::returnMatrix);
#endif
}

/*--------------------------[ soap_out ]-----------------------------------*/
int ns1__returnDataRowsPerSuperGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__returnDataRowsPerSuperGroup(soap, tag, id, this, type);
}

/*--------------------------[ soap_out_ns1__returnDataRowsPerSuperGroup ]--*/
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__returnDataRowsPerSuperGroup(struct soap *soap, const char *tag, int id, const ns1__returnDataRowsPerSuperGroup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__returnDataRowsPerSuperGroup), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "Id", -1, &a->ns1__returnDataRowsPerSuperGroup::Id, ""))
		return soap->error;
	if (soap_out_std__string(soap, "Name", -1, &a->ns1__returnDataRowsPerSuperGroup::Name, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__DataItemRow(soap, "returnMatrix", -1, &a->ns1__returnDataRowsPerSuperGroup::returnMatrix, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

/*--------------------------[ soap_in ]------------------------------------*/
void *ns1__returnDataRowsPerSuperGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__returnDataRowsPerSuperGroup(soap, tag, this, type);
}

/*--------------------------[ soap_in_ns1__returnDataRowsPerSuperGroup ]---*/
SOAP_FMAC3 ns1__returnDataRowsPerSuperGroup * SOAP_FMAC4 soap_in_ns1__returnDataRowsPerSuperGroup(struct soap *soap, const char *tag, ns1__returnDataRowsPerSuperGroup *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__returnDataRowsPerSuperGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__returnDataRowsPerSuperGroup, sizeof(ns1__returnDataRowsPerSuperGroup), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__returnDataRowsPerSuperGroup)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__returnDataRowsPerSuperGroup *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Name1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "Id", &a->ns1__returnDataRowsPerSuperGroup::Id, "xsd:unsignedInt"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "Name", &a->ns1__returnDataRowsPerSuperGroup::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__DataItemRow(soap, "returnMatrix", &a->ns1__returnDataRowsPerSuperGroup::returnMatrix, "ns1:DataItemRow"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_Name1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__returnDataRowsPerSuperGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__returnDataRowsPerSuperGroup, SOAP_TYPE_ns1__returnDataRowsPerSuperGroup, sizeof(ns1__returnDataRowsPerSuperGroup), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

/*--------------------------[ soap_instantiate_ns1__returnDataRowsPerSuperGroup ]--*/
SOAP_FMAC1 ns1__returnDataRowsPerSuperGroup * SOAP_FMAC2 soap_instantiate_ns1__returnDataRowsPerSuperGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__returnDataRowsPerSuperGroup(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__returnDataRowsPerSuperGroup *p;
	size_t k = sizeof(ns1__returnDataRowsPerSuperGroup);
	if (n < 0)
	{	p = SOAP_NEW(ns1__returnDataRowsPerSuperGroup);
		if (p)
			((ns1__returnDataRowsPerSuperGroup*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__returnDataRowsPerSuperGroup, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__returnDataRowsPerSuperGroup*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__returnDataRowsPerSuperGroup location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__returnDataRowsPerSuperGroup, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

/*--------------------------[ soap_put ]------------------------------------*/
int ns1__returnDataRowsPerSuperGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__returnDataRowsPerSuperGroup(soap, tag ? tag : "ns1:returnDataRowsPerSuperGroup", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

/*--------------------------[ soap_get ]------------------------------------*/
void *ns1__returnDataRowsPerSuperGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__returnDataRowsPerSuperGroup(soap, this, tag, type);
}

/*--------------------------[ soap_get_ns1__returnDataRowsPerSuperGroup ]---*/
SOAP_FMAC3 ns1__returnDataRowsPerSuperGroup * SOAP_FMAC4 soap_get_ns1__returnDataRowsPerSuperGroup(struct soap *soap, ns1__returnDataRowsPerSuperGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__returnDataRowsPerSuperGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

/*--------------------------[ soap_dealloc ]--------------------------------*/
void ns1__returnDataRowsPerSuperGroup::soap_dealloc()
{
  for(unsigned int i=0; i<returnMatrix.size(); i++)
  {
    //char address[20];
    returnMatrix[i]->soap_dealloc();
    //er_sprintf(address, "%p", returnMatrix[i]);
    //soap_obj_log_d << "ns1__returnDataRowsPerSuperGroup::soap_dealloc - delete " << address << ")" << LOG_TERMINATOR;
    delete []returnMatrix[i];
  }
  returnMatrix.clear();
}



//============[ ns1__ReturnMatrixDataTypePerGroup::Implemented Methods ]=====
//ctor
ns1__ReturnMatrixDataTypePerGroup::ns1__ReturnMatrixDataTypePerGroup(): responseInfoHeader(), returnDataRowsPerGroup(), soap()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ctor of ns1__ReturnMatrixDataTypePerGroup(" << address << ")" << LOG_TERMINATOR;
  ////DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__ReturnArrayDataType(addr:%s)\n", address));
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__ReturnMatrixDataTypePerGroup(addr:%p)\n", (void*)this));
}

//dtor
ns1__ReturnMatrixDataTypePerGroup::~ns1__ReturnMatrixDataTypePerGroup()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "dtor of ns1__ReturnMatrixDataTypePerGroup(" << address << ")" << LOG_TERMINATOR;
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "dtor ns1__ReturnMatrixDataTypePerGroup(addr:%p)\n", (void*)this));
}

/*--------------------------[ soap_default ]-------------------------------*/
void ns1__ReturnMatrixDataTypePerGroup::soap_default(struct soap *soap)
{
  this->soap = soap;
  this->ns1__ReturnMatrixDataTypePerGroup::responseInfoHeader = NULL;
  soap_default_std__vectorTemplateOfPointerTons1__returnDataRowsPerGroup(soap, &this->ns1__ReturnMatrixDataTypePerGroup::returnDataRowsPerGroup);
  /* transient soap skipped */
}

/*--------------------------[ soap_serialize ]-----------------------------*/
void ns1__ReturnMatrixDataTypePerGroup::soap_serialize(struct soap *soap) const
{
  (void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
  soap_serialize_PointerTons1__ResponseInfoHeaderType(soap, &this->ns1__ReturnMatrixDataTypePerGroup::responseInfoHeader);
  soap_serialize_std__vectorTemplateOfPointerTons1__returnDataRowsPerGroup(soap, &this->ns1__ReturnMatrixDataTypePerGroup::returnDataRowsPerGroup);
#endif
}

/*--------------------------[ soap_out ]-----------------------------------*/
int ns1__ReturnMatrixDataTypePerGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
  return soap_out_ns1__ReturnMatrixDataTypePerGroup(soap, tag, id, this, type);
}

/*--------------------[ soap_out_ns1__ReturnMatrixDataTypePerGroup ]-------*/
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ReturnMatrixDataTypePerGroup(struct soap *soap, const char *tag, int id, const ns1__ReturnMatrixDataTypePerGroup *a, const char *type)
{
  (void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ReturnMatrixDataTypePerGroup), type))
    return soap->error;
  if (!a->ns1__ReturnMatrixDataTypePerGroup::responseInfoHeader)
  {
    if (soap_element_empty(soap, "responseInfoHeader"))
      return soap->error;
  }
  else
    if (soap_out_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", -1, &a->ns1__ReturnMatrixDataTypePerGroup::responseInfoHeader, ""))
      return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__returnDataRowsPerGroup(soap, "returnDataRowsPerGroup", -1, &a->ns1__ReturnMatrixDataTypePerGroup::returnDataRowsPerGroup, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

/*--------------------------[ soap_in ]------------------------------------*/
void *ns1__ReturnMatrixDataTypePerGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{
  return soap_in_ns1__ReturnMatrixDataTypePerGroup(soap, tag, this, type);
}

/*--------------------[ soap_in_ns1__ReturnMatrixDataTypePerGroup ]--------*/
SOAP_FMAC3 ns1__ReturnMatrixDataTypePerGroup * SOAP_FMAC4 soap_in_ns1__ReturnMatrixDataTypePerGroup(struct soap *soap, const char *tag, ns1__ReturnMatrixDataTypePerGroup *a, const char *type)
{
  (void)tag; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (ns1__ReturnMatrixDataTypePerGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ReturnMatrixDataTypePerGroup, sizeof(ns1__ReturnMatrixDataTypePerGroup), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
  if (!a)
    return NULL;
  if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ReturnMatrixDataTypePerGroup)
  {
    soap_revert(soap);
    *soap->id = '\0';
    return (ns1__ReturnMatrixDataTypePerGroup *)a->soap_in(soap, tag, type);
  }
  if (soap->alloced)
    a->soap_default(soap);
  size_t soap_flag_responseInfoHeader1 = 1;
  if (soap->body && *soap->href != '#')
  {
    for (;;)
    {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_responseInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", &a->ns1__ReturnMatrixDataTypePerGroup::responseInfoHeader, "ns1:ResponseInfoHeaderType"))
        {
          soap_flag_responseInfoHeader1--;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_std__vectorTemplateOfPointerTons1__returnDataRowsPerGroup(soap, "returnDataRowsPerGroup", &a->ns1__ReturnMatrixDataTypePerGroup::returnDataRowsPerGroup, "ns1:returnDataRowsPerGroup"))
          continue;
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
    if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__ReturnMatrixDataTypePerGroup::responseInfoHeader || a->ns1__ReturnMatrixDataTypePerGroup::returnDataRowsPerGroup.size() < 1))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }
  }
  else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
  {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  else
  {
    a = (ns1__ReturnMatrixDataTypePerGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ReturnMatrixDataTypePerGroup, SOAP_TYPE_ns1__ReturnMatrixDataTypePerGroup, sizeof(ns1__ReturnMatrixDataTypePerGroup), 0, soap_finsert, soap_fbase);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

/*-----------------[ soap_instantiate_ns1__ReturnMatrixDataTypePerGroup ]---*/
SOAP_FMAC1 ns1__ReturnMatrixDataTypePerGroup * SOAP_FMAC2 soap_instantiate_ns1__ReturnMatrixDataTypePerGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ReturnMatrixDataTypePerGroup(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
  (void)type; (void)arrayType; /* appease -Wall -Werror */
  ns1__ReturnMatrixDataTypePerGroup *p;
  size_t k = sizeof(ns1__ReturnMatrixDataTypePerGroup);
  if (n < 0)
  {
    p = SOAP_NEW(ns1__ReturnMatrixDataTypePerGroup);
    if (p)
      ((ns1__ReturnMatrixDataTypePerGroup*)p)->soap = soap;
  }
  else
  {
    p = SOAP_NEW_ARRAY(ns1__ReturnMatrixDataTypePerGroup, n);
    k *= n;
    if (p)
      for (int i = 0; i < n; i++)
        ((ns1__ReturnMatrixDataTypePerGroup*)p)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ReturnMatrixDataTypePerGroup location=%p n=%d\n", (void*)p, n));
  soap_link(soap, p, SOAP_TYPE_ns1__ReturnMatrixDataTypePerGroup, n, soap_fdelete);
  if (size)
    *size = k;
  return p;
}

/*--------------------------[ soap_put ]-----------------------------------*/
int ns1__ReturnMatrixDataTypePerGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
  if (soap_out_ns1__ReturnMatrixDataTypePerGroup(soap, tag ? tag : "ns1:ReturnMatrixDataTypePerGroup", -2, this, type))
    return soap->error;
  return soap_putindependent(soap);
}

/*--------------------------[ soap_get ]-----------------------------------*/
void *ns1__ReturnMatrixDataTypePerGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
  return soap_get_ns1__ReturnMatrixDataTypePerGroup(soap, this, tag, type);
}

/*--------------------[ soap_get_ns1__ReturnMatrixDataTypePerGroup ]-------*/
SOAP_FMAC3 ns1__ReturnMatrixDataTypePerGroup * SOAP_FMAC4 soap_get_ns1__ReturnMatrixDataTypePerGroup(struct soap *soap, ns1__ReturnMatrixDataTypePerGroup *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns1__ReturnMatrixDataTypePerGroup(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

/*--------------------------[ soap_dealloc ]-------------------------------*/
void ns1__ReturnMatrixDataTypePerGroup::soap_dealloc()
{
  for(unsigned int i=0; i<returnDataRowsPerGroup.size(); i++)
  {
    //char address[20];
    returnDataRowsPerGroup[i]->soap_dealloc();
    //er_sprintf(address, "%p", returnDataRowsPerGroup[i]);
    //soap_obj_log_d << "ns1__ReturnMatrixDataTypePerGroup::soap_dealloc - delete " << address << ")" << LOG_TERMINATOR;
    delete []returnDataRowsPerGroup[i];
  }
  returnDataRowsPerGroup.clear();
}


//====================[ ns1__returnDataRowsPerGroup::Implemented Methods ]======
//ctor
ns1__returnDataRowsPerGroup::ns1__returnDataRowsPerGroup():  Id(), Name(), returnMatrix(), soap()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ctor of ns1__returnDataRowsPerGroup(" << address << ")" << LOG_TERMINATOR;
  ////DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__returnDataRowsPerGroup(addr:%s)\n", address));
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__returnDataRowsPerGroup(addr:%p)\n", (void*)this));
}

//dtor
ns1__returnDataRowsPerGroup::~ns1__returnDataRowsPerGroup()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "dtor of ns1__returnDataRowsPerGroup(" << address << ")" << LOG_TERMINATOR;
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "dtor ns1__returnDataRowsPerGroup(addr:%p)\n", (void*)this));
}

/*--------------------------[ soap_default ]-------------------------------*/
void ns1__returnDataRowsPerGroup::soap_default(struct soap *soap)
{
  this->soap = soap;
  soap_default_unsignedInt(soap, &this->ns1__returnDataRowsPerGroup::Id);
  soap_default_std__string(soap, &this->ns1__returnDataRowsPerGroup::Name);
  soap_default_std__vectorTemplateOfPointerTons1__DataItemRow(soap, &this->ns1__returnDataRowsPerGroup::returnMatrix);
  /* transient soap skipped */
}

/*--------------------------[ soap_serialize ]-----------------------------*/
void ns1__returnDataRowsPerGroup::soap_serialize(struct soap *soap) const
{
  (void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
  soap_embedded(soap, &this->ns1__returnDataRowsPerGroup::Id, SOAP_TYPE_unsignedInt);
  soap_serialize_std__string(soap, &this->ns1__returnDataRowsPerGroup::Name);
  soap_serialize_std__vectorTemplateOfPointerTons1__DataItemRow(soap, &this->ns1__returnDataRowsPerGroup::returnMatrix);
#endif
}

/*--------------------------[ soap_out ]-----------------------------------*/
int ns1__returnDataRowsPerGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
  return soap_out_ns1__returnDataRowsPerGroup(soap, tag, id, this, type);
}

/*--------------------------[ soap_out_ns1__returnDataRowsPerGroup ]-------*/
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__returnDataRowsPerGroup(struct soap *soap, const char *tag, int id, const ns1__returnDataRowsPerGroup *a, const char *type)
{
  (void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__returnDataRowsPerGroup), type))
    return soap->error;
  if (soap_out_unsignedInt(soap, "Id", -1, &a->ns1__returnDataRowsPerGroup::Id, ""))
    return soap->error;
  if (soap_out_std__string(soap, "Name", -1, &a->ns1__returnDataRowsPerGroup::Name, ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__DataItemRow(soap, "returnMatrix", -1, &a->ns1__returnDataRowsPerGroup::returnMatrix, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

/*--------------------------[ soap_in ]------------------------------------*/
void *ns1__returnDataRowsPerGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{
  return soap_in_ns1__returnDataRowsPerGroup(soap, tag, this, type);
}

/*--------------------------[ soap_in_ns1__returnDataRowsPerGroup ]--------*/
SOAP_FMAC3 ns1__returnDataRowsPerGroup * SOAP_FMAC4 soap_in_ns1__returnDataRowsPerGroup(struct soap *soap, const char *tag, ns1__returnDataRowsPerGroup *a, const char *type)
{
  (void)tag; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (ns1__returnDataRowsPerGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__returnDataRowsPerGroup, sizeof(ns1__returnDataRowsPerGroup), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
  if (!a)
    return NULL;
  if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__returnDataRowsPerGroup)
  {
    soap_revert(soap);
    *soap->id = '\0';
    return (ns1__returnDataRowsPerGroup *)a->soap_in(soap, tag, type);
  }
  if (soap->alloced)
    a->soap_default(soap);
  size_t soap_flag_Id1 = 1;
  size_t soap_flag_Name1 = 1;
  if (soap->body && *soap->href != '#')
  {
    for (;;)
    {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_unsignedInt(soap, "Id", &a->ns1__returnDataRowsPerGroup::Id, "xsd:unsignedInt"))
        {
          soap_flag_Id1--;
          continue;
        }
      }
      if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
      {
        if (soap_in_std__string(soap, "Name", &a->ns1__returnDataRowsPerGroup::Name, "xsd:string"))
        {
          soap_flag_Name1--;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_std__vectorTemplateOfPointerTons1__DataItemRow(soap, "returnMatrix", &a->ns1__returnDataRowsPerGroup::returnMatrix, "ns1:DataItemRow"))
          continue;
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_Name1 > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }
  }
  else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
  {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  else
  {
    a = (ns1__returnDataRowsPerGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__returnDataRowsPerGroup, SOAP_TYPE_ns1__returnDataRowsPerGroup, sizeof(ns1__returnDataRowsPerGroup), 0, soap_finsert, soap_fbase);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

/*--------------------------[ soap_instantiate_ns1__returnDataRowsPerGroup ]--*/
SOAP_FMAC1 ns1__returnDataRowsPerGroup * SOAP_FMAC2 soap_instantiate_ns1__returnDataRowsPerGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__returnDataRowsPerGroup(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
  (void)type; (void)arrayType; /* appease -Wall -Werror */
  ns1__returnDataRowsPerGroup *p;
  size_t k = sizeof(ns1__returnDataRowsPerGroup);
  if (n < 0)
  {
    p = SOAP_NEW(ns1__returnDataRowsPerGroup);
    if (p)
      ((ns1__returnDataRowsPerGroup*)p)->soap = soap;
  }
  else
  {
    p = SOAP_NEW_ARRAY(ns1__returnDataRowsPerGroup, n);
    k *= n;
    if (p)
      for (int i = 0; i < n; i++)
        ((ns1__returnDataRowsPerGroup*)p)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__returnDataRowsPerGroup location=%p n=%d\n", (void*)p, n));
  soap_link(soap, p, SOAP_TYPE_ns1__returnDataRowsPerGroup, n, soap_fdelete);
  if (size)
    *size = k;
  return p;
}

/*--------------------------[ soap_put ]-----------------------------------*/
int ns1__returnDataRowsPerGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
  if (soap_out_ns1__returnDataRowsPerGroup(soap, tag ? tag : "ns1:returnDataRowsPerGroup", -2, this, type))
    return soap->error;
  return soap_putindependent(soap);
}

/*--------------------------[ soap_get ]-----------------------------------*/
void *ns1__returnDataRowsPerGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
  return soap_get_ns1__returnDataRowsPerGroup(soap, this, tag, type);
}

/*--------------------------[ soap_get_ns1__returnDataRowsPerGroup ]-------*/
SOAP_FMAC3 ns1__returnDataRowsPerGroup * SOAP_FMAC4 soap_get_ns1__returnDataRowsPerGroup(struct soap *soap, ns1__returnDataRowsPerGroup *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns1__returnDataRowsPerGroup(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

/*--------------------------[ soap_dealloc ]-------------------------------*/
void ns1__returnDataRowsPerGroup::soap_dealloc()
{
  for(unsigned int i=0; i<returnMatrix.size(); i++)
  {
    //char address[20];
    returnMatrix[i]->soap_dealloc();
    //er_sprintf(address, "%p", returnMatrix[i]);
    //soap_obj_log_d << "ns1__returnDataRowsPerGroup::soap_dealloc - delete " << address << ")" << LOG_TERMINATOR;
    delete []returnMatrix[i];
  }
  returnMatrix.clear();
}



//====================[ ns1__ReturnArrayDataType::Implemented Methods ]======
//ctor
ns1__ReturnArrayDataType::ns1__ReturnArrayDataType():  responseInfoHeader(), returnArrayOfBlocks(), soap()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ctor of ns1__ReturnArrayDataType(" << address << ")" << LOG_TERMINATOR;
  ////DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__ReturnArrayDataType(addr:%s)\n", address));
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__ReturnArrayDataType(addr:%p)\n", (void*)this));
}

//dtor
ns1__ReturnArrayDataType::~ns1__ReturnArrayDataType()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "dtor of ns1__ReturnArrayDataType(" << address << ")" << LOG_TERMINATOR;
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "dtor ns1__ReturnArrayDataType(addr:%p)\n", (void*)this));
}

/*--------------------------[ soap_default ]-------------------------------*/
void ns1__ReturnArrayDataType::soap_default(struct soap *soap)
{
  this->soap = soap;
  this->ns1__ReturnArrayDataType::responseInfoHeader = NULL;
  soap_default_std__vectorTemplateOfPointerTons1__BlockItemType(soap, &this->ns1__ReturnArrayDataType::returnArrayOfBlocks);
  /* transient soap skipped */
}

/*--------------------------[ soap_serialize ]-----------------------------*/
void ns1__ReturnArrayDataType::soap_serialize(struct soap *soap) const
{
  (void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
  soap_serialize_PointerTons1__ResponseInfoHeaderType(soap, &this->ns1__ReturnArrayDataType::responseInfoHeader);
  soap_serialize_std__vectorTemplateOfPointerTons1__BlockItemType(soap, &this->ns1__ReturnArrayDataType::returnArrayOfBlocks);
#endif
}

/*--------------------------[ soap_out ]-----------------------------------*/
int ns1__ReturnArrayDataType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
  return soap_out_ns1__ReturnArrayDataType(soap, tag, id, this, type);
}

/*--------------------------[ soap_out_ns1__ReturnArrayDataType ]----------*/
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ReturnArrayDataType(struct soap *soap, const char *tag, int id, const ns1__ReturnArrayDataType *a, const char *type)
{
  (void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ReturnArrayDataType), type))
    return soap->error;
  if (!a->ns1__ReturnArrayDataType::responseInfoHeader)
  {
    if (soap_element_empty(soap, "responseInfoHeader"))
      return soap->error;
  }
  else
    if (soap_out_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", -1, &a->ns1__ReturnArrayDataType::responseInfoHeader, ""))
      return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__BlockItemType(soap, "returnArrayOfBlocks", -1, &a->ns1__ReturnArrayDataType::returnArrayOfBlocks, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

/*--------------------------[ soap_in ]------------------------------------*/
void *ns1__ReturnArrayDataType::soap_in(struct soap *soap, const char *tag, const char *type)
{
  return soap_in_ns1__ReturnArrayDataType(soap, tag, this, type);
}

/*--------------------------[ soap_in_ns1__ReturnArrayDataType ]-----------*/
SOAP_FMAC3 ns1__ReturnArrayDataType * SOAP_FMAC4 soap_in_ns1__ReturnArrayDataType(struct soap *soap, const char *tag, ns1__ReturnArrayDataType *a, const char *type)
{
  (void)tag; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (ns1__ReturnArrayDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ReturnArrayDataType, sizeof(ns1__ReturnArrayDataType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
  if (!a)
    return NULL;
  if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ReturnArrayDataType)
  {
    soap_revert(soap);
    *soap->id = '\0';
    return (ns1__ReturnArrayDataType *)a->soap_in(soap, tag, type);
  }
  if (soap->alloced)
    a->soap_default(soap);
  size_t soap_flag_responseInfoHeader1 = 1;
  if (soap->body && *soap->href != '#')
  {
    for (;;)
    {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_responseInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_PointerTons1__ResponseInfoHeaderType(soap, "responseInfoHeader", &a->ns1__ReturnArrayDataType::responseInfoHeader, "ns1:ResponseInfoHeaderType"))
        {
          soap_flag_responseInfoHeader1--;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_std__vectorTemplateOfPointerTons1__BlockItemType(soap, "returnArrayOfBlocks", &a->ns1__ReturnArrayDataType::returnArrayOfBlocks, "ns1:BlockItemType"))
          continue;
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
    if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__ReturnArrayDataType::responseInfoHeader || a->ns1__ReturnArrayDataType::returnArrayOfBlocks.size() < 1))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }
  }
  else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
  {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  else
  {
    a = (ns1__ReturnArrayDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ReturnArrayDataType, SOAP_TYPE_ns1__ReturnArrayDataType, sizeof(ns1__ReturnArrayDataType), 0, soap_finsert, soap_fbase);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

/*--------------------------[ soap_instantiate_ns1__ReturnArrayDataType ]--*/
SOAP_FMAC1 ns1__ReturnArrayDataType * SOAP_FMAC2 soap_instantiate_ns1__ReturnArrayDataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ReturnArrayDataType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
  (void)type; (void)arrayType; /* appease -Wall -Werror */
  ns1__ReturnArrayDataType *p;
  size_t k = sizeof(ns1__ReturnArrayDataType);
  if (n < 0)
  {
    p = SOAP_NEW(ns1__ReturnArrayDataType);
    if (p)
      ((ns1__ReturnArrayDataType*)p)->soap = soap;
  }
  else
  {
    p = SOAP_NEW_ARRAY(ns1__ReturnArrayDataType, n);
    k *= n;
    if (p)
      for (int i = 0; i < n; i++)
        ((ns1__ReturnArrayDataType*)p)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ReturnArrayDataType location=%p n=%d\n", (void*)p, n));
  soap_link(soap, p, SOAP_TYPE_ns1__ReturnArrayDataType, n, soap_fdelete);
  if (size)
    *size = k;
  return p;
}

/*--------------------------[ soap_put ]-----------------------------------*/
int ns1__ReturnArrayDataType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
  if (soap_out_ns1__ReturnArrayDataType(soap, tag ? tag : "ns1:ReturnArrayDataType", -2, this, type))
    return soap->error;
  return soap_putindependent(soap);
}

/*--------------------------[ soap_get ]-----------------------------------*/
void *ns1__ReturnArrayDataType::soap_get(struct soap *soap, const char *tag, const char *type)
{
  return soap_get_ns1__ReturnArrayDataType(soap, this, tag, type);
}

/*--------------------------[ soap_get_ns1__ReturnArrayDataType ]----------*/
SOAP_FMAC3 ns1__ReturnArrayDataType * SOAP_FMAC4 soap_get_ns1__ReturnArrayDataType(struct soap *soap, ns1__ReturnArrayDataType *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns1__ReturnArrayDataType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

/*--------------------------[ soap_dealloc ]-------------------------------*/
void ns1__ReturnArrayDataType::soap_dealloc()
{
  for(unsigned int i=0; i<returnArrayOfBlocks.size(); i++)
  {
    //char address[20];
    returnArrayOfBlocks[i]->soap_dealloc();
    //er_sprintf(address, "%p", returnArrayOfBlocks[i]);
    //soap_obj_log_d << "ns1__ReturnArrayDataType::soap_dealloc - delete " << address << ")" << LOG_TERMINATOR;
    delete []returnArrayOfBlocks[i];
  }
  returnArrayOfBlocks.clear();
}



//====================[ ns1__BlockItemType::Implemented Methods ]============
//ctor
ns1__BlockItemType::ns1__BlockItemType():  Id(), Name(), returnArray(), soap()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ctor of ns1__BlockItemType(" << address << ")" << LOG_TERMINATOR;
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__BlockItemType(addr:%s)\n", address));
  ////DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__BlockItemType(addr:%p)\n", (void*)this));
}

//dtor
ns1__BlockItemType::~ns1__BlockItemType()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "dtor of ns1__BlockItemType(" << address << ")" << LOG_TERMINATOR;
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "dtor ns1__BlockItemType(addr:%p)\n", (void*)this));
}

/*--------------------------[ soap_default ]-------------------------------*/
void ns1__BlockItemType::soap_default(struct soap *soap)
{
  this->soap = soap;
  soap_default_unsignedInt(soap, &this->ns1__BlockItemType::Id);
  soap_default_std__string(soap, &this->ns1__BlockItemType::Name);
  soap_default_std__vectorTemplateOfPointerTons1__DataItemType(soap, &this->ns1__BlockItemType::returnArray);
  /* transient soap skipped */
}

/*--------------------------[ soap_serialize ]-----------------------------*/
void ns1__BlockItemType::soap_serialize(struct soap *soap) const
{
  (void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
  soap_embedded(soap, &this->ns1__BlockItemType::Id, SOAP_TYPE_unsignedInt);
  soap_serialize_std__string(soap, &this->ns1__BlockItemType::Name);
  soap_serialize_std__vectorTemplateOfPointerTons1__DataItemType(soap, &this->ns1__BlockItemType::returnArray);
#endif
}

/*--------------------------[ soap_out ]-----------------------------------*/
int ns1__BlockItemType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
  return soap_out_ns1__BlockItemType(soap, tag, id, this, type);
}

/*--------------------------[ soap_out_ns1__BlockItemType ]----------------*/
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BlockItemType(struct soap *soap, const char *tag, int id, const ns1__BlockItemType *a, const char *type)
{
  (void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BlockItemType), type))
    return soap->error;
  if (soap_out_unsignedInt(soap, "Id", -1, &a->ns1__BlockItemType::Id, ""))
    return soap->error;
  if (soap_out_std__string(soap, "Name", -1, &a->ns1__BlockItemType::Name, ""))
    return soap->error;
  if (soap_out_std__vectorTemplateOfPointerTons1__DataItemType(soap, "returnArray", -1, &a->ns1__BlockItemType::returnArray, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

/*--------------------------[ soap_in ]------------------------------------*/
void *ns1__BlockItemType::soap_in(struct soap *soap, const char *tag, const char *type)
{
  return soap_in_ns1__BlockItemType(soap, tag, this, type);
}

/*--------------------------[ soap_in_ns1__BlockItemType ]-----------------*/
SOAP_FMAC3 ns1__BlockItemType * SOAP_FMAC4 soap_in_ns1__BlockItemType(struct soap *soap, const char *tag, ns1__BlockItemType *a, const char *type)
{
  (void)tag; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (ns1__BlockItemType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BlockItemType, sizeof(ns1__BlockItemType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
  if (!a)
    return NULL;
  if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__BlockItemType)
  {
    soap_revert(soap);
    *soap->id = '\0';
    return (ns1__BlockItemType *)a->soap_in(soap, tag, type);
  }
  if (soap->alloced)
    a->soap_default(soap);
  size_t soap_flag_Id1 = 1;
  size_t soap_flag_Name1 = 1;
  if (soap->body && *soap->href != '#')
  {
    for (;;)
    {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_unsignedInt(soap, "Id", &a->ns1__BlockItemType::Id, "xsd:unsignedInt"))
        {
          soap_flag_Id1--;
          continue;
        }
      }
      if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
      {
        if (soap_in_std__string(soap, "Name", &a->ns1__BlockItemType::Name, "xsd:string"))
        {
          soap_flag_Name1--;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_std__vectorTemplateOfPointerTons1__DataItemType(soap, "returnArray", &a->ns1__BlockItemType::returnArray, "ns1:DataItemType"))
          continue;
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_Name1 > 0 || a->ns1__BlockItemType::returnArray.size() < 1))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }
  }
  else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
  {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  else
  {
    a = (ns1__BlockItemType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BlockItemType, SOAP_TYPE_ns1__BlockItemType, sizeof(ns1__BlockItemType), 0, soap_finsert, soap_fbase);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

/*--------------------------[ soap_instantiate_ns1__BlockItemType ]--------*/
SOAP_FMAC1 ns1__BlockItemType * SOAP_FMAC2 soap_instantiate_ns1__BlockItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BlockItemType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
  (void)type; (void)arrayType; /* appease -Wall -Werror */
  ns1__BlockItemType *p;
  size_t k = sizeof(ns1__BlockItemType);
  if (n < 0)
  {
    p = SOAP_NEW(ns1__BlockItemType);
    if (p)
      ((ns1__BlockItemType*)p)->soap = soap;
  }
  else
  {
    p = SOAP_NEW_ARRAY(ns1__BlockItemType, n);
    k *= n;
    if (p)
      for (int i = 0; i < n; i++)
        ((ns1__BlockItemType*)p)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__BlockItemType location=%p n=%d\n", (void*)p, n));
  soap_link(soap, p, SOAP_TYPE_ns1__BlockItemType, n, soap_fdelete);
  if (size)
    *size = k;
  return p;
}

/*--------------------------[ soap_put ]-----------------------------------*/
int ns1__BlockItemType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
  if (soap_out_ns1__BlockItemType(soap, tag ? tag : "ns1:BlockItemType", -2, this, type))
    return soap->error;
  return soap_putindependent(soap);
}

/*--------------------------[ soap_get ]-----------------------------------*/
void *ns1__BlockItemType::soap_get(struct soap *soap, const char *tag, const char *type)
{
  return soap_get_ns1__BlockItemType(soap, this, tag, type);
}

/*--------------------------[ soap_get_ns1__BlockItemType ]----------------*/
SOAP_FMAC3 ns1__BlockItemType * SOAP_FMAC4 soap_get_ns1__BlockItemType(struct soap *soap, ns1__BlockItemType *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns1__BlockItemType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

/*--------------------------[ soap_dealloc ]-------------------------------*/
void ns1__BlockItemType::soap_dealloc()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ns1__BlockItemType::soap_dealloc(" << address << ")" << LOG_TERMINATOR;
  for(unsigned int i=0; i<returnArray.size(); i++)
  {
    //er_sprintf(address, "%p", returnArray[i]);
    //soap_obj_log_d << "ns1__BlockItemType::soap_dealloc - delete " << address << ")" << LOG_TERMINATOR;
    delete []returnArray[i];
  }
  returnArray.clear();
}



//====================[ ns1__DataItemRow::Implemented Methods ]==============
//ctor
ns1__DataItemRow::ns1__DataItemRow(): returnArray(), soap()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ctor of ns1__DataItemRow(" << address << ")" << LOG_TERMINATOR;
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__DataItemRow(addr:%s)\n", address));
  ////DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__DataItemRow(addr:%p)\n", (void*)this));
}

//dtor
ns1__DataItemRow::~ns1__DataItemRow()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "dtor of ns1__DataItemRow(" << address << ")" << LOG_TERMINATOR;
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "dtor ns1__DataItemRow(addr:%p)\n", (void*)this));
}

/*--------------------------[ soap_default ]-------------------------------*/
void ns1__DataItemRow::soap_default(struct soap *soap)
{
  this->soap = soap;
  soap_default_std__vectorTemplateOfPointerTons1__DataItemType(soap, &this->ns1__DataItemRow::returnArray);
  /* transient soap skipped */
}

/*--------------------------[ soap_serialize ]-----------------------------*/
void ns1__DataItemRow::soap_serialize(struct soap *soap) const
{
  (void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
  soap_serialize_std__vectorTemplateOfPointerTons1__DataItemType(soap, &this->ns1__DataItemRow::returnArray);
#endif
}

/*--------------------------[ soap_out ]-----------------------------------*/
int ns1__DataItemRow::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
  return soap_out_ns1__DataItemRow(soap, tag, id, this, type);
}

/*--------------------------[ soap_out_ns1__DataItemRow ]------------------*/
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DataItemRow(struct soap *soap, const char *tag, int id, const ns1__DataItemRow *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DataItemRow), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__DataItemType(soap, "returnArray", -1, &a->ns1__DataItemRow::returnArray, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

/*--------------------------[ soap_in ]------------------------------------*/
void *ns1__DataItemRow::soap_in(struct soap *soap, const char *tag, const char *type)
{
  return soap_in_ns1__DataItemRow(soap, tag, this, type);
}

/*--------------------------[ soap_in_ns1__DataItemRow ]-------------------*/
SOAP_FMAC3 ns1__DataItemRow * SOAP_FMAC4 soap_in_ns1__DataItemRow(struct soap *soap, const char *tag, ns1__DataItemRow *a, const char *type)
{
  (void)tag; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (ns1__DataItemRow *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DataItemRow, sizeof(ns1__DataItemRow), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
  if (!a)
    return NULL;
  if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__DataItemRow)
  {
    soap_revert(soap);
    *soap->id = '\0';
    return (ns1__DataItemRow *)a->soap_in(soap, tag, type);
  }
  if (soap->alloced)
    a->soap_default(soap);
  if (soap->body && *soap->href != '#')
  {
    for (;;)
    {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_std__vectorTemplateOfPointerTons1__DataItemType(soap, "returnArray", &a->ns1__DataItemRow::returnArray, "ns1:DataItemType"))
          continue;
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
    if ((soap->mode & SOAP_XML_STRICT) && (a->ns1__DataItemRow::returnArray.size() < 1))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }
  }
  else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
  {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  else
  {
    a = (ns1__DataItemRow *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DataItemRow, SOAP_TYPE_ns1__DataItemRow, sizeof(ns1__DataItemRow), 0, soap_finsert, soap_fbase);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

/*--------------------------[ soap_instantiate_ns1__DataItemRow ]----------*/
SOAP_FMAC1 ns1__DataItemRow * SOAP_FMAC2 soap_instantiate_ns1__DataItemRow(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DataItemRow(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
  (void)type; (void)arrayType; /* appease -Wall -Werror */
  ns1__DataItemRow *p;
  size_t k = sizeof(ns1__DataItemRow);
  if (n < 0)
  {
    p = SOAP_NEW(ns1__DataItemRow);
    if (p)
      ((ns1__DataItemRow*)p)->soap = soap;
  }
  else
  {
    p = SOAP_NEW_ARRAY(ns1__DataItemRow, n);
    k *= n;
    if (p)
      for (int i = 0; i < n; i++)
        ((ns1__DataItemRow*)p)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DataItemRow location=%p n=%d\n", (void*)p, n));
  soap_link(soap, p, SOAP_TYPE_ns1__DataItemRow, n, soap_fdelete);
  if (size)
    *size = k;
  return p;
}

/*--------------------------[ soap_put ]-----------------------------------*/
int ns1__DataItemRow::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
  if (soap_out_ns1__DataItemRow(soap, tag ? tag : "ns1:DataItemRow", -2, this, type))
    return soap->error;
  return soap_putindependent(soap);
}

/*--------------------------[ soap_get ]-----------------------------------*/
void *ns1__DataItemRow::soap_get(struct soap *soap, const char *tag, const char *type)
{
  return soap_get_ns1__DataItemRow(soap, this, tag, type);
}

/*--------------------------[ soap_get_ns1__DataItemRow ]------------------*/
SOAP_FMAC3 ns1__DataItemRow * SOAP_FMAC4 soap_get_ns1__DataItemRow(struct soap *soap, ns1__DataItemRow *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns1__DataItemRow(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

/*--------------------------[ soap_dealloc ]-------------------------------*/
void ns1__DataItemRow::soap_dealloc()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ns1__DataItemRow::soap_dealloc(" << address << ")" << LOG_TERMINATOR;
  for(unsigned int i=0; i<returnArray.size(); i++)
  {
    //er_sprintf(address, "%p", returnArray[i]);
    //soap_obj_log_d << "ns1__DataItemRow::soap_dealloc - delete " << address << ")" << LOG_TERMINATOR;
    delete []returnArray[i];
  }
  returnArray.clear();
}


//====================[ ns1__DataItemType::Implemented Methods ]=============
//ctor
ns1__DataItemType::ns1__DataItemType(): ersid(), value(), ersname(), bgcolor(), soap()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "ctor of ns1__DataItemType(" << address << ")" << LOG_TERMINATOR;
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__DataItemType(addr:%s)\n", address));
  ////DBGLOG(TEST, SOAP_MESSAGE(fdebug, "ctor ns1__DataItemType(addr:%p)\n", (void*)this));
}

//dtor
ns1__DataItemType::~ns1__DataItemType()
{
  //char address[20];
  ////sprintf(address, "%p", this);
  //er_sprintf(address, "%p", this);
  //soap_obj_log_d << "dtor of ns1__DataItemType(" << address << ")" << LOG_TERMINATOR;
  //DBGLOG(TEST, SOAP_MESSAGE(fdebug, "dtor ns1__DataItemType(addr:%p)\n", (void*)this));
}

/*--------------------------[ soap_default ]-------------------------------*/
void ns1__DataItemType::soap_default(struct soap *soap)
{
  this->soap = soap;
  soap_default_std__string(soap, &this->ns1__DataItemType::ersid);
  soap_default_std__string(soap, &this->ns1__DataItemType::value);
  soap_default_std__string(soap, &this->ns1__DataItemType::ersname);
  this->ns1__DataItemType::bgcolor = NULL;
  /* transient soap skipped */
}

/*--------------------------[ soap_serialize ]-----------------------------*/
void ns1__DataItemType::soap_serialize(struct soap *soap) const
{
  (void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
  soap_serialize_std__string(soap, &this->ns1__DataItemType::ersid);
  soap_serialize_std__string(soap, &this->ns1__DataItemType::value);
  soap_serialize_std__string(soap, &this->ns1__DataItemType::ersname);
  soap_serialize_PointerTounsignedInt(soap, &this->ns1__DataItemType::bgcolor);
#endif
}

/*--------------------------[ soap_out ]-----------------------------------*/
int ns1__DataItemType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
  return soap_out_ns1__DataItemType(soap, tag, id, this, type);
}

/*--------------------------[ soap_out_ns1__DataItemType ]-----------------*/
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DataItemType(struct soap *soap, const char *tag, int id, const ns1__DataItemType *a, const char *type)
{
  (void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DataItemType), type))
    return soap->error;
  if (soap_out_std__string(soap, "ersid", -1, &a->ns1__DataItemType::ersid, ""))
    return soap->error;
  if (soap_out_std__string(soap, "value", -1, &a->ns1__DataItemType::value, ""))
    return soap->error;
  if (soap_out_std__string(soap, "ersname", -1, &a->ns1__DataItemType::ersname, ""))
    return soap->error;
  if (soap_out_PointerTounsignedInt(soap, "bgcolor", -1, &a->ns1__DataItemType::bgcolor, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

/*--------------------------[ soap_in ]------------------------------------*/
void *ns1__DataItemType::soap_in(struct soap *soap, const char *tag, const char *type)
{
  return soap_in_ns1__DataItemType(soap, tag, this, type);
}

/*--------------------------[ soap_in_ns1__DataItemType ]------------------*/
SOAP_FMAC3 ns1__DataItemType * SOAP_FMAC4 soap_in_ns1__DataItemType(struct soap *soap, const char *tag, ns1__DataItemType *a, const char *type)
{
  (void)tag; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (ns1__DataItemType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DataItemType, sizeof(ns1__DataItemType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
  if (!a)
    return NULL;
  if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__DataItemType)
  {
    soap_revert(soap);
    *soap->id = '\0';
    return (ns1__DataItemType *)a->soap_in(soap, tag, type);
  }
  if (soap->alloced)
    a->soap_default(soap);
  size_t soap_flag_ersid1 = 1;
  size_t soap_flag_value1 = 1;
  size_t soap_flag_ersname1 = 1;
  size_t soap_flag_bgcolor1 = 1;
  if (soap->body && *soap->href != '#')
  {
    for (;;)
    {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_ersid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
      {
        if (soap_in_std__string(soap, "ersid", &a->ns1__DataItemType::ersid, "xsd:string"))
        {
          soap_flag_ersid1--;
          continue;
        }
      }
      if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
      {
        if (soap_in_std__string(soap, "value", &a->ns1__DataItemType::value, "xsd:string"))
        {
          soap_flag_value1--;
          continue;
        }
      }
      if (soap_flag_ersname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
      {
        if (soap_in_std__string(soap, "ersname", &a->ns1__DataItemType::ersname, "xsd:string"))
        {
          soap_flag_ersname1--;
          continue;
        }
      }
      if (soap_flag_bgcolor1 && soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_PointerTounsignedInt(soap, "bgcolor", &a->ns1__DataItemType::bgcolor, "xsd:unsignedInt"))
        {
          soap_flag_bgcolor1--;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ersid1 > 0 || soap_flag_value1 > 0 || soap_flag_ersname1 > 0))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }
  }
  else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
  {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  else
  {
    a = (ns1__DataItemType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DataItemType, SOAP_TYPE_ns1__DataItemType, sizeof(ns1__DataItemType), 0, soap_finsert, soap_fbase);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

/*--------------------------[ soap_instantiate_ns1__DataItemType ]---------*/
SOAP_FMAC1 ns1__DataItemType * SOAP_FMAC2 soap_instantiate_ns1__DataItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DataItemType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
  (void)type; (void)arrayType; /* appease -Wall -Werror */
  ns1__DataItemType *p;
  size_t k = sizeof(ns1__DataItemType);
  if (n < 0)
  {
    p = SOAP_NEW(ns1__DataItemType);
    if (p)
      ((ns1__DataItemType*)p)->soap = soap;
  }
  else
  {
    p = SOAP_NEW_ARRAY(ns1__DataItemType, n);
    k *= n;
    if (p)
      for (int i = 0; i < n; i++)
        ((ns1__DataItemType*)p)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DataItemType location=%p n=%d\n", (void*)p, n));
  soap_link(soap, p, SOAP_TYPE_ns1__DataItemType, n, soap_fdelete);
  if (size)
    *size = k;
  return p;
}

/*--------------------------[ soap_put ]-----------------------------------*/
int ns1__DataItemType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
  if (soap_out_ns1__DataItemType(soap, tag ? tag : "ns1:DataItemType", -2, this, type))
    return soap->error;
  return soap_putindependent(soap);
}

/*--------------------------[ soap_get ]-----------------------------------*/
void *ns1__DataItemType::soap_get(struct soap *soap, const char *tag, const char *type)
{
  return soap_get_ns1__DataItemType(soap, this, tag, type);
}

/*--------------------------[ soap_get_ns1__DataItemType ]-----------------*/
SOAP_FMAC3 ns1__DataItemType * SOAP_FMAC4 soap_get_ns1__DataItemType(struct soap *soap, ns1__DataItemType *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns1__DataItemType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

void ns1__ResponseSaveReportType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_unsignedInt(soap, &this->ns1__ResponseSaveReportType::reportId);
	soap_default_unsignedInt(soap, &this->ns1__ResponseSaveReportType::serviceReqId);
	soap_default_unsignedInt(soap, &this->ns1__ResponseSaveReportType::errorCause);
	/* transient soap skipped */
}

void ns1__ResponseSaveReportType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__ResponseSaveReportType::reportId, SOAP_TYPE_unsignedInt);
	soap_embedded(soap, &this->ns1__ResponseSaveReportType::serviceReqId, SOAP_TYPE_unsignedInt);
	soap_embedded(soap, &this->ns1__ResponseSaveReportType::errorCause, SOAP_TYPE_unsignedInt);
#endif
}

int ns1__ResponseSaveReportType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ResponseSaveReportType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ResponseSaveReportType(struct soap *soap, const char *tag, int id, const ns1__ResponseSaveReportType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ResponseSaveReportType), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "reportId", -1, &a->ns1__ResponseSaveReportType::reportId, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "serviceReqId", -1, &a->ns1__ResponseSaveReportType::serviceReqId, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "errorCause", -1, &a->ns1__ResponseSaveReportType::errorCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ResponseSaveReportType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ResponseSaveReportType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ResponseSaveReportType * SOAP_FMAC4 soap_in_ns1__ResponseSaveReportType(struct soap *soap, const char *tag, ns1__ResponseSaveReportType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ResponseSaveReportType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ResponseSaveReportType, sizeof(ns1__ResponseSaveReportType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ResponseSaveReportType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ResponseSaveReportType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reportId1 = 1;
	size_t soap_flag_serviceReqId1 = 1;
	size_t soap_flag_errorCause1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reportId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "reportId", &a->ns1__ResponseSaveReportType::reportId, "xsd:unsignedInt"))
				{	soap_flag_reportId1--;
					continue;
				}
			}
			if (soap_flag_serviceReqId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "serviceReqId", &a->ns1__ResponseSaveReportType::serviceReqId, "xsd:unsignedInt"))
				{	soap_flag_serviceReqId1--;
					continue;
				}
			}
			if (soap_flag_errorCause1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "errorCause", &a->ns1__ResponseSaveReportType::errorCause, "xsd:unsignedInt"))
				{	soap_flag_errorCause1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reportId1 > 0 || soap_flag_serviceReqId1 > 0 || soap_flag_errorCause1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ResponseSaveReportType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ResponseSaveReportType, SOAP_TYPE_ns1__ResponseSaveReportType, sizeof(ns1__ResponseSaveReportType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ResponseSaveReportType * SOAP_FMAC2 soap_instantiate_ns1__ResponseSaveReportType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ResponseSaveReportType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ResponseSaveReportType *p;
	size_t k = sizeof(ns1__ResponseSaveReportType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ResponseSaveReportType);
		if (p)
			((ns1__ResponseSaveReportType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ResponseSaveReportType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ResponseSaveReportType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ResponseSaveReportType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__ResponseSaveReportType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ResponseSaveReportType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ResponseSaveReportType(soap, tag ? tag : "ns1:ResponseSaveReportType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ResponseSaveReportType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ResponseSaveReportType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ResponseSaveReportType * SOAP_FMAC4 soap_get_ns1__ResponseSaveReportType(struct soap *soap, ns1__ResponseSaveReportType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ResponseSaveReportType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ResponseInfoHeaderType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_unsignedInt(soap, &this->ns1__ResponseInfoHeaderType::serviceReqId);
	soap_default_unsignedInt(soap, &this->ns1__ResponseInfoHeaderType::errorCause);
	soap_default_std__string(soap, &this->ns1__ResponseInfoHeaderType::serversInfo);
	/* transient soap skipped */
}

void ns1__ResponseInfoHeaderType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__ResponseInfoHeaderType::serviceReqId, SOAP_TYPE_unsignedInt);
	soap_embedded(soap, &this->ns1__ResponseInfoHeaderType::errorCause, SOAP_TYPE_unsignedInt);
	soap_serialize_std__string(soap, &this->ns1__ResponseInfoHeaderType::serversInfo);
#endif
}

int ns1__ResponseInfoHeaderType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ResponseInfoHeaderType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ResponseInfoHeaderType(struct soap *soap, const char *tag, int id, const ns1__ResponseInfoHeaderType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ResponseInfoHeaderType), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "serviceReqId", -1, &a->ns1__ResponseInfoHeaderType::serviceReqId, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "errorCause", -1, &a->ns1__ResponseInfoHeaderType::errorCause, ""))
		return soap->error;
	if (soap_out_std__string(soap, "serversInfo", -1, &a->ns1__ResponseInfoHeaderType::serversInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ResponseInfoHeaderType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ResponseInfoHeaderType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ResponseInfoHeaderType * SOAP_FMAC4 soap_in_ns1__ResponseInfoHeaderType(struct soap *soap, const char *tag, ns1__ResponseInfoHeaderType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ResponseInfoHeaderType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ResponseInfoHeaderType, sizeof(ns1__ResponseInfoHeaderType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ResponseInfoHeaderType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ResponseInfoHeaderType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_serviceReqId1 = 1;
	size_t soap_flag_errorCause1 = 1;
	size_t soap_flag_serversInfo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_serviceReqId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "serviceReqId", &a->ns1__ResponseInfoHeaderType::serviceReqId, "xsd:unsignedInt"))
				{	soap_flag_serviceReqId1--;
					continue;
				}
			}
			if (soap_flag_errorCause1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "errorCause", &a->ns1__ResponseInfoHeaderType::errorCause, "xsd:unsignedInt"))
				{	soap_flag_errorCause1--;
					continue;
				}
			}
			if (soap_flag_serversInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "serversInfo", &a->ns1__ResponseInfoHeaderType::serversInfo, "xsd:string"))
				{	soap_flag_serversInfo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_serviceReqId1 > 0 || soap_flag_errorCause1 > 0 || soap_flag_serversInfo1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ResponseInfoHeaderType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ResponseInfoHeaderType, SOAP_TYPE_ns1__ResponseInfoHeaderType, sizeof(ns1__ResponseInfoHeaderType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ResponseInfoHeaderType * SOAP_FMAC2 soap_instantiate_ns1__ResponseInfoHeaderType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ResponseInfoHeaderType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ResponseInfoHeaderType *p;
	size_t k = sizeof(ns1__ResponseInfoHeaderType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ResponseInfoHeaderType);
		if (p)
			((ns1__ResponseInfoHeaderType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ResponseInfoHeaderType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ResponseInfoHeaderType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ResponseInfoHeaderType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__ResponseInfoHeaderType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ResponseInfoHeaderType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ResponseInfoHeaderType(soap, tag ? tag : "ns1:ResponseInfoHeaderType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ResponseInfoHeaderType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ResponseInfoHeaderType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ResponseInfoHeaderType * SOAP_FMAC4 soap_get_ns1__ResponseInfoHeaderType(struct soap *soap, ns1__ResponseInfoHeaderType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ResponseInfoHeaderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ChatResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__ChatResponseType::sessionId);
	soap_default_unsignedInt(soap, &this->ns1__ChatResponseType::serviceReqId);
	soap_default_unsignedInt(soap, &this->ns1__ChatResponseType::errorCause);
	/* transient soap skipped */
}

void ns1__ChatResponseType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__ChatResponseType::sessionId);
	soap_embedded(soap, &this->ns1__ChatResponseType::serviceReqId, SOAP_TYPE_unsignedInt);
	soap_embedded(soap, &this->ns1__ChatResponseType::errorCause, SOAP_TYPE_unsignedInt);
#endif
}

int ns1__ChatResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ChatResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ChatResponseType(struct soap *soap, const char *tag, int id, const ns1__ChatResponseType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ChatResponseType), type))
		return soap->error;
	if (soap_out_std__string(soap, "sessionId", -1, &a->ns1__ChatResponseType::sessionId, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "serviceReqId", -1, &a->ns1__ChatResponseType::serviceReqId, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "errorCause", -1, &a->ns1__ChatResponseType::errorCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ChatResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ChatResponseType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ChatResponseType * SOAP_FMAC4 soap_in_ns1__ChatResponseType(struct soap *soap, const char *tag, ns1__ChatResponseType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ChatResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ChatResponseType, sizeof(ns1__ChatResponseType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ChatResponseType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ChatResponseType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_serviceReqId1 = 1;
	size_t soap_flag_errorCause1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sessionId", &a->ns1__ChatResponseType::sessionId, "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			}
			if (soap_flag_serviceReqId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "serviceReqId", &a->ns1__ChatResponseType::serviceReqId, "xsd:unsignedInt"))
				{	soap_flag_serviceReqId1--;
					continue;
				}
			}
			if (soap_flag_errorCause1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "errorCause", &a->ns1__ChatResponseType::errorCause, "xsd:unsignedInt"))
				{	soap_flag_errorCause1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sessionId1 > 0 || soap_flag_serviceReqId1 > 0 || soap_flag_errorCause1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ChatResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ChatResponseType, SOAP_TYPE_ns1__ChatResponseType, sizeof(ns1__ChatResponseType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ChatResponseType * SOAP_FMAC2 soap_instantiate_ns1__ChatResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ChatResponseType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ChatResponseType *p;
	size_t k = sizeof(ns1__ChatResponseType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ChatResponseType);
		if (p)
			((ns1__ChatResponseType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ChatResponseType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ChatResponseType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ChatResponseType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__ChatResponseType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ChatResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ChatResponseType(soap, tag ? tag : "ns1:ChatResponseType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ChatResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ChatResponseType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ChatResponseType * SOAP_FMAC4 soap_get_ns1__ChatResponseType(struct soap *soap, ns1__ChatResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ChatResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__TFRequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__TFRequestType::requestInfoHeader = NULL;
	soap_default_unsignedInt(soap, &this->ns1__TFRequestType::AgentId);
	soap_default_std__string(soap, &this->ns1__TFRequestType::Operation);
	/* transient soap skipped */
}

void ns1__TFRequestType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RequestInfoHeaderType(soap, &this->ns1__TFRequestType::requestInfoHeader);
	soap_embedded(soap, &this->ns1__TFRequestType::AgentId, SOAP_TYPE_unsignedInt);
	soap_serialize_std__string(soap, &this->ns1__TFRequestType::Operation);
#endif
}

int ns1__TFRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TFRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TFRequestType(struct soap *soap, const char *tag, int id, const ns1__TFRequestType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TFRequestType), type))
		return soap->error;
	if (!a->ns1__TFRequestType::requestInfoHeader)
	{	if (soap_element_empty(soap, "requestInfoHeader"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", -1, &a->ns1__TFRequestType::requestInfoHeader, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "AgentId", -1, &a->ns1__TFRequestType::AgentId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "Operation", -1, &a->ns1__TFRequestType::Operation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__TFRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__TFRequestType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TFRequestType * SOAP_FMAC4 soap_in_ns1__TFRequestType(struct soap *soap, const char *tag, ns1__TFRequestType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TFRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TFRequestType, sizeof(ns1__TFRequestType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__TFRequestType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__TFRequestType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_requestInfoHeader1 = 1;
	size_t soap_flag_AgentId1 = 1;
	size_t soap_flag_Operation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", &a->ns1__TFRequestType::requestInfoHeader, "ns1:RequestInfoHeaderType"))
				{	soap_flag_requestInfoHeader1--;
					continue;
				}
			}
			if (soap_flag_AgentId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "AgentId", &a->ns1__TFRequestType::AgentId, "xsd:unsignedInt"))
				{	soap_flag_AgentId1--;
					continue;
				}
			}
			if (soap_flag_Operation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "Operation", &a->ns1__TFRequestType::Operation, "xsd:string"))
				{	soap_flag_Operation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__TFRequestType::requestInfoHeader || soap_flag_AgentId1 > 0 || soap_flag_Operation1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__TFRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TFRequestType, SOAP_TYPE_ns1__TFRequestType, sizeof(ns1__TFRequestType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__TFRequestType * SOAP_FMAC2 soap_instantiate_ns1__TFRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TFRequestType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__TFRequestType *p;
	size_t k = sizeof(ns1__TFRequestType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__TFRequestType);
		if (p)
			((ns1__TFRequestType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__TFRequestType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__TFRequestType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__TFRequestType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__TFRequestType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__TFRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__TFRequestType(soap, tag ? tag : "ns1:TFRequestType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TFRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TFRequestType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TFRequestType * SOAP_FMAC4 soap_get_ns1__TFRequestType(struct soap *soap, ns1__TFRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TFRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ACDRequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ACDRequestType::requestInfoHeader = NULL;
	soap_default_unsignedInt(soap, &this->ns1__ACDRequestType::AgentId);
	soap_default_unsignedInt(soap, &this->ns1__ACDRequestType::GroupId);
	soap_default_std__string(soap, &this->ns1__ACDRequestType::Operation);
	/* transient soap skipped */
}

void ns1__ACDRequestType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RequestInfoHeaderType(soap, &this->ns1__ACDRequestType::requestInfoHeader);
	soap_embedded(soap, &this->ns1__ACDRequestType::AgentId, SOAP_TYPE_unsignedInt);
	soap_embedded(soap, &this->ns1__ACDRequestType::GroupId, SOAP_TYPE_unsignedInt);
	soap_serialize_std__string(soap, &this->ns1__ACDRequestType::Operation);
#endif
}

int ns1__ACDRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ACDRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ACDRequestType(struct soap *soap, const char *tag, int id, const ns1__ACDRequestType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ACDRequestType), type))
		return soap->error;
	if (!a->ns1__ACDRequestType::requestInfoHeader)
	{	if (soap_element_empty(soap, "requestInfoHeader"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", -1, &a->ns1__ACDRequestType::requestInfoHeader, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "AgentId", -1, &a->ns1__ACDRequestType::AgentId, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "GroupId", -1, &a->ns1__ACDRequestType::GroupId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "Operation", -1, &a->ns1__ACDRequestType::Operation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ACDRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ACDRequestType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ACDRequestType * SOAP_FMAC4 soap_in_ns1__ACDRequestType(struct soap *soap, const char *tag, ns1__ACDRequestType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ACDRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ACDRequestType, sizeof(ns1__ACDRequestType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ACDRequestType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ACDRequestType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_requestInfoHeader1 = 1;
	size_t soap_flag_AgentId1 = 1;
	size_t soap_flag_GroupId1 = 1;
	size_t soap_flag_Operation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", &a->ns1__ACDRequestType::requestInfoHeader, "ns1:RequestInfoHeaderType"))
				{	soap_flag_requestInfoHeader1--;
					continue;
				}
			}
			if (soap_flag_AgentId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "AgentId", &a->ns1__ACDRequestType::AgentId, "xsd:unsignedInt"))
				{	soap_flag_AgentId1--;
					continue;
				}
			}
			if (soap_flag_GroupId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "GroupId", &a->ns1__ACDRequestType::GroupId, "xsd:unsignedInt"))
				{	soap_flag_GroupId1--;
					continue;
				}
			}
			if (soap_flag_Operation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "Operation", &a->ns1__ACDRequestType::Operation, "xsd:string"))
				{	soap_flag_Operation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__ACDRequestType::requestInfoHeader || soap_flag_AgentId1 > 0 || soap_flag_GroupId1 > 0 || soap_flag_Operation1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ACDRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ACDRequestType, SOAP_TYPE_ns1__ACDRequestType, sizeof(ns1__ACDRequestType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ACDRequestType * SOAP_FMAC2 soap_instantiate_ns1__ACDRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ACDRequestType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ACDRequestType *p;
	size_t k = sizeof(ns1__ACDRequestType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ACDRequestType);
		if (p)
			((ns1__ACDRequestType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ACDRequestType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ACDRequestType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ACDRequestType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__ACDRequestType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ACDRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ACDRequestType(soap, tag ? tag : "ns1:ACDRequestType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ACDRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ACDRequestType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ACDRequestType * SOAP_FMAC4 soap_get_ns1__ACDRequestType(struct soap *soap, ns1__ACDRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ACDRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ACDMultiRequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ACDMultiRequestType::requestInfoHeader = NULL;
	soap_default_unsignedInt(soap, &this->ns1__ACDMultiRequestType::Id);
	soap_default_std__vectorTemplateOfunsignedInt(soap, &this->ns1__ACDMultiRequestType::multiId);
	soap_default_std__string(soap, &this->ns1__ACDMultiRequestType::Operation);
	/* transient soap skipped */
}

void ns1__ACDMultiRequestType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RequestInfoHeaderType(soap, &this->ns1__ACDMultiRequestType::requestInfoHeader);
	soap_embedded(soap, &this->ns1__ACDMultiRequestType::Id, SOAP_TYPE_unsignedInt);
	soap_serialize_std__vectorTemplateOfunsignedInt(soap, &this->ns1__ACDMultiRequestType::multiId);
	soap_serialize_std__string(soap, &this->ns1__ACDMultiRequestType::Operation);
#endif
}

int ns1__ACDMultiRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ACDMultiRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ACDMultiRequestType(struct soap *soap, const char *tag, int id, const ns1__ACDMultiRequestType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ACDMultiRequestType), type))
		return soap->error;
	if (!a->ns1__ACDMultiRequestType::requestInfoHeader)
	{	if (soap_element_empty(soap, "requestInfoHeader"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", -1, &a->ns1__ACDMultiRequestType::requestInfoHeader, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "Id", -1, &a->ns1__ACDMultiRequestType::Id, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfunsignedInt(soap, "multiId", -1, &a->ns1__ACDMultiRequestType::multiId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "Operation", -1, &a->ns1__ACDMultiRequestType::Operation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ACDMultiRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ACDMultiRequestType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ACDMultiRequestType * SOAP_FMAC4 soap_in_ns1__ACDMultiRequestType(struct soap *soap, const char *tag, ns1__ACDMultiRequestType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ACDMultiRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ACDMultiRequestType, sizeof(ns1__ACDMultiRequestType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ACDMultiRequestType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ACDMultiRequestType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_requestInfoHeader1 = 1;
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Operation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", &a->ns1__ACDMultiRequestType::requestInfoHeader, "ns1:RequestInfoHeaderType"))
				{	soap_flag_requestInfoHeader1--;
					continue;
				}
			}
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "Id", &a->ns1__ACDMultiRequestType::Id, "xsd:unsignedInt"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfunsignedInt(soap, "multiId", &a->ns1__ACDMultiRequestType::multiId, "xsd:unsignedInt"))
					continue;
			}
			if (soap_flag_Operation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "Operation", &a->ns1__ACDMultiRequestType::Operation, "xsd:string"))
				{	soap_flag_Operation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__ACDMultiRequestType::requestInfoHeader || soap_flag_Id1 > 0 || a->ns1__ACDMultiRequestType::multiId.size() < 1 || soap_flag_Operation1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ACDMultiRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ACDMultiRequestType, SOAP_TYPE_ns1__ACDMultiRequestType, sizeof(ns1__ACDMultiRequestType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ACDMultiRequestType * SOAP_FMAC2 soap_instantiate_ns1__ACDMultiRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ACDMultiRequestType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ACDMultiRequestType *p;
	size_t k = sizeof(ns1__ACDMultiRequestType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ACDMultiRequestType);
		if (p)
			((ns1__ACDMultiRequestType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ACDMultiRequestType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ACDMultiRequestType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ACDMultiRequestType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__ACDMultiRequestType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ACDMultiRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ACDMultiRequestType(soap, tag ? tag : "ns1:ACDMultiRequestType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ACDMultiRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ACDMultiRequestType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ACDMultiRequestType * SOAP_FMAC4 soap_get_ns1__ACDMultiRequestType(struct soap *soap, ns1__ACDMultiRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ACDMultiRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


//============[ ns1__GenInfoRequestType::Implemented Methods ]===========
/*--------------------------[ soap_default ]-------------------------------*/
void ns1__GenInfoRequestType::soap_default(struct soap *soap)
{
  this->soap = soap;
  this->ns1__GenInfoRequestType::requestInfoHeader = NULL;
  soap_default_std__vectorTemplateOfunsignedInt(soap, &this->ns1__GenInfoRequestType::Id);
  /* transient soap skipped */
}

/*--------------------------[ soap_serialize ]-----------------------------*/
void ns1__GenInfoRequestType::soap_serialize(struct soap *soap) const
{
  (void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
  soap_serialize_PointerTons1__RequestInfoHeaderType(soap, &this->ns1__GenInfoRequestType::requestInfoHeader);
  soap_serialize_std__vectorTemplateOfunsignedInt(soap, &this->ns1__GenInfoRequestType::Id);
#endif
}

/*--------------------------[ soap_out ]-----------------------------------*/
int ns1__GenInfoRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
  return soap_out_ns1__GenInfoRequestType(soap, tag, id, this, type);
}

/*--------------------[ soap_out_ns1__GenInfoRequestType ]-----------------*/
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GenInfoRequestType(struct soap *soap, const char *tag, int id, const ns1__GenInfoRequestType *a, const char *type)
{
  (void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GenInfoRequestType), type))
    return soap->error;
  if (!a->ns1__GenInfoRequestType::requestInfoHeader)
  {
    if (soap_element_empty(soap, "requestInfoHeader"))
      return soap->error;
  }
  else
    if (soap_out_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", -1, &a->ns1__GenInfoRequestType::requestInfoHeader, ""))
      return soap->error;
  if (soap_out_std__vectorTemplateOfunsignedInt(soap, "Id", -1, &a->ns1__GenInfoRequestType::Id, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

/*--------------------------[ soap_in ]------------------------------------*/
void *ns1__GenInfoRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{
  return soap_in_ns1__GenInfoRequestType(soap, tag, this, type);
}

/*--------------------------[ ns1__GenInfoRequestType ]--------------------*/
SOAP_FMAC3 ns1__GenInfoRequestType * SOAP_FMAC4 soap_in_ns1__GenInfoRequestType(struct soap *soap, const char *tag, ns1__GenInfoRequestType *a, const char *type)
{
  (void)tag; (void)type; /* appease -Wall -Werror */
  if (soap_element_begin_in(soap, tag, 0, NULL))
    return NULL;
  a = (ns1__GenInfoRequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GenInfoRequestType, sizeof(ns1__GenInfoRequestType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
  if (!a)
    return NULL;
  if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GenInfoRequestType)
  {	soap_revert(soap);
  *soap->id = '\0';
  return (ns1__GenInfoRequestType *)a->soap_in(soap, tag, type);
  }
  if (soap->alloced)
    a->soap_default(soap);
  size_t soap_flag_requestInfoHeader1 = 1;
  if (soap->body && *soap->href != '#')
  {
    for (;;)
    {
      soap->error = SOAP_TAG_MISMATCH;
      if (soap_flag_requestInfoHeader1 && soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_PointerTons1__RequestInfoHeaderType(soap, "requestInfoHeader", &a->ns1__GenInfoRequestType::requestInfoHeader, "ns1:RequestInfoHeaderType"))
        {
          soap_flag_requestInfoHeader1--;
          continue;
        }
      }
      if (soap->error == SOAP_TAG_MISMATCH)
      {
        if (soap_in_std__vectorTemplateOfunsignedInt(soap, "Id", &a->ns1__GenInfoRequestType::Id, "xsd:unsignedInt"))
          continue;
      }
      if (soap->error == SOAP_TAG_MISMATCH)
        soap->error = soap_ignore_element(soap);
      if (soap->error == SOAP_NO_TAG)
        break;
      if (soap->error)
        return NULL;
    }
    if (soap_element_end_in(soap, tag))
      return NULL;
    if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__GenInfoRequestType::requestInfoHeader || a->ns1__GenInfoRequestType::Id.size() < 1))
    {
      soap->error = SOAP_OCCURS;
      return NULL;
    }
  }
  else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
  {
    soap->error = SOAP_OCCURS;
    return NULL;
  }
  else
  {
    a = (ns1__GenInfoRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GenInfoRequestType, SOAP_TYPE_ns1__GenInfoRequestType, sizeof(ns1__GenInfoRequestType), 0, soap_finsert, soap_fbase);
    if (soap->body && soap_element_end_in(soap, tag))
      return NULL;
  }
  return a;
}

/*----------------------[ soap_instantiate_ns1__GenInfoRequestType ]----------*/
SOAP_FMAC1 ns1__GenInfoRequestType * SOAP_FMAC2 soap_instantiate_ns1__GenInfoRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GenInfoRequestType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
  (void)type; (void)arrayType; /* appease -Wall -Werror */
  ns1__GenInfoRequestType *p;
  size_t k = sizeof(ns1__GenInfoRequestType);
  if (n < 0)
  {
    p = SOAP_NEW(ns1__GenInfoRequestType);
    if (p)
      ((ns1__GenInfoRequestType*)p)->soap = soap;
  }
  else
  {
    p = SOAP_NEW_ARRAY(ns1__GenInfoRequestType, n);
    k *= n;
    if (p)
      for (int i = 0; i < n; i++)
        ((ns1__GenInfoRequestType*)p)[i].soap = soap;
  }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GenInfoRequestType location=%p n=%d\n", (void*)p, n));
  soap_link(soap, p, SOAP_TYPE_ns1__GenInfoRequestType, n, soap_fdelete);
  if (size)
    *size = k;
  return p;
}

/*--------------------------[ soap_put ]-----------------------------------*/
int ns1__GenInfoRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
  if (soap_out_ns1__GenInfoRequestType(soap, tag ? tag : "ns1:GenInfoRequestType", -2, this, type))
    return soap->error;
  return soap_putindependent(soap);
}

/*--------------------------[ soap_get ]-----------------------------------*/
void *ns1__GenInfoRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
  return soap_get_ns1__GenInfoRequestType(soap, this, tag, type);
}

/*--------------------------[ soap_get_ns1__GenInfoRequestType ]-----------*/
SOAP_FMAC3 ns1__GenInfoRequestType * SOAP_FMAC4 soap_get_ns1__GenInfoRequestType(struct soap *soap, ns1__GenInfoRequestType *p, const char *tag, const char *type)
{
  if ((p = soap_in_ns1__GenInfoRequestType(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

void ns1__RequestInfoHeaderType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_unsignedInt(soap, &this->ns1__RequestInfoHeaderType::serviceReqId);
	soap_default_std__string(soap, &this->ns1__RequestInfoHeaderType::ticket);
	/* transient soap skipped */
}

void ns1__RequestInfoHeaderType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__RequestInfoHeaderType::serviceReqId, SOAP_TYPE_unsignedInt);
	soap_serialize_std__string(soap, &this->ns1__RequestInfoHeaderType::ticket);
#endif
}

int ns1__RequestInfoHeaderType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RequestInfoHeaderType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RequestInfoHeaderType(struct soap *soap, const char *tag, int id, const ns1__RequestInfoHeaderType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RequestInfoHeaderType), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "serviceReqId", -1, &a->ns1__RequestInfoHeaderType::serviceReqId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ticket", -1, &a->ns1__RequestInfoHeaderType::ticket, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RequestInfoHeaderType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__RequestInfoHeaderType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RequestInfoHeaderType * SOAP_FMAC4 soap_in_ns1__RequestInfoHeaderType(struct soap *soap, const char *tag, ns1__RequestInfoHeaderType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RequestInfoHeaderType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RequestInfoHeaderType, sizeof(ns1__RequestInfoHeaderType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__RequestInfoHeaderType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__RequestInfoHeaderType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_serviceReqId1 = 1;
	size_t soap_flag_ticket1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_serviceReqId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "serviceReqId", &a->ns1__RequestInfoHeaderType::serviceReqId, "xsd:unsignedInt"))
				{	soap_flag_serviceReqId1--;
					continue;
				}
			}
			if (soap_flag_ticket1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ticket", &a->ns1__RequestInfoHeaderType::ticket, "xsd:string"))
				{	soap_flag_ticket1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_serviceReqId1 > 0 || soap_flag_ticket1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RequestInfoHeaderType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RequestInfoHeaderType, SOAP_TYPE_ns1__RequestInfoHeaderType, sizeof(ns1__RequestInfoHeaderType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RequestInfoHeaderType * SOAP_FMAC2 soap_instantiate_ns1__RequestInfoHeaderType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RequestInfoHeaderType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RequestInfoHeaderType *p;
	size_t k = sizeof(ns1__RequestInfoHeaderType);
	if (n < 0)
	{	p = SOAP_NEW(ns1__RequestInfoHeaderType);
		if (p)
			((ns1__RequestInfoHeaderType*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__RequestInfoHeaderType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__RequestInfoHeaderType*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RequestInfoHeaderType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__RequestInfoHeaderType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__RequestInfoHeaderType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__RequestInfoHeaderType(soap, tag ? tag : "ns1:RequestInfoHeaderType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RequestInfoHeaderType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RequestInfoHeaderType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RequestInfoHeaderType * SOAP_FMAC4 soap_get_ns1__RequestInfoHeaderType(struct soap *soap, ns1__RequestInfoHeaderType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RequestInfoHeaderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SuperGroupDailyBriefInfo(struct soap *soap, struct __ns1__SuperGroupDailyBriefInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SuperGroupDailyBriefInfoRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SuperGroupDailyBriefInfo(struct soap *soap, const struct __ns1__SuperGroupDailyBriefInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenInfoRequestType(soap, &a->ns1__SuperGroupDailyBriefInfoRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SuperGroupDailyBriefInfo(struct soap *soap, const char *tag, int id, const struct __ns1__SuperGroupDailyBriefInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenInfoRequestType(soap, "ns1:SuperGroupDailyBriefInfoRequest", -1, &a->ns1__SuperGroupDailyBriefInfoRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SuperGroupDailyBriefInfo * SOAP_FMAC4 soap_in___ns1__SuperGroupDailyBriefInfo(struct soap *soap, const char *tag, struct __ns1__SuperGroupDailyBriefInfo *a, const char *type)
{
	size_t soap_flag_ns1__SuperGroupDailyBriefInfoRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SuperGroupDailyBriefInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SuperGroupDailyBriefInfo, sizeof(struct __ns1__SuperGroupDailyBriefInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SuperGroupDailyBriefInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SuperGroupDailyBriefInfoRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenInfoRequestType(soap, "ns1:SuperGroupDailyBriefInfoRequest", &a->ns1__SuperGroupDailyBriefInfoRequest, "ns1:GenInfoRequestType"))
				{	soap_flag_ns1__SuperGroupDailyBriefInfoRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SuperGroupDailyBriefInfo * SOAP_FMAC2 soap_instantiate___ns1__SuperGroupDailyBriefInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SuperGroupDailyBriefInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SuperGroupDailyBriefInfo *p;
	size_t k = sizeof(struct __ns1__SuperGroupDailyBriefInfo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SuperGroupDailyBriefInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SuperGroupDailyBriefInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SuperGroupDailyBriefInfo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SuperGroupDailyBriefInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SuperGroupDailyBriefInfo(struct soap *soap, const struct __ns1__SuperGroupDailyBriefInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SuperGroupDailyBriefInfo(soap, tag ? tag : "-ns1:SuperGroupDailyBriefInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SuperGroupDailyBriefInfo * SOAP_FMAC4 soap_get___ns1__SuperGroupDailyBriefInfo(struct soap *soap, struct __ns1__SuperGroupDailyBriefInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SuperGroupDailyBriefInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SuperGroupHourlyInfo(struct soap *soap, struct __ns1__SuperGroupHourlyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SuperGroupHourlyInfoRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SuperGroupHourlyInfo(struct soap *soap, const struct __ns1__SuperGroupHourlyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenInfoRequestType(soap, &a->ns1__SuperGroupHourlyInfoRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SuperGroupHourlyInfo(struct soap *soap, const char *tag, int id, const struct __ns1__SuperGroupHourlyInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenInfoRequestType(soap, "ns1:SuperGroupHourlyInfoRequest", -1, &a->ns1__SuperGroupHourlyInfoRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SuperGroupHourlyInfo * SOAP_FMAC4 soap_in___ns1__SuperGroupHourlyInfo(struct soap *soap, const char *tag, struct __ns1__SuperGroupHourlyInfo *a, const char *type)
{
	size_t soap_flag_ns1__SuperGroupHourlyInfoRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SuperGroupHourlyInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SuperGroupHourlyInfo, sizeof(struct __ns1__SuperGroupHourlyInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SuperGroupHourlyInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SuperGroupHourlyInfoRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenInfoRequestType(soap, "ns1:SuperGroupHourlyInfoRequest", &a->ns1__SuperGroupHourlyInfoRequest, "ns1:GenInfoRequestType"))
				{	soap_flag_ns1__SuperGroupHourlyInfoRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SuperGroupHourlyInfo * SOAP_FMAC2 soap_instantiate___ns1__SuperGroupHourlyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SuperGroupHourlyInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SuperGroupHourlyInfo *p;
	size_t k = sizeof(struct __ns1__SuperGroupHourlyInfo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SuperGroupHourlyInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SuperGroupHourlyInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SuperGroupHourlyInfo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SuperGroupHourlyInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SuperGroupHourlyInfo(struct soap *soap, const struct __ns1__SuperGroupHourlyInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SuperGroupHourlyInfo(soap, tag ? tag : "-ns1:SuperGroupHourlyInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SuperGroupHourlyInfo * SOAP_FMAC4 soap_get___ns1__SuperGroupHourlyInfo(struct soap *soap, struct __ns1__SuperGroupHourlyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SuperGroupHourlyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GroupDailyDetailedInfo(struct soap *soap, struct __ns1__GroupDailyDetailedInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GroupDailyDetailedInfoRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GroupDailyDetailedInfo(struct soap *soap, const struct __ns1__GroupDailyDetailedInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenInfoRequestType(soap, &a->ns1__GroupDailyDetailedInfoRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GroupDailyDetailedInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GroupDailyDetailedInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenInfoRequestType(soap, "ns1:GroupDailyDetailedInfoRequest", -1, &a->ns1__GroupDailyDetailedInfoRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GroupDailyDetailedInfo * SOAP_FMAC4 soap_in___ns1__GroupDailyDetailedInfo(struct soap *soap, const char *tag, struct __ns1__GroupDailyDetailedInfo *a, const char *type)
{
	size_t soap_flag_ns1__GroupDailyDetailedInfoRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GroupDailyDetailedInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GroupDailyDetailedInfo, sizeof(struct __ns1__GroupDailyDetailedInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GroupDailyDetailedInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GroupDailyDetailedInfoRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenInfoRequestType(soap, "ns1:GroupDailyDetailedInfoRequest", &a->ns1__GroupDailyDetailedInfoRequest, "ns1:GenInfoRequestType"))
				{	soap_flag_ns1__GroupDailyDetailedInfoRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GroupDailyDetailedInfo * SOAP_FMAC2 soap_instantiate___ns1__GroupDailyDetailedInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GroupDailyDetailedInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GroupDailyDetailedInfo *p;
	size_t k = sizeof(struct __ns1__GroupDailyDetailedInfo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GroupDailyDetailedInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GroupDailyDetailedInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GroupDailyDetailedInfo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GroupDailyDetailedInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GroupDailyDetailedInfo(struct soap *soap, const struct __ns1__GroupDailyDetailedInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GroupDailyDetailedInfo(soap, tag ? tag : "-ns1:GroupDailyDetailedInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GroupDailyDetailedInfo * SOAP_FMAC4 soap_get___ns1__GroupDailyDetailedInfo(struct soap *soap, struct __ns1__GroupDailyDetailedInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GroupDailyDetailedInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GroupDailyBriefInfo(struct soap *soap, struct __ns1__GroupDailyBriefInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GroupDailyBriefInfoRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GroupDailyBriefInfo(struct soap *soap, const struct __ns1__GroupDailyBriefInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenInfoRequestType(soap, &a->ns1__GroupDailyBriefInfoRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GroupDailyBriefInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GroupDailyBriefInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenInfoRequestType(soap, "ns1:GroupDailyBriefInfoRequest", -1, &a->ns1__GroupDailyBriefInfoRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GroupDailyBriefInfo * SOAP_FMAC4 soap_in___ns1__GroupDailyBriefInfo(struct soap *soap, const char *tag, struct __ns1__GroupDailyBriefInfo *a, const char *type)
{
	size_t soap_flag_ns1__GroupDailyBriefInfoRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GroupDailyBriefInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GroupDailyBriefInfo, sizeof(struct __ns1__GroupDailyBriefInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GroupDailyBriefInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GroupDailyBriefInfoRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenInfoRequestType(soap, "ns1:GroupDailyBriefInfoRequest", &a->ns1__GroupDailyBriefInfoRequest, "ns1:GenInfoRequestType"))
				{	soap_flag_ns1__GroupDailyBriefInfoRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GroupDailyBriefInfo * SOAP_FMAC2 soap_instantiate___ns1__GroupDailyBriefInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GroupDailyBriefInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GroupDailyBriefInfo *p;
	size_t k = sizeof(struct __ns1__GroupDailyBriefInfo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GroupDailyBriefInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GroupDailyBriefInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GroupDailyBriefInfo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GroupDailyBriefInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GroupDailyBriefInfo(struct soap *soap, const struct __ns1__GroupDailyBriefInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GroupDailyBriefInfo(soap, tag ? tag : "-ns1:GroupDailyBriefInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GroupDailyBriefInfo * SOAP_FMAC4 soap_get___ns1__GroupDailyBriefInfo(struct soap *soap, struct __ns1__GroupDailyBriefInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GroupDailyBriefInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GroupHourlyInfo(struct soap *soap, struct __ns1__GroupHourlyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GroupHourlyInfoRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GroupHourlyInfo(struct soap *soap, const struct __ns1__GroupHourlyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenInfoRequestType(soap, &a->ns1__GroupHourlyInfoRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GroupHourlyInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GroupHourlyInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenInfoRequestType(soap, "ns1:GroupHourlyInfoRequest", -1, &a->ns1__GroupHourlyInfoRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GroupHourlyInfo * SOAP_FMAC4 soap_in___ns1__GroupHourlyInfo(struct soap *soap, const char *tag, struct __ns1__GroupHourlyInfo *a, const char *type)
{
	size_t soap_flag_ns1__GroupHourlyInfoRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GroupHourlyInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GroupHourlyInfo, sizeof(struct __ns1__GroupHourlyInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GroupHourlyInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GroupHourlyInfoRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenInfoRequestType(soap, "ns1:GroupHourlyInfoRequest", &a->ns1__GroupHourlyInfoRequest, "ns1:GenInfoRequestType"))
				{	soap_flag_ns1__GroupHourlyInfoRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GroupHourlyInfo * SOAP_FMAC2 soap_instantiate___ns1__GroupHourlyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GroupHourlyInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GroupHourlyInfo *p;
	size_t k = sizeof(struct __ns1__GroupHourlyInfo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GroupHourlyInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GroupHourlyInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GroupHourlyInfo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GroupHourlyInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GroupHourlyInfo(struct soap *soap, const struct __ns1__GroupHourlyInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GroupHourlyInfo(soap, tag ? tag : "-ns1:GroupHourlyInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GroupHourlyInfo * SOAP_FMAC4 soap_get___ns1__GroupHourlyInfo(struct soap *soap, struct __ns1__GroupHourlyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GroupHourlyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__AgentNeedHelp(struct soap *soap, struct __ns1__AgentNeedHelp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AgentNeedHelpRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__AgentNeedHelp(struct soap *soap, const struct __ns1__AgentNeedHelp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__BriefInfoRequestType(soap, &a->ns1__AgentNeedHelpRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__AgentNeedHelp(struct soap *soap, const char *tag, int id, const struct __ns1__AgentNeedHelp *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__BriefInfoRequestType(soap, "ns1:AgentNeedHelpRequest", -1, &a->ns1__AgentNeedHelpRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AgentNeedHelp * SOAP_FMAC4 soap_in___ns1__AgentNeedHelp(struct soap *soap, const char *tag, struct __ns1__AgentNeedHelp *a, const char *type)
{
	size_t soap_flag_ns1__AgentNeedHelpRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__AgentNeedHelp *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__AgentNeedHelp, sizeof(struct __ns1__AgentNeedHelp), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__AgentNeedHelp(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AgentNeedHelpRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__BriefInfoRequestType(soap, "ns1:AgentNeedHelpRequest", &a->ns1__AgentNeedHelpRequest, "ns1:BriefInfoRequestType"))
				{	soap_flag_ns1__AgentNeedHelpRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__AgentNeedHelp * SOAP_FMAC2 soap_instantiate___ns1__AgentNeedHelp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__AgentNeedHelp(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__AgentNeedHelp *p;
	size_t k = sizeof(struct __ns1__AgentNeedHelp);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__AgentNeedHelp);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__AgentNeedHelp, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__AgentNeedHelp location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__AgentNeedHelp, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__AgentNeedHelp(struct soap *soap, const struct __ns1__AgentNeedHelp *a, const char *tag, const char *type)
{
	if (soap_out___ns1__AgentNeedHelp(soap, tag ? tag : "-ns1:AgentNeedHelp", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AgentNeedHelp * SOAP_FMAC4 soap_get___ns1__AgentNeedHelp(struct soap *soap, struct __ns1__AgentNeedHelp *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__AgentNeedHelp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__TraceInternalStat(struct soap *soap, struct __ns1__TraceInternalStat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__TraceInternalStatRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__TraceInternalStat(struct soap *soap, const struct __ns1__TraceInternalStat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__StatRequestType(soap, &a->ns1__TraceInternalStatRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__TraceInternalStat(struct soap *soap, const char *tag, int id, const struct __ns1__TraceInternalStat *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__StatRequestType(soap, "ns1:TraceInternalStatRequest", -1, &a->ns1__TraceInternalStatRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TraceInternalStat * SOAP_FMAC4 soap_in___ns1__TraceInternalStat(struct soap *soap, const char *tag, struct __ns1__TraceInternalStat *a, const char *type)
{
	size_t soap_flag_ns1__TraceInternalStatRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__TraceInternalStat *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__TraceInternalStat, sizeof(struct __ns1__TraceInternalStat), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__TraceInternalStat(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__TraceInternalStatRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__StatRequestType(soap, "ns1:TraceInternalStatRequest", &a->ns1__TraceInternalStatRequest, "ns1:StatRequestType"))
				{	soap_flag_ns1__TraceInternalStatRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__TraceInternalStat * SOAP_FMAC2 soap_instantiate___ns1__TraceInternalStat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__TraceInternalStat(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__TraceInternalStat *p;
	size_t k = sizeof(struct __ns1__TraceInternalStat);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__TraceInternalStat);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__TraceInternalStat, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__TraceInternalStat location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__TraceInternalStat, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__TraceInternalStat(struct soap *soap, const struct __ns1__TraceInternalStat *a, const char *tag, const char *type)
{
	if (soap_out___ns1__TraceInternalStat(soap, tag ? tag : "-ns1:TraceInternalStat", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TraceInternalStat * SOAP_FMAC4 soap_get___ns1__TraceInternalStat(struct soap *soap, struct __ns1__TraceInternalStat *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__TraceInternalStat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ApplicationKeepAlive(struct soap *soap, struct __ns1__ApplicationKeepAlive *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ApplicationKeepAliveRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ApplicationKeepAlive(struct soap *soap, const struct __ns1__ApplicationKeepAlive *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApplicationKeepAliveRequestType(soap, &a->ns1__ApplicationKeepAliveRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ApplicationKeepAlive(struct soap *soap, const char *tag, int id, const struct __ns1__ApplicationKeepAlive *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__ApplicationKeepAliveRequestType(soap, "ns1:ApplicationKeepAliveRequest", -1, &a->ns1__ApplicationKeepAliveRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ApplicationKeepAlive * SOAP_FMAC4 soap_in___ns1__ApplicationKeepAlive(struct soap *soap, const char *tag, struct __ns1__ApplicationKeepAlive *a, const char *type)
{
	size_t soap_flag_ns1__ApplicationKeepAliveRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ApplicationKeepAlive *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ApplicationKeepAlive, sizeof(struct __ns1__ApplicationKeepAlive), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ApplicationKeepAlive(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ApplicationKeepAliveRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApplicationKeepAliveRequestType(soap, "ns1:ApplicationKeepAliveRequest", &a->ns1__ApplicationKeepAliveRequest, "ns1:ApplicationKeepAliveRequestType"))
				{	soap_flag_ns1__ApplicationKeepAliveRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ApplicationKeepAlive * SOAP_FMAC2 soap_instantiate___ns1__ApplicationKeepAlive(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ApplicationKeepAlive(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ApplicationKeepAlive *p;
	size_t k = sizeof(struct __ns1__ApplicationKeepAlive);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ApplicationKeepAlive);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ApplicationKeepAlive, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ApplicationKeepAlive location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__ApplicationKeepAlive, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ApplicationKeepAlive(struct soap *soap, const struct __ns1__ApplicationKeepAlive *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ApplicationKeepAlive(soap, tag ? tag : "-ns1:ApplicationKeepAlive", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ApplicationKeepAlive * SOAP_FMAC4 soap_get___ns1__ApplicationKeepAlive(struct soap *soap, struct __ns1__ApplicationKeepAlive *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ApplicationKeepAlive(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ApplicationRegister(struct soap *soap, struct __ns1__ApplicationRegister *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ApplicationRegisterRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ApplicationRegister(struct soap *soap, const struct __ns1__ApplicationRegister *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ApplicationRegisterRequestType(soap, &a->ns1__ApplicationRegisterRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ApplicationRegister(struct soap *soap, const char *tag, int id, const struct __ns1__ApplicationRegister *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__ApplicationRegisterRequestType(soap, "ns1:ApplicationRegisterRequest", -1, &a->ns1__ApplicationRegisterRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ApplicationRegister * SOAP_FMAC4 soap_in___ns1__ApplicationRegister(struct soap *soap, const char *tag, struct __ns1__ApplicationRegister *a, const char *type)
{
	size_t soap_flag_ns1__ApplicationRegisterRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ApplicationRegister *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ApplicationRegister, sizeof(struct __ns1__ApplicationRegister), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ApplicationRegister(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ApplicationRegisterRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ApplicationRegisterRequestType(soap, "ns1:ApplicationRegisterRequest", &a->ns1__ApplicationRegisterRequest, "ns1:ApplicationRegisterRequestType"))
				{	soap_flag_ns1__ApplicationRegisterRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ApplicationRegister * SOAP_FMAC2 soap_instantiate___ns1__ApplicationRegister(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ApplicationRegister(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ApplicationRegister *p;
	size_t k = sizeof(struct __ns1__ApplicationRegister);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ApplicationRegister);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ApplicationRegister, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ApplicationRegister location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__ApplicationRegister, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ApplicationRegister(struct soap *soap, const struct __ns1__ApplicationRegister *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ApplicationRegister(soap, tag ? tag : "-ns1:ApplicationRegister", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ApplicationRegister * SOAP_FMAC4 soap_get___ns1__ApplicationRegister(struct soap *soap, struct __ns1__ApplicationRegister *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ApplicationRegister(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__LoginManagerAvailableGroupsForAgent(struct soap *soap, struct __ns1__LoginManagerAvailableGroupsForAgent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__LoginManagerRequestAvailableGroups = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__LoginManagerAvailableGroupsForAgent(struct soap *soap, const struct __ns1__LoginManagerAvailableGroupsForAgent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__LoginManagerRequestType(soap, &a->ns1__LoginManagerRequestAvailableGroups);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__LoginManagerAvailableGroupsForAgent(struct soap *soap, const char *tag, int id, const struct __ns1__LoginManagerAvailableGroupsForAgent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__LoginManagerRequestType(soap, "ns1:LoginManagerRequestAvailableGroups", -1, &a->ns1__LoginManagerRequestAvailableGroups, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LoginManagerAvailableGroupsForAgent * SOAP_FMAC4 soap_in___ns1__LoginManagerAvailableGroupsForAgent(struct soap *soap, const char *tag, struct __ns1__LoginManagerAvailableGroupsForAgent *a, const char *type)
{
	size_t soap_flag_ns1__LoginManagerRequestAvailableGroups = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__LoginManagerAvailableGroupsForAgent *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__LoginManagerAvailableGroupsForAgent, sizeof(struct __ns1__LoginManagerAvailableGroupsForAgent), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__LoginManagerAvailableGroupsForAgent(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__LoginManagerRequestAvailableGroups && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__LoginManagerRequestType(soap, "ns1:LoginManagerRequestAvailableGroups", &a->ns1__LoginManagerRequestAvailableGroups, "ns1:LoginManagerRequestType"))
				{	soap_flag_ns1__LoginManagerRequestAvailableGroups--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__LoginManagerAvailableGroupsForAgent * SOAP_FMAC2 soap_instantiate___ns1__LoginManagerAvailableGroupsForAgent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__LoginManagerAvailableGroupsForAgent(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__LoginManagerAvailableGroupsForAgent *p;
	size_t k = sizeof(struct __ns1__LoginManagerAvailableGroupsForAgent);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__LoginManagerAvailableGroupsForAgent);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__LoginManagerAvailableGroupsForAgent, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__LoginManagerAvailableGroupsForAgent location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__LoginManagerAvailableGroupsForAgent, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__LoginManagerAvailableGroupsForAgent(struct soap *soap, const struct __ns1__LoginManagerAvailableGroupsForAgent *a, const char *tag, const char *type)
{
	if (soap_out___ns1__LoginManagerAvailableGroupsForAgent(soap, tag ? tag : "-ns1:LoginManagerAvailableGroupsForAgent", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LoginManagerAvailableGroupsForAgent * SOAP_FMAC4 soap_get___ns1__LoginManagerAvailableGroupsForAgent(struct soap *soap, struct __ns1__LoginManagerAvailableGroupsForAgent *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__LoginManagerAvailableGroupsForAgent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__LoginManagerAvailableAgentsForGroup(struct soap *soap, struct __ns1__LoginManagerAvailableAgentsForGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__LoginManagerRequestAvailableAgents = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__LoginManagerAvailableAgentsForGroup(struct soap *soap, const struct __ns1__LoginManagerAvailableAgentsForGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__LoginManagerRequestType(soap, &a->ns1__LoginManagerRequestAvailableAgents);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__LoginManagerAvailableAgentsForGroup(struct soap *soap, const char *tag, int id, const struct __ns1__LoginManagerAvailableAgentsForGroup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__LoginManagerRequestType(soap, "ns1:LoginManagerRequestAvailableAgents", -1, &a->ns1__LoginManagerRequestAvailableAgents, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LoginManagerAvailableAgentsForGroup * SOAP_FMAC4 soap_in___ns1__LoginManagerAvailableAgentsForGroup(struct soap *soap, const char *tag, struct __ns1__LoginManagerAvailableAgentsForGroup *a, const char *type)
{
	size_t soap_flag_ns1__LoginManagerRequestAvailableAgents = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__LoginManagerAvailableAgentsForGroup *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__LoginManagerAvailableAgentsForGroup, sizeof(struct __ns1__LoginManagerAvailableAgentsForGroup), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__LoginManagerAvailableAgentsForGroup(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__LoginManagerRequestAvailableAgents && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__LoginManagerRequestType(soap, "ns1:LoginManagerRequestAvailableAgents", &a->ns1__LoginManagerRequestAvailableAgents, "ns1:LoginManagerRequestType"))
				{	soap_flag_ns1__LoginManagerRequestAvailableAgents--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__LoginManagerAvailableAgentsForGroup * SOAP_FMAC2 soap_instantiate___ns1__LoginManagerAvailableAgentsForGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__LoginManagerAvailableAgentsForGroup(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__LoginManagerAvailableAgentsForGroup *p;
	size_t k = sizeof(struct __ns1__LoginManagerAvailableAgentsForGroup);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__LoginManagerAvailableAgentsForGroup);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__LoginManagerAvailableAgentsForGroup, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__LoginManagerAvailableAgentsForGroup location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__LoginManagerAvailableAgentsForGroup, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__LoginManagerAvailableAgentsForGroup(struct soap *soap, const struct __ns1__LoginManagerAvailableAgentsForGroup *a, const char *tag, const char *type)
{
	if (soap_out___ns1__LoginManagerAvailableAgentsForGroup(soap, tag ? tag : "-ns1:LoginManagerAvailableAgentsForGroup", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LoginManagerAvailableAgentsForGroup * SOAP_FMAC4 soap_get___ns1__LoginManagerAvailableAgentsForGroup(struct soap *soap, struct __ns1__LoginManagerAvailableAgentsForGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__LoginManagerAvailableAgentsForGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__LoginManagerMultiAgentsToOneGroup(struct soap *soap, struct __ns1__LoginManagerMultiAgentsToOneGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__LoginLogoutRequestAcdMultiAgents = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__LoginManagerMultiAgentsToOneGroup(struct soap *soap, const struct __ns1__LoginManagerMultiAgentsToOneGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ACDMultiRequestType(soap, &a->ns1__LoginLogoutRequestAcdMultiAgents);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__LoginManagerMultiAgentsToOneGroup(struct soap *soap, const char *tag, int id, const struct __ns1__LoginManagerMultiAgentsToOneGroup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__ACDMultiRequestType(soap, "ns1:LoginLogoutRequestAcdMultiAgents", -1, &a->ns1__LoginLogoutRequestAcdMultiAgents, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LoginManagerMultiAgentsToOneGroup * SOAP_FMAC4 soap_in___ns1__LoginManagerMultiAgentsToOneGroup(struct soap *soap, const char *tag, struct __ns1__LoginManagerMultiAgentsToOneGroup *a, const char *type)
{
	size_t soap_flag_ns1__LoginLogoutRequestAcdMultiAgents = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__LoginManagerMultiAgentsToOneGroup *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__LoginManagerMultiAgentsToOneGroup, sizeof(struct __ns1__LoginManagerMultiAgentsToOneGroup), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__LoginManagerMultiAgentsToOneGroup(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__LoginLogoutRequestAcdMultiAgents && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ACDMultiRequestType(soap, "ns1:LoginLogoutRequestAcdMultiAgents", &a->ns1__LoginLogoutRequestAcdMultiAgents, "ns1:ACDMultiRequestType"))
				{	soap_flag_ns1__LoginLogoutRequestAcdMultiAgents--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__LoginManagerMultiAgentsToOneGroup * SOAP_FMAC2 soap_instantiate___ns1__LoginManagerMultiAgentsToOneGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__LoginManagerMultiAgentsToOneGroup(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__LoginManagerMultiAgentsToOneGroup *p;
	size_t k = sizeof(struct __ns1__LoginManagerMultiAgentsToOneGroup);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__LoginManagerMultiAgentsToOneGroup);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__LoginManagerMultiAgentsToOneGroup, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__LoginManagerMultiAgentsToOneGroup location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__LoginManagerMultiAgentsToOneGroup, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__LoginManagerMultiAgentsToOneGroup(struct soap *soap, const struct __ns1__LoginManagerMultiAgentsToOneGroup *a, const char *tag, const char *type)
{
	if (soap_out___ns1__LoginManagerMultiAgentsToOneGroup(soap, tag ? tag : "-ns1:LoginManagerMultiAgentsToOneGroup", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LoginManagerMultiAgentsToOneGroup * SOAP_FMAC4 soap_get___ns1__LoginManagerMultiAgentsToOneGroup(struct soap *soap, struct __ns1__LoginManagerMultiAgentsToOneGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__LoginManagerMultiAgentsToOneGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__LoginManagerOneAgentToMultiGroups(struct soap *soap, struct __ns1__LoginManagerOneAgentToMultiGroups *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__LoginLogoutRequestAcdOneAgent = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__LoginManagerOneAgentToMultiGroups(struct soap *soap, const struct __ns1__LoginManagerOneAgentToMultiGroups *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ACDMultiRequestType(soap, &a->ns1__LoginLogoutRequestAcdOneAgent);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__LoginManagerOneAgentToMultiGroups(struct soap *soap, const char *tag, int id, const struct __ns1__LoginManagerOneAgentToMultiGroups *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__ACDMultiRequestType(soap, "ns1:LoginLogoutRequestAcdOneAgent", -1, &a->ns1__LoginLogoutRequestAcdOneAgent, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LoginManagerOneAgentToMultiGroups * SOAP_FMAC4 soap_in___ns1__LoginManagerOneAgentToMultiGroups(struct soap *soap, const char *tag, struct __ns1__LoginManagerOneAgentToMultiGroups *a, const char *type)
{
	size_t soap_flag_ns1__LoginLogoutRequestAcdOneAgent = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__LoginManagerOneAgentToMultiGroups *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__LoginManagerOneAgentToMultiGroups, sizeof(struct __ns1__LoginManagerOneAgentToMultiGroups), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__LoginManagerOneAgentToMultiGroups(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__LoginLogoutRequestAcdOneAgent && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ACDMultiRequestType(soap, "ns1:LoginLogoutRequestAcdOneAgent", &a->ns1__LoginLogoutRequestAcdOneAgent, "ns1:ACDMultiRequestType"))
				{	soap_flag_ns1__LoginLogoutRequestAcdOneAgent--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__LoginManagerOneAgentToMultiGroups * SOAP_FMAC2 soap_instantiate___ns1__LoginManagerOneAgentToMultiGroups(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__LoginManagerOneAgentToMultiGroups(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__LoginManagerOneAgentToMultiGroups *p;
	size_t k = sizeof(struct __ns1__LoginManagerOneAgentToMultiGroups);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__LoginManagerOneAgentToMultiGroups);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__LoginManagerOneAgentToMultiGroups, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__LoginManagerOneAgentToMultiGroups location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__LoginManagerOneAgentToMultiGroups, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__LoginManagerOneAgentToMultiGroups(struct soap *soap, const struct __ns1__LoginManagerOneAgentToMultiGroups *a, const char *tag, const char *type)
{
	if (soap_out___ns1__LoginManagerOneAgentToMultiGroups(soap, tag ? tag : "-ns1:LoginManagerOneAgentToMultiGroups", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LoginManagerOneAgentToMultiGroups * SOAP_FMAC4 soap_get___ns1__LoginManagerOneAgentToMultiGroups(struct soap *soap, struct __ns1__LoginManagerOneAgentToMultiGroups *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__LoginManagerOneAgentToMultiGroups(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__LoginManagerGroupsPerAgent(struct soap *soap, struct __ns1__LoginManagerGroupsPerAgent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__LoginManagerRequestGroups = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__LoginManagerGroupsPerAgent(struct soap *soap, const struct __ns1__LoginManagerGroupsPerAgent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__LoginManagerRequestType(soap, &a->ns1__LoginManagerRequestGroups);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__LoginManagerGroupsPerAgent(struct soap *soap, const char *tag, int id, const struct __ns1__LoginManagerGroupsPerAgent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__LoginManagerRequestType(soap, "ns1:LoginManagerRequestGroups", -1, &a->ns1__LoginManagerRequestGroups, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LoginManagerGroupsPerAgent * SOAP_FMAC4 soap_in___ns1__LoginManagerGroupsPerAgent(struct soap *soap, const char *tag, struct __ns1__LoginManagerGroupsPerAgent *a, const char *type)
{
	size_t soap_flag_ns1__LoginManagerRequestGroups = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__LoginManagerGroupsPerAgent *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__LoginManagerGroupsPerAgent, sizeof(struct __ns1__LoginManagerGroupsPerAgent), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__LoginManagerGroupsPerAgent(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__LoginManagerRequestGroups && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__LoginManagerRequestType(soap, "ns1:LoginManagerRequestGroups", &a->ns1__LoginManagerRequestGroups, "ns1:LoginManagerRequestType"))
				{	soap_flag_ns1__LoginManagerRequestGroups--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__LoginManagerGroupsPerAgent * SOAP_FMAC2 soap_instantiate___ns1__LoginManagerGroupsPerAgent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__LoginManagerGroupsPerAgent(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__LoginManagerGroupsPerAgent *p;
	size_t k = sizeof(struct __ns1__LoginManagerGroupsPerAgent);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__LoginManagerGroupsPerAgent);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__LoginManagerGroupsPerAgent, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__LoginManagerGroupsPerAgent location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__LoginManagerGroupsPerAgent, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__LoginManagerGroupsPerAgent(struct soap *soap, const struct __ns1__LoginManagerGroupsPerAgent *a, const char *tag, const char *type)
{
	if (soap_out___ns1__LoginManagerGroupsPerAgent(soap, tag ? tag : "-ns1:LoginManagerGroupsPerAgent", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LoginManagerGroupsPerAgent * SOAP_FMAC4 soap_get___ns1__LoginManagerGroupsPerAgent(struct soap *soap, struct __ns1__LoginManagerGroupsPerAgent *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__LoginManagerGroupsPerAgent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__LoginManagerAgentsPerGroup(struct soap *soap, struct __ns1__LoginManagerAgentsPerGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__LoginManagerRequestAgents = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__LoginManagerAgentsPerGroup(struct soap *soap, const struct __ns1__LoginManagerAgentsPerGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__LoginManagerRequestType(soap, &a->ns1__LoginManagerRequestAgents);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__LoginManagerAgentsPerGroup(struct soap *soap, const char *tag, int id, const struct __ns1__LoginManagerAgentsPerGroup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__LoginManagerRequestType(soap, "ns1:LoginManagerRequestAgents", -1, &a->ns1__LoginManagerRequestAgents, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LoginManagerAgentsPerGroup * SOAP_FMAC4 soap_in___ns1__LoginManagerAgentsPerGroup(struct soap *soap, const char *tag, struct __ns1__LoginManagerAgentsPerGroup *a, const char *type)
{
	size_t soap_flag_ns1__LoginManagerRequestAgents = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__LoginManagerAgentsPerGroup *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__LoginManagerAgentsPerGroup, sizeof(struct __ns1__LoginManagerAgentsPerGroup), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__LoginManagerAgentsPerGroup(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__LoginManagerRequestAgents && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__LoginManagerRequestType(soap, "ns1:LoginManagerRequestAgents", &a->ns1__LoginManagerRequestAgents, "ns1:LoginManagerRequestType"))
				{	soap_flag_ns1__LoginManagerRequestAgents--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__LoginManagerAgentsPerGroup * SOAP_FMAC2 soap_instantiate___ns1__LoginManagerAgentsPerGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__LoginManagerAgentsPerGroup(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__LoginManagerAgentsPerGroup *p;
	size_t k = sizeof(struct __ns1__LoginManagerAgentsPerGroup);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__LoginManagerAgentsPerGroup);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__LoginManagerAgentsPerGroup, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__LoginManagerAgentsPerGroup location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__LoginManagerAgentsPerGroup, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__LoginManagerAgentsPerGroup(struct soap *soap, const struct __ns1__LoginManagerAgentsPerGroup *a, const char *tag, const char *type)
{
	if (soap_out___ns1__LoginManagerAgentsPerGroup(soap, tag ? tag : "-ns1:LoginManagerAgentsPerGroup", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LoginManagerAgentsPerGroup * SOAP_FMAC4 soap_get___ns1__LoginManagerAgentsPerGroup(struct soap *soap, struct __ns1__LoginManagerAgentsPerGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__LoginManagerAgentsPerGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DeleteReport(struct soap *soap, struct __ns1__DeleteReport *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestDeleteReport = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DeleteReport(struct soap *soap, const struct __ns1__DeleteReport *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RequestDeleteReportType(soap, &a->ns1__RequestDeleteReport);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DeleteReport(struct soap *soap, const char *tag, int id, const struct __ns1__DeleteReport *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__RequestDeleteReportType(soap, "ns1:RequestDeleteReport", -1, &a->ns1__RequestDeleteReport, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DeleteReport * SOAP_FMAC4 soap_in___ns1__DeleteReport(struct soap *soap, const char *tag, struct __ns1__DeleteReport *a, const char *type)
{
	size_t soap_flag_ns1__RequestDeleteReport = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DeleteReport *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DeleteReport, sizeof(struct __ns1__DeleteReport), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DeleteReport(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestDeleteReport && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RequestDeleteReportType(soap, "ns1:RequestDeleteReport", &a->ns1__RequestDeleteReport, "ns1:RequestDeleteReportType"))
				{	soap_flag_ns1__RequestDeleteReport--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DeleteReport * SOAP_FMAC2 soap_instantiate___ns1__DeleteReport(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DeleteReport(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DeleteReport *p;
	size_t k = sizeof(struct __ns1__DeleteReport);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__DeleteReport);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__DeleteReport, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DeleteReport location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__DeleteReport, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DeleteReport(struct soap *soap, const struct __ns1__DeleteReport *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DeleteReport(soap, tag ? tag : "-ns1:DeleteReport", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DeleteReport * SOAP_FMAC4 soap_get___ns1__DeleteReport(struct soap *soap, struct __ns1__DeleteReport *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DeleteReport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SaveReport(struct soap *soap, struct __ns1__SaveReport *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestSaveReport = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SaveReport(struct soap *soap, const struct __ns1__SaveReport *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RequestSaveReportType(soap, &a->ns1__RequestSaveReport);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SaveReport(struct soap *soap, const char *tag, int id, const struct __ns1__SaveReport *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__RequestSaveReportType(soap, "ns1:RequestSaveReport", -1, &a->ns1__RequestSaveReport, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SaveReport * SOAP_FMAC4 soap_in___ns1__SaveReport(struct soap *soap, const char *tag, struct __ns1__SaveReport *a, const char *type)
{
	size_t soap_flag_ns1__RequestSaveReport = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SaveReport *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SaveReport, sizeof(struct __ns1__SaveReport), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SaveReport(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestSaveReport && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__RequestSaveReportType(soap, "ns1:RequestSaveReport", &a->ns1__RequestSaveReport, "ns1:RequestSaveReportType"))
				{	soap_flag_ns1__RequestSaveReport--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SaveReport * SOAP_FMAC2 soap_instantiate___ns1__SaveReport(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SaveReport(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SaveReport *p;
	size_t k = sizeof(struct __ns1__SaveReport);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SaveReport);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SaveReport, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SaveReport location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SaveReport, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SaveReport(struct soap *soap, const struct __ns1__SaveReport *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SaveReport(soap, tag ? tag : "-ns1:SaveReport", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SaveReport * SOAP_FMAC4 soap_get___ns1__SaveReport(struct soap *soap, struct __ns1__SaveReport *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SaveReport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SaveWorkspase(struct soap *soap, struct __ns1__SaveWorkspase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestSaveWorkspase = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SaveWorkspase(struct soap *soap, const struct __ns1__SaveWorkspase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SaveWorkspaseRequestType(soap, &a->ns1__RequestSaveWorkspase);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SaveWorkspase(struct soap *soap, const char *tag, int id, const struct __ns1__SaveWorkspase *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SaveWorkspaseRequestType(soap, "ns1:RequestSaveWorkspase", -1, &a->ns1__RequestSaveWorkspase, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SaveWorkspase * SOAP_FMAC4 soap_in___ns1__SaveWorkspase(struct soap *soap, const char *tag, struct __ns1__SaveWorkspase *a, const char *type)
{
	size_t soap_flag_ns1__RequestSaveWorkspase = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SaveWorkspase *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SaveWorkspase, sizeof(struct __ns1__SaveWorkspase), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SaveWorkspase(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestSaveWorkspase && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SaveWorkspaseRequestType(soap, "ns1:RequestSaveWorkspase", &a->ns1__RequestSaveWorkspase, "ns1:SaveWorkspaseRequestType"))
				{	soap_flag_ns1__RequestSaveWorkspase--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SaveWorkspase * SOAP_FMAC2 soap_instantiate___ns1__SaveWorkspase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SaveWorkspase(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SaveWorkspase *p;
	size_t k = sizeof(struct __ns1__SaveWorkspase);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SaveWorkspase);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SaveWorkspase, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SaveWorkspase location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SaveWorkspase, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SaveWorkspase(struct soap *soap, const struct __ns1__SaveWorkspase *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SaveWorkspase(soap, tag ? tag : "-ns1:SaveWorkspase", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SaveWorkspase * SOAP_FMAC4 soap_get___ns1__SaveWorkspase(struct soap *soap, struct __ns1__SaveWorkspase *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SaveWorkspase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CommandAgentTelephonyFeatures(struct soap *soap, struct __ns1__CommandAgentTelephonyFeatures *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestTf = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CommandAgentTelephonyFeatures(struct soap *soap, const struct __ns1__CommandAgentTelephonyFeatures *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__TFRequestType(soap, &a->ns1__RequestTf);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CommandAgentTelephonyFeatures(struct soap *soap, const char *tag, int id, const struct __ns1__CommandAgentTelephonyFeatures *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__TFRequestType(soap, "ns1:RequestTf", -1, &a->ns1__RequestTf, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CommandAgentTelephonyFeatures * SOAP_FMAC4 soap_in___ns1__CommandAgentTelephonyFeatures(struct soap *soap, const char *tag, struct __ns1__CommandAgentTelephonyFeatures *a, const char *type)
{
	size_t soap_flag_ns1__RequestTf = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CommandAgentTelephonyFeatures *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CommandAgentTelephonyFeatures, sizeof(struct __ns1__CommandAgentTelephonyFeatures), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CommandAgentTelephonyFeatures(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestTf && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__TFRequestType(soap, "ns1:RequestTf", &a->ns1__RequestTf, "ns1:TFRequestType"))
				{	soap_flag_ns1__RequestTf--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CommandAgentTelephonyFeatures * SOAP_FMAC2 soap_instantiate___ns1__CommandAgentTelephonyFeatures(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CommandAgentTelephonyFeatures(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CommandAgentTelephonyFeatures *p;
	size_t k = sizeof(struct __ns1__CommandAgentTelephonyFeatures);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__CommandAgentTelephonyFeatures);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__CommandAgentTelephonyFeatures, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CommandAgentTelephonyFeatures location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__CommandAgentTelephonyFeatures, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CommandAgentTelephonyFeatures(struct soap *soap, const struct __ns1__CommandAgentTelephonyFeatures *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CommandAgentTelephonyFeatures(soap, tag ? tag : "-ns1:CommandAgentTelephonyFeatures", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CommandAgentTelephonyFeatures * SOAP_FMAC4 soap_get___ns1__CommandAgentTelephonyFeatures(struct soap *soap, struct __ns1__CommandAgentTelephonyFeatures *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CommandAgentTelephonyFeatures(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CommandAgentStartRecord(struct soap *soap, struct __ns1__CommandAgentStartRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__StartRecordRequestAcd = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CommandAgentStartRecord(struct soap *soap, const struct __ns1__CommandAgentStartRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__TFRequestType(soap, &a->ns1__StartRecordRequestAcd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CommandAgentStartRecord(struct soap *soap, const char *tag, int id, const struct __ns1__CommandAgentStartRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__TFRequestType(soap, "ns1:StartRecordRequestAcd", -1, &a->ns1__StartRecordRequestAcd, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CommandAgentStartRecord * SOAP_FMAC4 soap_in___ns1__CommandAgentStartRecord(struct soap *soap, const char *tag, struct __ns1__CommandAgentStartRecord *a, const char *type)
{
	size_t soap_flag_ns1__StartRecordRequestAcd = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CommandAgentStartRecord *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CommandAgentStartRecord, sizeof(struct __ns1__CommandAgentStartRecord), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CommandAgentStartRecord(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__StartRecordRequestAcd && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__TFRequestType(soap, "ns1:StartRecordRequestAcd", &a->ns1__StartRecordRequestAcd, "ns1:TFRequestType"))
				{	soap_flag_ns1__StartRecordRequestAcd--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CommandAgentStartRecord * SOAP_FMAC2 soap_instantiate___ns1__CommandAgentStartRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CommandAgentStartRecord(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CommandAgentStartRecord *p;
	size_t k = sizeof(struct __ns1__CommandAgentStartRecord);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__CommandAgentStartRecord);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__CommandAgentStartRecord, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CommandAgentStartRecord location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__CommandAgentStartRecord, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CommandAgentStartRecord(struct soap *soap, const struct __ns1__CommandAgentStartRecord *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CommandAgentStartRecord(soap, tag ? tag : "-ns1:CommandAgentStartRecord", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CommandAgentStartRecord * SOAP_FMAC4 soap_get___ns1__CommandAgentStartRecord(struct soap *soap, struct __ns1__CommandAgentStartRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CommandAgentStartRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CommandAgentStartChat(struct soap *soap, struct __ns1__CommandAgentStartChat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__StartChatRequestAcd = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CommandAgentStartChat(struct soap *soap, const struct __ns1__CommandAgentStartChat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__TFRequestType(soap, &a->ns1__StartChatRequestAcd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CommandAgentStartChat(struct soap *soap, const char *tag, int id, const struct __ns1__CommandAgentStartChat *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__TFRequestType(soap, "ns1:StartChatRequestAcd", -1, &a->ns1__StartChatRequestAcd, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CommandAgentStartChat * SOAP_FMAC4 soap_in___ns1__CommandAgentStartChat(struct soap *soap, const char *tag, struct __ns1__CommandAgentStartChat *a, const char *type)
{
	size_t soap_flag_ns1__StartChatRequestAcd = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CommandAgentStartChat *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CommandAgentStartChat, sizeof(struct __ns1__CommandAgentStartChat), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CommandAgentStartChat(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__StartChatRequestAcd && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__TFRequestType(soap, "ns1:StartChatRequestAcd", &a->ns1__StartChatRequestAcd, "ns1:TFRequestType"))
				{	soap_flag_ns1__StartChatRequestAcd--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CommandAgentStartChat * SOAP_FMAC2 soap_instantiate___ns1__CommandAgentStartChat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CommandAgentStartChat(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CommandAgentStartChat *p;
	size_t k = sizeof(struct __ns1__CommandAgentStartChat);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__CommandAgentStartChat);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__CommandAgentStartChat, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CommandAgentStartChat location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__CommandAgentStartChat, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CommandAgentStartChat(struct soap *soap, const struct __ns1__CommandAgentStartChat *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CommandAgentStartChat(soap, tag ? tag : "-ns1:CommandAgentStartChat", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CommandAgentStartChat * SOAP_FMAC4 soap_get___ns1__CommandAgentStartChat(struct soap *soap, struct __ns1__CommandAgentStartChat *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CommandAgentStartChat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CommandAgentReleaseResume(struct soap *soap, struct __ns1__CommandAgentReleaseResume *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ReleaseResumeRequestAcd = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CommandAgentReleaseResume(struct soap *soap, const struct __ns1__CommandAgentReleaseResume *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ACDRequestType(soap, &a->ns1__ReleaseResumeRequestAcd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CommandAgentReleaseResume(struct soap *soap, const char *tag, int id, const struct __ns1__CommandAgentReleaseResume *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__ACDRequestType(soap, "ns1:ReleaseResumeRequestAcd", -1, &a->ns1__ReleaseResumeRequestAcd, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CommandAgentReleaseResume * SOAP_FMAC4 soap_in___ns1__CommandAgentReleaseResume(struct soap *soap, const char *tag, struct __ns1__CommandAgentReleaseResume *a, const char *type)
{
	size_t soap_flag_ns1__ReleaseResumeRequestAcd = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CommandAgentReleaseResume *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CommandAgentReleaseResume, sizeof(struct __ns1__CommandAgentReleaseResume), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CommandAgentReleaseResume(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ReleaseResumeRequestAcd && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ACDRequestType(soap, "ns1:ReleaseResumeRequestAcd", &a->ns1__ReleaseResumeRequestAcd, "ns1:ACDRequestType"))
				{	soap_flag_ns1__ReleaseResumeRequestAcd--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CommandAgentReleaseResume * SOAP_FMAC2 soap_instantiate___ns1__CommandAgentReleaseResume(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CommandAgentReleaseResume(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CommandAgentReleaseResume *p;
	size_t k = sizeof(struct __ns1__CommandAgentReleaseResume);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__CommandAgentReleaseResume);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__CommandAgentReleaseResume, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CommandAgentReleaseResume location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__CommandAgentReleaseResume, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CommandAgentReleaseResume(struct soap *soap, const struct __ns1__CommandAgentReleaseResume *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CommandAgentReleaseResume(soap, tag ? tag : "-ns1:CommandAgentReleaseResume", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CommandAgentReleaseResume * SOAP_FMAC4 soap_get___ns1__CommandAgentReleaseResume(struct soap *soap, struct __ns1__CommandAgentReleaseResume *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CommandAgentReleaseResume(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CommandAgentLoginLogout(struct soap *soap, struct __ns1__CommandAgentLoginLogout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__LoginLogoutRequestAcdComandAgent = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CommandAgentLoginLogout(struct soap *soap, const struct __ns1__CommandAgentLoginLogout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ACDMultiRequestType(soap, &a->ns1__LoginLogoutRequestAcdComandAgent);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CommandAgentLoginLogout(struct soap *soap, const char *tag, int id, const struct __ns1__CommandAgentLoginLogout *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__ACDMultiRequestType(soap, "ns1:LoginLogoutRequestAcdComandAgent", -1, &a->ns1__LoginLogoutRequestAcdComandAgent, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CommandAgentLoginLogout * SOAP_FMAC4 soap_in___ns1__CommandAgentLoginLogout(struct soap *soap, const char *tag, struct __ns1__CommandAgentLoginLogout *a, const char *type)
{
	size_t soap_flag_ns1__LoginLogoutRequestAcdComandAgent = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CommandAgentLoginLogout *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CommandAgentLoginLogout, sizeof(struct __ns1__CommandAgentLoginLogout), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CommandAgentLoginLogout(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__LoginLogoutRequestAcdComandAgent && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ACDMultiRequestType(soap, "ns1:LoginLogoutRequestAcdComandAgent", &a->ns1__LoginLogoutRequestAcdComandAgent, "ns1:ACDMultiRequestType"))
				{	soap_flag_ns1__LoginLogoutRequestAcdComandAgent--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CommandAgentLoginLogout * SOAP_FMAC2 soap_instantiate___ns1__CommandAgentLoginLogout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CommandAgentLoginLogout(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CommandAgentLoginLogout *p;
	size_t k = sizeof(struct __ns1__CommandAgentLoginLogout);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__CommandAgentLoginLogout);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__CommandAgentLoginLogout, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CommandAgentLoginLogout location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__CommandAgentLoginLogout, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CommandAgentLoginLogout(struct soap *soap, const struct __ns1__CommandAgentLoginLogout *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CommandAgentLoginLogout(soap, tag ? tag : "-ns1:CommandAgentLoginLogout", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CommandAgentLoginLogout * SOAP_FMAC4 soap_get___ns1__CommandAgentLoginLogout(struct soap *soap, struct __ns1__CommandAgentLoginLogout *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CommandAgentLoginLogout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__BriefEmailDNIS(struct soap *soap, struct __ns1__BriefEmailDNIS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestBriefEMailDNISMatrix = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__BriefEmailDNIS(struct soap *soap, const struct __ns1__BriefEmailDNIS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__BriefInfoRequestType(soap, &a->ns1__RequestBriefEMailDNISMatrix);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__BriefEmailDNIS(struct soap *soap, const char *tag, int id, const struct __ns1__BriefEmailDNIS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__BriefInfoRequestType(soap, "ns1:RequestBriefEMailDNISMatrix", -1, &a->ns1__RequestBriefEMailDNISMatrix, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BriefEmailDNIS * SOAP_FMAC4 soap_in___ns1__BriefEmailDNIS(struct soap *soap, const char *tag, struct __ns1__BriefEmailDNIS *a, const char *type)
{
	size_t soap_flag_ns1__RequestBriefEMailDNISMatrix = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__BriefEmailDNIS *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__BriefEmailDNIS, sizeof(struct __ns1__BriefEmailDNIS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__BriefEmailDNIS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestBriefEMailDNISMatrix && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__BriefInfoRequestType(soap, "ns1:RequestBriefEMailDNISMatrix", &a->ns1__RequestBriefEMailDNISMatrix, "ns1:BriefInfoRequestType"))
				{	soap_flag_ns1__RequestBriefEMailDNISMatrix--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__BriefEmailDNIS * SOAP_FMAC2 soap_instantiate___ns1__BriefEmailDNIS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__BriefEmailDNIS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__BriefEmailDNIS *p;
	size_t k = sizeof(struct __ns1__BriefEmailDNIS);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__BriefEmailDNIS);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__BriefEmailDNIS, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__BriefEmailDNIS location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__BriefEmailDNIS, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__BriefEmailDNIS(struct soap *soap, const struct __ns1__BriefEmailDNIS *a, const char *tag, const char *type)
{
	if (soap_out___ns1__BriefEmailDNIS(soap, tag ? tag : "-ns1:BriefEmailDNIS", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BriefEmailDNIS * SOAP_FMAC4 soap_get___ns1__BriefEmailDNIS(struct soap *soap, struct __ns1__BriefEmailDNIS *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__BriefEmailDNIS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__BriefVoiceDNIS(struct soap *soap, struct __ns1__BriefVoiceDNIS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestBriefVoiceDNISMatrix = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__BriefVoiceDNIS(struct soap *soap, const struct __ns1__BriefVoiceDNIS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__BriefInfoRequestType(soap, &a->ns1__RequestBriefVoiceDNISMatrix);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__BriefVoiceDNIS(struct soap *soap, const char *tag, int id, const struct __ns1__BriefVoiceDNIS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__BriefInfoRequestType(soap, "ns1:RequestBriefVoiceDNISMatrix", -1, &a->ns1__RequestBriefVoiceDNISMatrix, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BriefVoiceDNIS * SOAP_FMAC4 soap_in___ns1__BriefVoiceDNIS(struct soap *soap, const char *tag, struct __ns1__BriefVoiceDNIS *a, const char *type)
{
	size_t soap_flag_ns1__RequestBriefVoiceDNISMatrix = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__BriefVoiceDNIS *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__BriefVoiceDNIS, sizeof(struct __ns1__BriefVoiceDNIS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__BriefVoiceDNIS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestBriefVoiceDNISMatrix && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__BriefInfoRequestType(soap, "ns1:RequestBriefVoiceDNISMatrix", &a->ns1__RequestBriefVoiceDNISMatrix, "ns1:BriefInfoRequestType"))
				{	soap_flag_ns1__RequestBriefVoiceDNISMatrix--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__BriefVoiceDNIS * SOAP_FMAC2 soap_instantiate___ns1__BriefVoiceDNIS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__BriefVoiceDNIS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__BriefVoiceDNIS *p;
	size_t k = sizeof(struct __ns1__BriefVoiceDNIS);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__BriefVoiceDNIS);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__BriefVoiceDNIS, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__BriefVoiceDNIS location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__BriefVoiceDNIS, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__BriefVoiceDNIS(struct soap *soap, const struct __ns1__BriefVoiceDNIS *a, const char *tag, const char *type)
{
	if (soap_out___ns1__BriefVoiceDNIS(soap, tag ? tag : "-ns1:BriefVoiceDNIS", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BriefVoiceDNIS * SOAP_FMAC4 soap_get___ns1__BriefVoiceDNIS(struct soap *soap, struct __ns1__BriefVoiceDNIS *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__BriefVoiceDNIS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__EmailDNISList(struct soap *soap, struct __ns1__EmailDNISList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestEmailDNISList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__EmailDNISList(struct soap *soap, const struct __ns1__EmailDNISList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenRequestType(soap, &a->ns1__RequestEmailDNISList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__EmailDNISList(struct soap *soap, const char *tag, int id, const struct __ns1__EmailDNISList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenRequestType(soap, "ns1:RequestEmailDNISList", -1, &a->ns1__RequestEmailDNISList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EmailDNISList * SOAP_FMAC4 soap_in___ns1__EmailDNISList(struct soap *soap, const char *tag, struct __ns1__EmailDNISList *a, const char *type)
{
	size_t soap_flag_ns1__RequestEmailDNISList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__EmailDNISList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__EmailDNISList, sizeof(struct __ns1__EmailDNISList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__EmailDNISList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestEmailDNISList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenRequestType(soap, "ns1:RequestEmailDNISList", &a->ns1__RequestEmailDNISList, "ns1:GenRequestType"))
				{	soap_flag_ns1__RequestEmailDNISList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__EmailDNISList * SOAP_FMAC2 soap_instantiate___ns1__EmailDNISList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__EmailDNISList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__EmailDNISList *p;
	size_t k = sizeof(struct __ns1__EmailDNISList);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__EmailDNISList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__EmailDNISList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__EmailDNISList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__EmailDNISList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__EmailDNISList(struct soap *soap, const struct __ns1__EmailDNISList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__EmailDNISList(soap, tag ? tag : "-ns1:EmailDNISList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EmailDNISList * SOAP_FMAC4 soap_get___ns1__EmailDNISList(struct soap *soap, struct __ns1__EmailDNISList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__EmailDNISList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__VoiceDNISList(struct soap *soap, struct __ns1__VoiceDNISList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestVoiceDNISList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__VoiceDNISList(struct soap *soap, const struct __ns1__VoiceDNISList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenRequestType(soap, &a->ns1__RequestVoiceDNISList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__VoiceDNISList(struct soap *soap, const char *tag, int id, const struct __ns1__VoiceDNISList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenRequestType(soap, "ns1:RequestVoiceDNISList", -1, &a->ns1__RequestVoiceDNISList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__VoiceDNISList * SOAP_FMAC4 soap_in___ns1__VoiceDNISList(struct soap *soap, const char *tag, struct __ns1__VoiceDNISList *a, const char *type)
{
	size_t soap_flag_ns1__RequestVoiceDNISList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__VoiceDNISList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__VoiceDNISList, sizeof(struct __ns1__VoiceDNISList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__VoiceDNISList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestVoiceDNISList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenRequestType(soap, "ns1:RequestVoiceDNISList", &a->ns1__RequestVoiceDNISList, "ns1:GenRequestType"))
				{	soap_flag_ns1__RequestVoiceDNISList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__VoiceDNISList * SOAP_FMAC2 soap_instantiate___ns1__VoiceDNISList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__VoiceDNISList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__VoiceDNISList *p;
	size_t k = sizeof(struct __ns1__VoiceDNISList);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__VoiceDNISList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__VoiceDNISList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__VoiceDNISList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__VoiceDNISList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__VoiceDNISList(struct soap *soap, const struct __ns1__VoiceDNISList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__VoiceDNISList(soap, tag ? tag : "-ns1:VoiceDNISList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__VoiceDNISList * SOAP_FMAC4 soap_get___ns1__VoiceDNISList(struct soap *soap, struct __ns1__VoiceDNISList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__VoiceDNISList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ReportListData(struct soap *soap, struct __ns1__ReportListData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestReportListData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ReportListData(struct soap *soap, const struct __ns1__ReportListData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ReportListDataRequestType(soap, &a->ns1__RequestReportListData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ReportListData(struct soap *soap, const char *tag, int id, const struct __ns1__ReportListData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__ReportListDataRequestType(soap, "ns1:RequestReportListData", -1, &a->ns1__RequestReportListData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ReportListData * SOAP_FMAC4 soap_in___ns1__ReportListData(struct soap *soap, const char *tag, struct __ns1__ReportListData *a, const char *type)
{
	size_t soap_flag_ns1__RequestReportListData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ReportListData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ReportListData, sizeof(struct __ns1__ReportListData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ReportListData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestReportListData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ReportListDataRequestType(soap, "ns1:RequestReportListData", &a->ns1__RequestReportListData, "ns1:ReportListDataRequestType"))
				{	soap_flag_ns1__RequestReportListData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ReportListData * SOAP_FMAC2 soap_instantiate___ns1__ReportListData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ReportListData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ReportListData *p;
	size_t k = sizeof(struct __ns1__ReportListData);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ReportListData);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ReportListData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ReportListData location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__ReportListData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ReportListData(struct soap *soap, const struct __ns1__ReportListData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ReportListData(soap, tag ? tag : "-ns1:ReportListData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ReportListData * SOAP_FMAC4 soap_get___ns1__ReportListData(struct soap *soap, struct __ns1__ReportListData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ReportListData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DefaultWorkspace(struct soap *soap, struct __ns1__DefaultWorkspace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestDefaultWorkspace = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DefaultWorkspace(struct soap *soap, const struct __ns1__DefaultWorkspace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__DefaultWorkspaceRequestType(soap, &a->ns1__RequestDefaultWorkspace);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DefaultWorkspace(struct soap *soap, const char *tag, int id, const struct __ns1__DefaultWorkspace *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__DefaultWorkspaceRequestType(soap, "ns1:RequestDefaultWorkspace", -1, &a->ns1__RequestDefaultWorkspace, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DefaultWorkspace * SOAP_FMAC4 soap_in___ns1__DefaultWorkspace(struct soap *soap, const char *tag, struct __ns1__DefaultWorkspace *a, const char *type)
{
	size_t soap_flag_ns1__RequestDefaultWorkspace = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DefaultWorkspace *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DefaultWorkspace, sizeof(struct __ns1__DefaultWorkspace), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DefaultWorkspace(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestDefaultWorkspace && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__DefaultWorkspaceRequestType(soap, "ns1:RequestDefaultWorkspace", &a->ns1__RequestDefaultWorkspace, "ns1:DefaultWorkspaceRequestType"))
				{	soap_flag_ns1__RequestDefaultWorkspace--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DefaultWorkspace * SOAP_FMAC2 soap_instantiate___ns1__DefaultWorkspace(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DefaultWorkspace(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DefaultWorkspace *p;
	size_t k = sizeof(struct __ns1__DefaultWorkspace);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__DefaultWorkspace);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__DefaultWorkspace, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DefaultWorkspace location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__DefaultWorkspace, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DefaultWorkspace(struct soap *soap, const struct __ns1__DefaultWorkspace *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DefaultWorkspace(soap, tag ? tag : "-ns1:DefaultWorkspace", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DefaultWorkspace * SOAP_FMAC4 soap_get___ns1__DefaultWorkspace(struct soap *soap, struct __ns1__DefaultWorkspace *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DefaultWorkspace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__BriefAgents(struct soap *soap, struct __ns1__BriefAgents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestBriefAgentsMatrix = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__BriefAgents(struct soap *soap, const struct __ns1__BriefAgents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__BriefInfoRequestType(soap, &a->ns1__RequestBriefAgentsMatrix);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__BriefAgents(struct soap *soap, const char *tag, int id, const struct __ns1__BriefAgents *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__BriefInfoRequestType(soap, "ns1:RequestBriefAgentsMatrix", -1, &a->ns1__RequestBriefAgentsMatrix, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BriefAgents * SOAP_FMAC4 soap_in___ns1__BriefAgents(struct soap *soap, const char *tag, struct __ns1__BriefAgents *a, const char *type)
{
	size_t soap_flag_ns1__RequestBriefAgentsMatrix = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__BriefAgents *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__BriefAgents, sizeof(struct __ns1__BriefAgents), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__BriefAgents(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestBriefAgentsMatrix && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__BriefInfoRequestType(soap, "ns1:RequestBriefAgentsMatrix", &a->ns1__RequestBriefAgentsMatrix, "ns1:BriefInfoRequestType"))
				{	soap_flag_ns1__RequestBriefAgentsMatrix--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__BriefAgents * SOAP_FMAC2 soap_instantiate___ns1__BriefAgents(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__BriefAgents(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__BriefAgents *p;
	size_t k = sizeof(struct __ns1__BriefAgents);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__BriefAgents);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__BriefAgents, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__BriefAgents location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__BriefAgents, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__BriefAgents(struct soap *soap, const struct __ns1__BriefAgents *a, const char *tag, const char *type)
{
	if (soap_out___ns1__BriefAgents(soap, tag ? tag : "-ns1:BriefAgents", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BriefAgents * SOAP_FMAC4 soap_get___ns1__BriefAgents(struct soap *soap, struct __ns1__BriefAgents *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__BriefAgents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__AgentsList(struct soap *soap, struct __ns1__AgentsList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestAgentsList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__AgentsList(struct soap *soap, const struct __ns1__AgentsList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenRequestType(soap, &a->ns1__RequestAgentsList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__AgentsList(struct soap *soap, const char *tag, int id, const struct __ns1__AgentsList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenRequestType(soap, "ns1:RequestAgentsList", -1, &a->ns1__RequestAgentsList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AgentsList * SOAP_FMAC4 soap_in___ns1__AgentsList(struct soap *soap, const char *tag, struct __ns1__AgentsList *a, const char *type)
{
	size_t soap_flag_ns1__RequestAgentsList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__AgentsList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__AgentsList, sizeof(struct __ns1__AgentsList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__AgentsList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestAgentsList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenRequestType(soap, "ns1:RequestAgentsList", &a->ns1__RequestAgentsList, "ns1:GenRequestType"))
				{	soap_flag_ns1__RequestAgentsList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__AgentsList * SOAP_FMAC2 soap_instantiate___ns1__AgentsList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__AgentsList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__AgentsList *p;
	size_t k = sizeof(struct __ns1__AgentsList);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__AgentsList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__AgentsList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__AgentsList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__AgentsList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__AgentsList(struct soap *soap, const struct __ns1__AgentsList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__AgentsList(soap, tag ? tag : "-ns1:AgentsList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AgentsList * SOAP_FMAC4 soap_get___ns1__AgentsList(struct soap *soap, struct __ns1__AgentsList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__AgentsList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__AgentsPerGroupInfo(struct soap *soap, struct __ns1__AgentsPerGroupInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestGroupAgentsMatrix = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__AgentsPerGroupInfo(struct soap *soap, const struct __ns1__AgentsPerGroupInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenInfoRequestType(soap, &a->ns1__RequestGroupAgentsMatrix);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__AgentsPerGroupInfo(struct soap *soap, const char *tag, int id, const struct __ns1__AgentsPerGroupInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenInfoRequestType(soap, "ns1:RequestGroupAgentsMatrix", -1, &a->ns1__RequestGroupAgentsMatrix, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AgentsPerGroupInfo * SOAP_FMAC4 soap_in___ns1__AgentsPerGroupInfo(struct soap *soap, const char *tag, struct __ns1__AgentsPerGroupInfo *a, const char *type)
{
	size_t soap_flag_ns1__RequestGroupAgentsMatrix = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__AgentsPerGroupInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__AgentsPerGroupInfo, sizeof(struct __ns1__AgentsPerGroupInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__AgentsPerGroupInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestGroupAgentsMatrix && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenInfoRequestType(soap, "ns1:RequestGroupAgentsMatrix", &a->ns1__RequestGroupAgentsMatrix, "ns1:GenInfoRequestType"))
				{	soap_flag_ns1__RequestGroupAgentsMatrix--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__AgentsPerGroupInfo * SOAP_FMAC2 soap_instantiate___ns1__AgentsPerGroupInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__AgentsPerGroupInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__AgentsPerGroupInfo *p;
	size_t k = sizeof(struct __ns1__AgentsPerGroupInfo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__AgentsPerGroupInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__AgentsPerGroupInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__AgentsPerGroupInfo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__AgentsPerGroupInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__AgentsPerGroupInfo(struct soap *soap, const struct __ns1__AgentsPerGroupInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__AgentsPerGroupInfo(soap, tag ? tag : "-ns1:AgentsPerGroupInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AgentsPerGroupInfo * SOAP_FMAC4 soap_get___ns1__AgentsPerGroupInfo(struct soap *soap, struct __ns1__AgentsPerGroupInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__AgentsPerGroupInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__MailAccList(struct soap *soap, struct __ns1__MailAccList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestMailAccList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__MailAccList(struct soap *soap, const struct __ns1__MailAccList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenRequestType(soap, &a->ns1__RequestMailAccList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__MailAccList(struct soap *soap, const char *tag, int id, const struct __ns1__MailAccList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenRequestType(soap, "ns1:RequestMailAccList", -1, &a->ns1__RequestMailAccList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__MailAccList * SOAP_FMAC4 soap_in___ns1__MailAccList(struct soap *soap, const char *tag, struct __ns1__MailAccList *a, const char *type)
{
	size_t soap_flag_ns1__RequestMailAccList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__MailAccList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__MailAccList, sizeof(struct __ns1__MailAccList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__MailAccList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestMailAccList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenRequestType(soap, "ns1:RequestMailAccList", &a->ns1__RequestMailAccList, "ns1:GenRequestType"))
				{	soap_flag_ns1__RequestMailAccList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__MailAccList * SOAP_FMAC2 soap_instantiate___ns1__MailAccList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__MailAccList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__MailAccList *p;
	size_t k = sizeof(struct __ns1__MailAccList);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__MailAccList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__MailAccList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__MailAccList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__MailAccList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__MailAccList(struct soap *soap, const struct __ns1__MailAccList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__MailAccList(soap, tag ? tag : "-ns1:MailAccList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__MailAccList * SOAP_FMAC4 soap_get___ns1__MailAccList(struct soap *soap, struct __ns1__MailAccList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__MailAccList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__IvrAppList(struct soap *soap, struct __ns1__IvrAppList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestIvrAppList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__IvrAppList(struct soap *soap, const struct __ns1__IvrAppList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenRequestType(soap, &a->ns1__RequestIvrAppList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__IvrAppList(struct soap *soap, const char *tag, int id, const struct __ns1__IvrAppList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenRequestType(soap, "ns1:RequestIvrAppList", -1, &a->ns1__RequestIvrAppList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__IvrAppList * SOAP_FMAC4 soap_in___ns1__IvrAppList(struct soap *soap, const char *tag, struct __ns1__IvrAppList *a, const char *type)
{
	size_t soap_flag_ns1__RequestIvrAppList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__IvrAppList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__IvrAppList, sizeof(struct __ns1__IvrAppList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__IvrAppList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestIvrAppList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenRequestType(soap, "ns1:RequestIvrAppList", &a->ns1__RequestIvrAppList, "ns1:GenRequestType"))
				{	soap_flag_ns1__RequestIvrAppList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__IvrAppList * SOAP_FMAC2 soap_instantiate___ns1__IvrAppList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__IvrAppList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__IvrAppList *p;
	size_t k = sizeof(struct __ns1__IvrAppList);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__IvrAppList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__IvrAppList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__IvrAppList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__IvrAppList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__IvrAppList(struct soap *soap, const struct __ns1__IvrAppList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__IvrAppList(soap, tag ? tag : "-ns1:IvrAppList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__IvrAppList * SOAP_FMAC4 soap_get___ns1__IvrAppList(struct soap *soap, struct __ns1__IvrAppList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__IvrAppList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__IvrPortGroupList(struct soap *soap, struct __ns1__IvrPortGroupList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestIvrPortGroupList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__IvrPortGroupList(struct soap *soap, const struct __ns1__IvrPortGroupList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenRequestType(soap, &a->ns1__RequestIvrPortGroupList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__IvrPortGroupList(struct soap *soap, const char *tag, int id, const struct __ns1__IvrPortGroupList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenRequestType(soap, "ns1:RequestIvrPortGroupList", -1, &a->ns1__RequestIvrPortGroupList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__IvrPortGroupList * SOAP_FMAC4 soap_in___ns1__IvrPortGroupList(struct soap *soap, const char *tag, struct __ns1__IvrPortGroupList *a, const char *type)
{
	size_t soap_flag_ns1__RequestIvrPortGroupList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__IvrPortGroupList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__IvrPortGroupList, sizeof(struct __ns1__IvrPortGroupList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__IvrPortGroupList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestIvrPortGroupList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenRequestType(soap, "ns1:RequestIvrPortGroupList", &a->ns1__RequestIvrPortGroupList, "ns1:GenRequestType"))
				{	soap_flag_ns1__RequestIvrPortGroupList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__IvrPortGroupList * SOAP_FMAC2 soap_instantiate___ns1__IvrPortGroupList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__IvrPortGroupList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__IvrPortGroupList *p;
	size_t k = sizeof(struct __ns1__IvrPortGroupList);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__IvrPortGroupList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__IvrPortGroupList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__IvrPortGroupList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__IvrPortGroupList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__IvrPortGroupList(struct soap *soap, const struct __ns1__IvrPortGroupList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__IvrPortGroupList(soap, tag ? tag : "-ns1:IvrPortGroupList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__IvrPortGroupList * SOAP_FMAC4 soap_get___ns1__IvrPortGroupList(struct soap *soap, struct __ns1__IvrPortGroupList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__IvrPortGroupList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GroupList(struct soap *soap, struct __ns1__GroupList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestGroupList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GroupList(struct soap *soap, const struct __ns1__GroupList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenRequestType(soap, &a->ns1__RequestGroupList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GroupList(struct soap *soap, const char *tag, int id, const struct __ns1__GroupList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenRequestType(soap, "ns1:RequestGroupList", -1, &a->ns1__RequestGroupList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GroupList * SOAP_FMAC4 soap_in___ns1__GroupList(struct soap *soap, const char *tag, struct __ns1__GroupList *a, const char *type)
{
	size_t soap_flag_ns1__RequestGroupList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GroupList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GroupList, sizeof(struct __ns1__GroupList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GroupList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestGroupList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenRequestType(soap, "ns1:RequestGroupList", &a->ns1__RequestGroupList, "ns1:GenRequestType"))
				{	soap_flag_ns1__RequestGroupList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GroupList * SOAP_FMAC2 soap_instantiate___ns1__GroupList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GroupList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GroupList *p;
	size_t k = sizeof(struct __ns1__GroupList);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GroupList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GroupList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GroupList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GroupList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GroupList(struct soap *soap, const struct __ns1__GroupList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GroupList(soap, tag ? tag : "-ns1:GroupList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GroupList * SOAP_FMAC4 soap_get___ns1__GroupList(struct soap *soap, struct __ns1__GroupList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GroupList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UserLogout(struct soap *soap, struct __ns1__UserLogout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestUserLogout = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UserLogout(struct soap *soap, const struct __ns1__UserLogout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenRequestType(soap, &a->ns1__RequestUserLogout);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UserLogout(struct soap *soap, const char *tag, int id, const struct __ns1__UserLogout *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenRequestType(soap, "ns1:RequestUserLogout", -1, &a->ns1__RequestUserLogout, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UserLogout * SOAP_FMAC4 soap_in___ns1__UserLogout(struct soap *soap, const char *tag, struct __ns1__UserLogout *a, const char *type)
{
	size_t soap_flag_ns1__RequestUserLogout = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UserLogout *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UserLogout, sizeof(struct __ns1__UserLogout), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UserLogout(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestUserLogout && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenRequestType(soap, "ns1:RequestUserLogout", &a->ns1__RequestUserLogout, "ns1:GenRequestType"))
				{	soap_flag_ns1__RequestUserLogout--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__UserLogout * SOAP_FMAC2 soap_instantiate___ns1__UserLogout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UserLogout(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UserLogout *p;
	size_t k = sizeof(struct __ns1__UserLogout);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__UserLogout);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__UserLogout, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UserLogout location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__UserLogout, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UserLogout(struct soap *soap, const struct __ns1__UserLogout *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UserLogout(soap, tag ? tag : "-ns1:UserLogout", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UserLogout * SOAP_FMAC4 soap_get___ns1__UserLogout(struct soap *soap, struct __ns1__UserLogout *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UserLogout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UserLogin(struct soap *soap, struct __ns1__UserLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestUserLogin = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UserLogin(struct soap *soap, const struct __ns1__UserLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__LoginRequestType(soap, &a->ns1__RequestUserLogin);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UserLogin(struct soap *soap, const char *tag, int id, const struct __ns1__UserLogin *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__LoginRequestType(soap, "ns1:RequestUserLogin", -1, &a->ns1__RequestUserLogin, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UserLogin * SOAP_FMAC4 soap_in___ns1__UserLogin(struct soap *soap, const char *tag, struct __ns1__UserLogin *a, const char *type)
{
	size_t soap_flag_ns1__RequestUserLogin = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UserLogin *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UserLogin, sizeof(struct __ns1__UserLogin), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UserLogin(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestUserLogin && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__LoginRequestType(soap, "ns1:RequestUserLogin", &a->ns1__RequestUserLogin, "ns1:LoginRequestType"))
				{	soap_flag_ns1__RequestUserLogin--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__UserLogin * SOAP_FMAC2 soap_instantiate___ns1__UserLogin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UserLogin(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UserLogin *p;
	size_t k = sizeof(struct __ns1__UserLogin);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__UserLogin);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__UserLogin, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UserLogin location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__UserLogin, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UserLogin(struct soap *soap, const struct __ns1__UserLogin *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UserLogin(soap, tag ? tag : "-ns1:UserLogin", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UserLogin * SOAP_FMAC4 soap_get___ns1__UserLogin(struct soap *soap, struct __ns1__UserLogin *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UserLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SuperGroupList(struct soap *soap, struct __ns1__SuperGroupList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestSuperGroupList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SuperGroupList(struct soap *soap, const struct __ns1__SuperGroupList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenRequestType(soap, &a->ns1__RequestSuperGroupList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SuperGroupList(struct soap *soap, const char *tag, int id, const struct __ns1__SuperGroupList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenRequestType(soap, "ns1:RequestSuperGroupList", -1, &a->ns1__RequestSuperGroupList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SuperGroupList * SOAP_FMAC4 soap_in___ns1__SuperGroupList(struct soap *soap, const char *tag, struct __ns1__SuperGroupList *a, const char *type)
{
	size_t soap_flag_ns1__RequestSuperGroupList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SuperGroupList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SuperGroupList, sizeof(struct __ns1__SuperGroupList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SuperGroupList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestSuperGroupList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenRequestType(soap, "ns1:RequestSuperGroupList", &a->ns1__RequestSuperGroupList, "ns1:GenRequestType"))
				{	soap_flag_ns1__RequestSuperGroupList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SuperGroupList * SOAP_FMAC2 soap_instantiate___ns1__SuperGroupList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SuperGroupList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SuperGroupList *p;
	size_t k = sizeof(struct __ns1__SuperGroupList);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SuperGroupList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SuperGroupList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SuperGroupList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SuperGroupList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SuperGroupList(struct soap *soap, const struct __ns1__SuperGroupList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SuperGroupList(soap, tag ? tag : "-ns1:SuperGroupList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SuperGroupList * SOAP_FMAC4 soap_get___ns1__SuperGroupList(struct soap *soap, struct __ns1__SuperGroupList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SuperGroupList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SuperGroupInfo(struct soap *soap, struct __ns1__SuperGroupInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestSuperGroupInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SuperGroupInfo(struct soap *soap, const struct __ns1__SuperGroupInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenInfoRequestType(soap, &a->ns1__RequestSuperGroupInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SuperGroupInfo(struct soap *soap, const char *tag, int id, const struct __ns1__SuperGroupInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenInfoRequestType(soap, "ns1:RequestSuperGroupInfo", -1, &a->ns1__RequestSuperGroupInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SuperGroupInfo * SOAP_FMAC4 soap_in___ns1__SuperGroupInfo(struct soap *soap, const char *tag, struct __ns1__SuperGroupInfo *a, const char *type)
{
	size_t soap_flag_ns1__RequestSuperGroupInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SuperGroupInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SuperGroupInfo, sizeof(struct __ns1__SuperGroupInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SuperGroupInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestSuperGroupInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenInfoRequestType(soap, "ns1:RequestSuperGroupInfo", &a->ns1__RequestSuperGroupInfo, "ns1:GenInfoRequestType"))
				{	soap_flag_ns1__RequestSuperGroupInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SuperGroupInfo * SOAP_FMAC2 soap_instantiate___ns1__SuperGroupInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SuperGroupInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SuperGroupInfo *p;
	size_t k = sizeof(struct __ns1__SuperGroupInfo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SuperGroupInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SuperGroupInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SuperGroupInfo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SuperGroupInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SuperGroupInfo(struct soap *soap, const struct __ns1__SuperGroupInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SuperGroupInfo(soap, tag ? tag : "-ns1:SuperGroupInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SuperGroupInfo * SOAP_FMAC4 soap_get___ns1__SuperGroupInfo(struct soap *soap, struct __ns1__SuperGroupInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SuperGroupInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__MailboxInfo(struct soap *soap, struct __ns1__MailboxInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestMailboxInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__MailboxInfo(struct soap *soap, const struct __ns1__MailboxInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenInfoRequestType(soap, &a->ns1__RequestMailboxInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__MailboxInfo(struct soap *soap, const char *tag, int id, const struct __ns1__MailboxInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenInfoRequestType(soap, "ns1:RequestMailboxInfo", -1, &a->ns1__RequestMailboxInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__MailboxInfo * SOAP_FMAC4 soap_in___ns1__MailboxInfo(struct soap *soap, const char *tag, struct __ns1__MailboxInfo *a, const char *type)
{
	size_t soap_flag_ns1__RequestMailboxInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__MailboxInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__MailboxInfo, sizeof(struct __ns1__MailboxInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__MailboxInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestMailboxInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenInfoRequestType(soap, "ns1:RequestMailboxInfo", &a->ns1__RequestMailboxInfo, "ns1:GenInfoRequestType"))
				{	soap_flag_ns1__RequestMailboxInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__MailboxInfo * SOAP_FMAC2 soap_instantiate___ns1__MailboxInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__MailboxInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__MailboxInfo *p;
	size_t k = sizeof(struct __ns1__MailboxInfo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__MailboxInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__MailboxInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__MailboxInfo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__MailboxInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__MailboxInfo(struct soap *soap, const struct __ns1__MailboxInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__MailboxInfo(soap, tag ? tag : "-ns1:MailboxInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__MailboxInfo * SOAP_FMAC4 soap_get___ns1__MailboxInfo(struct soap *soap, struct __ns1__MailboxInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__MailboxInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__IvrGrpInfo(struct soap *soap, struct __ns1__IvrGrpInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestIvrGrpInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__IvrGrpInfo(struct soap *soap, const struct __ns1__IvrGrpInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenInfoRequestType(soap, &a->ns1__RequestIvrGrpInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__IvrGrpInfo(struct soap *soap, const char *tag, int id, const struct __ns1__IvrGrpInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenInfoRequestType(soap, "ns1:RequestIvrGrpInfo", -1, &a->ns1__RequestIvrGrpInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__IvrGrpInfo * SOAP_FMAC4 soap_in___ns1__IvrGrpInfo(struct soap *soap, const char *tag, struct __ns1__IvrGrpInfo *a, const char *type)
{
	size_t soap_flag_ns1__RequestIvrGrpInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__IvrGrpInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__IvrGrpInfo, sizeof(struct __ns1__IvrGrpInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__IvrGrpInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestIvrGrpInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenInfoRequestType(soap, "ns1:RequestIvrGrpInfo", &a->ns1__RequestIvrGrpInfo, "ns1:GenInfoRequestType"))
				{	soap_flag_ns1__RequestIvrGrpInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__IvrGrpInfo * SOAP_FMAC2 soap_instantiate___ns1__IvrGrpInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__IvrGrpInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__IvrGrpInfo *p;
	size_t k = sizeof(struct __ns1__IvrGrpInfo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__IvrGrpInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__IvrGrpInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__IvrGrpInfo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__IvrGrpInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__IvrGrpInfo(struct soap *soap, const struct __ns1__IvrGrpInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__IvrGrpInfo(soap, tag ? tag : "-ns1:IvrGrpInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__IvrGrpInfo * SOAP_FMAC4 soap_get___ns1__IvrGrpInfo(struct soap *soap, struct __ns1__IvrGrpInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__IvrGrpInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__IvrPortInfo(struct soap *soap, struct __ns1__IvrPortInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestIvrPortInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__IvrPortInfo(struct soap *soap, const struct __ns1__IvrPortInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenInfoRequestType(soap, &a->ns1__RequestIvrPortInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__IvrPortInfo(struct soap *soap, const char *tag, int id, const struct __ns1__IvrPortInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenInfoRequestType(soap, "ns1:RequestIvrPortInfo", -1, &a->ns1__RequestIvrPortInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__IvrPortInfo * SOAP_FMAC4 soap_in___ns1__IvrPortInfo(struct soap *soap, const char *tag, struct __ns1__IvrPortInfo *a, const char *type)
{
	size_t soap_flag_ns1__RequestIvrPortInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__IvrPortInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__IvrPortInfo, sizeof(struct __ns1__IvrPortInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__IvrPortInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestIvrPortInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenInfoRequestType(soap, "ns1:RequestIvrPortInfo", &a->ns1__RequestIvrPortInfo, "ns1:GenInfoRequestType"))
				{	soap_flag_ns1__RequestIvrPortInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__IvrPortInfo * SOAP_FMAC2 soap_instantiate___ns1__IvrPortInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__IvrPortInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__IvrPortInfo *p;
	size_t k = sizeof(struct __ns1__IvrPortInfo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__IvrPortInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__IvrPortInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__IvrPortInfo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__IvrPortInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__IvrPortInfo(struct soap *soap, const struct __ns1__IvrPortInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__IvrPortInfo(soap, tag ? tag : "-ns1:IvrPortInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__IvrPortInfo * SOAP_FMAC4 soap_get___ns1__IvrPortInfo(struct soap *soap, struct __ns1__IvrPortInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__IvrPortInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__IvrApplInfo(struct soap *soap, struct __ns1__IvrApplInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestIvrApplInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__IvrApplInfo(struct soap *soap, const struct __ns1__IvrApplInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenInfoRequestType(soap, &a->ns1__RequestIvrApplInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__IvrApplInfo(struct soap *soap, const char *tag, int id, const struct __ns1__IvrApplInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenInfoRequestType(soap, "ns1:RequestIvrApplInfo", -1, &a->ns1__RequestIvrApplInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__IvrApplInfo * SOAP_FMAC4 soap_in___ns1__IvrApplInfo(struct soap *soap, const char *tag, struct __ns1__IvrApplInfo *a, const char *type)
{
	size_t soap_flag_ns1__RequestIvrApplInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__IvrApplInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__IvrApplInfo, sizeof(struct __ns1__IvrApplInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__IvrApplInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestIvrApplInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenInfoRequestType(soap, "ns1:RequestIvrApplInfo", &a->ns1__RequestIvrApplInfo, "ns1:GenInfoRequestType"))
				{	soap_flag_ns1__RequestIvrApplInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__IvrApplInfo * SOAP_FMAC2 soap_instantiate___ns1__IvrApplInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__IvrApplInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__IvrApplInfo *p;
	size_t k = sizeof(struct __ns1__IvrApplInfo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__IvrApplInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__IvrApplInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__IvrApplInfo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__IvrApplInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__IvrApplInfo(struct soap *soap, const struct __ns1__IvrApplInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__IvrApplInfo(soap, tag ? tag : "-ns1:IvrApplInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__IvrApplInfo * SOAP_FMAC4 soap_get___ns1__IvrApplInfo(struct soap *soap, struct __ns1__IvrApplInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__IvrApplInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GroupPeriodInfo(struct soap *soap, struct __ns1__GroupPeriodInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestGroupPeriodInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GroupPeriodInfo(struct soap *soap, const struct __ns1__GroupPeriodInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenInfoRequestType(soap, &a->ns1__RequestGroupPeriodInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GroupPeriodInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GroupPeriodInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenInfoRequestType(soap, "ns1:RequestGroupPeriodInfo", -1, &a->ns1__RequestGroupPeriodInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GroupPeriodInfo * SOAP_FMAC4 soap_in___ns1__GroupPeriodInfo(struct soap *soap, const char *tag, struct __ns1__GroupPeriodInfo *a, const char *type)
{
	size_t soap_flag_ns1__RequestGroupPeriodInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GroupPeriodInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GroupPeriodInfo, sizeof(struct __ns1__GroupPeriodInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GroupPeriodInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestGroupPeriodInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenInfoRequestType(soap, "ns1:RequestGroupPeriodInfo", &a->ns1__RequestGroupPeriodInfo, "ns1:GenInfoRequestType"))
				{	soap_flag_ns1__RequestGroupPeriodInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GroupPeriodInfo * SOAP_FMAC2 soap_instantiate___ns1__GroupPeriodInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GroupPeriodInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GroupPeriodInfo *p;
	size_t k = sizeof(struct __ns1__GroupPeriodInfo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GroupPeriodInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GroupPeriodInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GroupPeriodInfo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GroupPeriodInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GroupPeriodInfo(struct soap *soap, const struct __ns1__GroupPeriodInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GroupPeriodInfo(soap, tag ? tag : "-ns1:GroupPeriodInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GroupPeriodInfo * SOAP_FMAC4 soap_get___ns1__GroupPeriodInfo(struct soap *soap, struct __ns1__GroupPeriodInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GroupPeriodInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GroupGeneralInfo(struct soap *soap, struct __ns1__GroupGeneralInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestGroupGeneralInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GroupGeneralInfo(struct soap *soap, const struct __ns1__GroupGeneralInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenInfoRequestType(soap, &a->ns1__RequestGroupGeneralInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GroupGeneralInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GroupGeneralInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenInfoRequestType(soap, "ns1:RequestGroupGeneralInfo", -1, &a->ns1__RequestGroupGeneralInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GroupGeneralInfo * SOAP_FMAC4 soap_in___ns1__GroupGeneralInfo(struct soap *soap, const char *tag, struct __ns1__GroupGeneralInfo *a, const char *type)
{
	size_t soap_flag_ns1__RequestGroupGeneralInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GroupGeneralInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GroupGeneralInfo, sizeof(struct __ns1__GroupGeneralInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GroupGeneralInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestGroupGeneralInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenInfoRequestType(soap, "ns1:RequestGroupGeneralInfo", &a->ns1__RequestGroupGeneralInfo, "ns1:GenInfoRequestType"))
				{	soap_flag_ns1__RequestGroupGeneralInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GroupGeneralInfo * SOAP_FMAC2 soap_instantiate___ns1__GroupGeneralInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GroupGeneralInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GroupGeneralInfo *p;
	size_t k = sizeof(struct __ns1__GroupGeneralInfo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GroupGeneralInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GroupGeneralInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GroupGeneralInfo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GroupGeneralInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GroupGeneralInfo(struct soap *soap, const struct __ns1__GroupGeneralInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GroupGeneralInfo(soap, tag ? tag : "-ns1:GroupGeneralInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GroupGeneralInfo * SOAP_FMAC4 soap_get___ns1__GroupGeneralInfo(struct soap *soap, struct __ns1__GroupGeneralInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GroupGeneralInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GroupShiftInfo(struct soap *soap, struct __ns1__GroupShiftInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestGroupShiftInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GroupShiftInfo(struct soap *soap, const struct __ns1__GroupShiftInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenInfoRequestType(soap, &a->ns1__RequestGroupShiftInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GroupShiftInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GroupShiftInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenInfoRequestType(soap, "ns1:RequestGroupShiftInfo", -1, &a->ns1__RequestGroupShiftInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GroupShiftInfo * SOAP_FMAC4 soap_in___ns1__GroupShiftInfo(struct soap *soap, const char *tag, struct __ns1__GroupShiftInfo *a, const char *type)
{
	size_t soap_flag_ns1__RequestGroupShiftInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GroupShiftInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GroupShiftInfo, sizeof(struct __ns1__GroupShiftInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GroupShiftInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestGroupShiftInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenInfoRequestType(soap, "ns1:RequestGroupShiftInfo", &a->ns1__RequestGroupShiftInfo, "ns1:GenInfoRequestType"))
				{	soap_flag_ns1__RequestGroupShiftInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GroupShiftInfo * SOAP_FMAC2 soap_instantiate___ns1__GroupShiftInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GroupShiftInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GroupShiftInfo *p;
	size_t k = sizeof(struct __ns1__GroupShiftInfo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GroupShiftInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GroupShiftInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GroupShiftInfo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GroupShiftInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GroupShiftInfo(struct soap *soap, const struct __ns1__GroupShiftInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GroupShiftInfo(soap, tag ? tag : "-ns1:GroupShiftInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GroupShiftInfo * SOAP_FMAC4 soap_get___ns1__GroupShiftInfo(struct soap *soap, struct __ns1__GroupShiftInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GroupShiftInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GroupIntOvfInfo(struct soap *soap, struct __ns1__GroupIntOvfInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestGroupIntOvfInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GroupIntOvfInfo(struct soap *soap, const struct __ns1__GroupIntOvfInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenInfoRequestType(soap, &a->ns1__RequestGroupIntOvfInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GroupIntOvfInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GroupIntOvfInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenInfoRequestType(soap, "ns1:RequestGroupIntOvfInfo", -1, &a->ns1__RequestGroupIntOvfInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GroupIntOvfInfo * SOAP_FMAC4 soap_in___ns1__GroupIntOvfInfo(struct soap *soap, const char *tag, struct __ns1__GroupIntOvfInfo *a, const char *type)
{
	size_t soap_flag_ns1__RequestGroupIntOvfInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GroupIntOvfInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GroupIntOvfInfo, sizeof(struct __ns1__GroupIntOvfInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GroupIntOvfInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestGroupIntOvfInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenInfoRequestType(soap, "ns1:RequestGroupIntOvfInfo", &a->ns1__RequestGroupIntOvfInfo, "ns1:GenInfoRequestType"))
				{	soap_flag_ns1__RequestGroupIntOvfInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GroupIntOvfInfo * SOAP_FMAC2 soap_instantiate___ns1__GroupIntOvfInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GroupIntOvfInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GroupIntOvfInfo *p;
	size_t k = sizeof(struct __ns1__GroupIntOvfInfo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GroupIntOvfInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GroupIntOvfInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GroupIntOvfInfo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GroupIntOvfInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GroupIntOvfInfo(struct soap *soap, const struct __ns1__GroupIntOvfInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GroupIntOvfInfo(soap, tag ? tag : "-ns1:GroupIntOvfInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GroupIntOvfInfo * SOAP_FMAC4 soap_get___ns1__GroupIntOvfInfo(struct soap *soap, struct __ns1__GroupIntOvfInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GroupIntOvfInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GroupAbndInfo(struct soap *soap, struct __ns1__GroupAbndInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestGroupAbndInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GroupAbndInfo(struct soap *soap, const struct __ns1__GroupAbndInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenInfoRequestType(soap, &a->ns1__RequestGroupAbndInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GroupAbndInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GroupAbndInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenInfoRequestType(soap, "ns1:RequestGroupAbndInfo", -1, &a->ns1__RequestGroupAbndInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GroupAbndInfo * SOAP_FMAC4 soap_in___ns1__GroupAbndInfo(struct soap *soap, const char *tag, struct __ns1__GroupAbndInfo *a, const char *type)
{
	size_t soap_flag_ns1__RequestGroupAbndInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GroupAbndInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GroupAbndInfo, sizeof(struct __ns1__GroupAbndInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GroupAbndInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestGroupAbndInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenInfoRequestType(soap, "ns1:RequestGroupAbndInfo", &a->ns1__RequestGroupAbndInfo, "ns1:GenInfoRequestType"))
				{	soap_flag_ns1__RequestGroupAbndInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GroupAbndInfo * SOAP_FMAC2 soap_instantiate___ns1__GroupAbndInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GroupAbndInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GroupAbndInfo *p;
	size_t k = sizeof(struct __ns1__GroupAbndInfo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GroupAbndInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GroupAbndInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GroupAbndInfo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GroupAbndInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GroupAbndInfo(struct soap *soap, const struct __ns1__GroupAbndInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GroupAbndInfo(soap, tag ? tag : "-ns1:GroupAbndInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GroupAbndInfo * SOAP_FMAC4 soap_get___ns1__GroupAbndInfo(struct soap *soap, struct __ns1__GroupAbndInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GroupAbndInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GroupAgentsInfo(struct soap *soap, struct __ns1__GroupAgentsInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestGroupAgentsInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GroupAgentsInfo(struct soap *soap, const struct __ns1__GroupAgentsInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenInfoRequestType(soap, &a->ns1__RequestGroupAgentsInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GroupAgentsInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GroupAgentsInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenInfoRequestType(soap, "ns1:RequestGroupAgentsInfo", -1, &a->ns1__RequestGroupAgentsInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GroupAgentsInfo * SOAP_FMAC4 soap_in___ns1__GroupAgentsInfo(struct soap *soap, const char *tag, struct __ns1__GroupAgentsInfo *a, const char *type)
{
	size_t soap_flag_ns1__RequestGroupAgentsInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GroupAgentsInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GroupAgentsInfo, sizeof(struct __ns1__GroupAgentsInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GroupAgentsInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestGroupAgentsInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenInfoRequestType(soap, "ns1:RequestGroupAgentsInfo", &a->ns1__RequestGroupAgentsInfo, "ns1:GenInfoRequestType"))
				{	soap_flag_ns1__RequestGroupAgentsInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GroupAgentsInfo * SOAP_FMAC2 soap_instantiate___ns1__GroupAgentsInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GroupAgentsInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GroupAgentsInfo *p;
	size_t k = sizeof(struct __ns1__GroupAgentsInfo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GroupAgentsInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GroupAgentsInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GroupAgentsInfo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GroupAgentsInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GroupAgentsInfo(struct soap *soap, const struct __ns1__GroupAgentsInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GroupAgentsInfo(soap, tag ? tag : "-ns1:GroupAgentsInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GroupAgentsInfo * SOAP_FMAC4 soap_get___ns1__GroupAgentsInfo(struct soap *soap, struct __ns1__GroupAgentsInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GroupAgentsInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GroupQueInfo(struct soap *soap, struct __ns1__GroupQueInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestGroupQueInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GroupQueInfo(struct soap *soap, const struct __ns1__GroupQueInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenInfoRequestType(soap, &a->ns1__RequestGroupQueInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GroupQueInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GroupQueInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenInfoRequestType(soap, "ns1:RequestGroupQueInfo", -1, &a->ns1__RequestGroupQueInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GroupQueInfo * SOAP_FMAC4 soap_in___ns1__GroupQueInfo(struct soap *soap, const char *tag, struct __ns1__GroupQueInfo *a, const char *type)
{
	size_t soap_flag_ns1__RequestGroupQueInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GroupQueInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GroupQueInfo, sizeof(struct __ns1__GroupQueInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GroupQueInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestGroupQueInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenInfoRequestType(soap, "ns1:RequestGroupQueInfo", &a->ns1__RequestGroupQueInfo, "ns1:GenInfoRequestType"))
				{	soap_flag_ns1__RequestGroupQueInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GroupQueInfo * SOAP_FMAC2 soap_instantiate___ns1__GroupQueInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GroupQueInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GroupQueInfo *p;
	size_t k = sizeof(struct __ns1__GroupQueInfo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GroupQueInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GroupQueInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GroupQueInfo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GroupQueInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GroupQueInfo(struct soap *soap, const struct __ns1__GroupQueInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GroupQueInfo(soap, tag ? tag : "-ns1:GroupQueInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GroupQueInfo * SOAP_FMAC4 soap_get___ns1__GroupQueInfo(struct soap *soap, struct __ns1__GroupQueInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GroupQueInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GroupDetailFullInfo(struct soap *soap, struct __ns1__GroupDetailFullInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RequestGroupDetailFullInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GroupDetailFullInfo(struct soap *soap, const struct __ns1__GroupDetailFullInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GenInfoRequestType(soap, &a->ns1__RequestGroupDetailFullInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GroupDetailFullInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GroupDetailFullInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GenInfoRequestType(soap, "ns1:RequestGroupDetailFullInfo", -1, &a->ns1__RequestGroupDetailFullInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GroupDetailFullInfo * SOAP_FMAC4 soap_in___ns1__GroupDetailFullInfo(struct soap *soap, const char *tag, struct __ns1__GroupDetailFullInfo *a, const char *type)
{
	size_t soap_flag_ns1__RequestGroupDetailFullInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GroupDetailFullInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GroupDetailFullInfo, sizeof(struct __ns1__GroupDetailFullInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GroupDetailFullInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RequestGroupDetailFullInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenInfoRequestType(soap, "ns1:RequestGroupDetailFullInfo", &a->ns1__RequestGroupDetailFullInfo, "ns1:GenInfoRequestType"))
				{	soap_flag_ns1__RequestGroupDetailFullInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GroupDetailFullInfo * SOAP_FMAC2 soap_instantiate___ns1__GroupDetailFullInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GroupDetailFullInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GroupDetailFullInfo *p;
	size_t k = sizeof(struct __ns1__GroupDetailFullInfo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GroupDetailFullInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GroupDetailFullInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GroupDetailFullInfo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GroupDetailFullInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GroupDetailFullInfo(struct soap *soap, const struct __ns1__GroupDetailFullInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GroupDetailFullInfo(soap, tag ? tag : "-ns1:GroupDetailFullInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GroupDetailFullInfo * SOAP_FMAC4 soap_get___ns1__GroupDetailFullInfo(struct soap *soap, struct __ns1__GroupDetailFullInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GroupDetailFullInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__StatRequestType(struct soap *soap, ns1__StatRequestType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__StatRequestType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__StatRequestType(struct soap *soap, const char *tag, int id, ns1__StatRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__StatRequestType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__StatRequestType ? type : NULL);
}

SOAP_FMAC3 ns1__StatRequestType ** SOAP_FMAC4 soap_in_PointerTons1__StatRequestType(struct soap *soap, const char *tag, ns1__StatRequestType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__StatRequestType **)soap_malloc(soap, sizeof(ns1__StatRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__StatRequestType *)soap_instantiate_ns1__StatRequestType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__StatRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__StatRequestType, sizeof(ns1__StatRequestType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__StatRequestType(struct soap *soap, ns1__StatRequestType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__StatRequestType(soap, tag ? tag : "ns1:StatRequestType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__StatRequestType ** SOAP_FMAC4 soap_get_PointerTons1__StatRequestType(struct soap *soap, ns1__StatRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__StatRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ApplicationKeepAliveRequestType(struct soap *soap, ns1__ApplicationKeepAliveRequestType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ApplicationKeepAliveRequestType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ApplicationKeepAliveRequestType(struct soap *soap, const char *tag, int id, ns1__ApplicationKeepAliveRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ApplicationKeepAliveRequestType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ApplicationKeepAliveRequestType ? type : NULL);
}

SOAP_FMAC3 ns1__ApplicationKeepAliveRequestType ** SOAP_FMAC4 soap_in_PointerTons1__ApplicationKeepAliveRequestType(struct soap *soap, const char *tag, ns1__ApplicationKeepAliveRequestType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ApplicationKeepAliveRequestType **)soap_malloc(soap, sizeof(ns1__ApplicationKeepAliveRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ApplicationKeepAliveRequestType *)soap_instantiate_ns1__ApplicationKeepAliveRequestType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ApplicationKeepAliveRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ApplicationKeepAliveRequestType, sizeof(ns1__ApplicationKeepAliveRequestType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ApplicationKeepAliveRequestType(struct soap *soap, ns1__ApplicationKeepAliveRequestType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ApplicationKeepAliveRequestType(soap, tag ? tag : "ns1:ApplicationKeepAliveRequestType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ApplicationKeepAliveRequestType ** SOAP_FMAC4 soap_get_PointerTons1__ApplicationKeepAliveRequestType(struct soap *soap, ns1__ApplicationKeepAliveRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ApplicationKeepAliveRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ApplicationRegisterRequestType(struct soap *soap, ns1__ApplicationRegisterRequestType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ApplicationRegisterRequestType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ApplicationRegisterRequestType(struct soap *soap, const char *tag, int id, ns1__ApplicationRegisterRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ApplicationRegisterRequestType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ApplicationRegisterRequestType ? type : NULL);
}

SOAP_FMAC3 ns1__ApplicationRegisterRequestType ** SOAP_FMAC4 soap_in_PointerTons1__ApplicationRegisterRequestType(struct soap *soap, const char *tag, ns1__ApplicationRegisterRequestType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ApplicationRegisterRequestType **)soap_malloc(soap, sizeof(ns1__ApplicationRegisterRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ApplicationRegisterRequestType *)soap_instantiate_ns1__ApplicationRegisterRequestType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ApplicationRegisterRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ApplicationRegisterRequestType, sizeof(ns1__ApplicationRegisterRequestType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ApplicationRegisterRequestType(struct soap *soap, ns1__ApplicationRegisterRequestType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ApplicationRegisterRequestType(soap, tag ? tag : "ns1:ApplicationRegisterRequestType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ApplicationRegisterRequestType ** SOAP_FMAC4 soap_get_PointerTons1__ApplicationRegisterRequestType(struct soap *soap, ns1__ApplicationRegisterRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ApplicationRegisterRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__LoginManagerRequestType(struct soap *soap, ns1__LoginManagerRequestType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__LoginManagerRequestType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__LoginManagerRequestType(struct soap *soap, const char *tag, int id, ns1__LoginManagerRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__LoginManagerRequestType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__LoginManagerRequestType ? type : NULL);
}

SOAP_FMAC3 ns1__LoginManagerRequestType ** SOAP_FMAC4 soap_in_PointerTons1__LoginManagerRequestType(struct soap *soap, const char *tag, ns1__LoginManagerRequestType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__LoginManagerRequestType **)soap_malloc(soap, sizeof(ns1__LoginManagerRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__LoginManagerRequestType *)soap_instantiate_ns1__LoginManagerRequestType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__LoginManagerRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__LoginManagerRequestType, sizeof(ns1__LoginManagerRequestType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__LoginManagerRequestType(struct soap *soap, ns1__LoginManagerRequestType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__LoginManagerRequestType(soap, tag ? tag : "ns1:LoginManagerRequestType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__LoginManagerRequestType ** SOAP_FMAC4 soap_get_PointerTons1__LoginManagerRequestType(struct soap *soap, ns1__LoginManagerRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__LoginManagerRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RequestDeleteReportType(struct soap *soap, ns1__RequestDeleteReportType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RequestDeleteReportType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RequestDeleteReportType(struct soap *soap, const char *tag, int id, ns1__RequestDeleteReportType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RequestDeleteReportType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RequestDeleteReportType ? type : NULL);
}

SOAP_FMAC3 ns1__RequestDeleteReportType ** SOAP_FMAC4 soap_in_PointerTons1__RequestDeleteReportType(struct soap *soap, const char *tag, ns1__RequestDeleteReportType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RequestDeleteReportType **)soap_malloc(soap, sizeof(ns1__RequestDeleteReportType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RequestDeleteReportType *)soap_instantiate_ns1__RequestDeleteReportType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RequestDeleteReportType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RequestDeleteReportType, sizeof(ns1__RequestDeleteReportType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RequestDeleteReportType(struct soap *soap, ns1__RequestDeleteReportType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RequestDeleteReportType(soap, tag ? tag : "ns1:RequestDeleteReportType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RequestDeleteReportType ** SOAP_FMAC4 soap_get_PointerTons1__RequestDeleteReportType(struct soap *soap, ns1__RequestDeleteReportType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RequestDeleteReportType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RequestSaveReportType(struct soap *soap, ns1__RequestSaveReportType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RequestSaveReportType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RequestSaveReportType(struct soap *soap, const char *tag, int id, ns1__RequestSaveReportType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RequestSaveReportType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RequestSaveReportType ? type : NULL);
}

SOAP_FMAC3 ns1__RequestSaveReportType ** SOAP_FMAC4 soap_in_PointerTons1__RequestSaveReportType(struct soap *soap, const char *tag, ns1__RequestSaveReportType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RequestSaveReportType **)soap_malloc(soap, sizeof(ns1__RequestSaveReportType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RequestSaveReportType *)soap_instantiate_ns1__RequestSaveReportType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RequestSaveReportType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RequestSaveReportType, sizeof(ns1__RequestSaveReportType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RequestSaveReportType(struct soap *soap, ns1__RequestSaveReportType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RequestSaveReportType(soap, tag ? tag : "ns1:RequestSaveReportType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RequestSaveReportType ** SOAP_FMAC4 soap_get_PointerTons1__RequestSaveReportType(struct soap *soap, ns1__RequestSaveReportType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RequestSaveReportType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SaveWorkspaseRequestType(struct soap *soap, ns1__SaveWorkspaseRequestType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SaveWorkspaseRequestType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SaveWorkspaseRequestType(struct soap *soap, const char *tag, int id, ns1__SaveWorkspaseRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SaveWorkspaseRequestType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__SaveWorkspaseRequestType ? type : NULL);
}

SOAP_FMAC3 ns1__SaveWorkspaseRequestType ** SOAP_FMAC4 soap_in_PointerTons1__SaveWorkspaseRequestType(struct soap *soap, const char *tag, ns1__SaveWorkspaseRequestType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SaveWorkspaseRequestType **)soap_malloc(soap, sizeof(ns1__SaveWorkspaseRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SaveWorkspaseRequestType *)soap_instantiate_ns1__SaveWorkspaseRequestType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SaveWorkspaseRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SaveWorkspaseRequestType, sizeof(ns1__SaveWorkspaseRequestType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SaveWorkspaseRequestType(struct soap *soap, ns1__SaveWorkspaseRequestType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SaveWorkspaseRequestType(soap, tag ? tag : "ns1:SaveWorkspaseRequestType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SaveWorkspaseRequestType ** SOAP_FMAC4 soap_get_PointerTons1__SaveWorkspaseRequestType(struct soap *soap, ns1__SaveWorkspaseRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SaveWorkspaseRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TFRequestType(struct soap *soap, ns1__TFRequestType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TFRequestType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TFRequestType(struct soap *soap, const char *tag, int id, ns1__TFRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TFRequestType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__TFRequestType ? type : NULL);
}

SOAP_FMAC3 ns1__TFRequestType ** SOAP_FMAC4 soap_in_PointerTons1__TFRequestType(struct soap *soap, const char *tag, ns1__TFRequestType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TFRequestType **)soap_malloc(soap, sizeof(ns1__TFRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TFRequestType *)soap_instantiate_ns1__TFRequestType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__TFRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TFRequestType, sizeof(ns1__TFRequestType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TFRequestType(struct soap *soap, ns1__TFRequestType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__TFRequestType(soap, tag ? tag : "ns1:TFRequestType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TFRequestType ** SOAP_FMAC4 soap_get_PointerTons1__TFRequestType(struct soap *soap, ns1__TFRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TFRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ACDRequestType(struct soap *soap, ns1__ACDRequestType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ACDRequestType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ACDRequestType(struct soap *soap, const char *tag, int id, ns1__ACDRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ACDRequestType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ACDRequestType ? type : NULL);
}

SOAP_FMAC3 ns1__ACDRequestType ** SOAP_FMAC4 soap_in_PointerTons1__ACDRequestType(struct soap *soap, const char *tag, ns1__ACDRequestType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ACDRequestType **)soap_malloc(soap, sizeof(ns1__ACDRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ACDRequestType *)soap_instantiate_ns1__ACDRequestType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ACDRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ACDRequestType, sizeof(ns1__ACDRequestType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ACDRequestType(struct soap *soap, ns1__ACDRequestType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ACDRequestType(soap, tag ? tag : "ns1:ACDRequestType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ACDRequestType ** SOAP_FMAC4 soap_get_PointerTons1__ACDRequestType(struct soap *soap, ns1__ACDRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ACDRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ACDMultiRequestType(struct soap *soap, ns1__ACDMultiRequestType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ACDMultiRequestType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ACDMultiRequestType(struct soap *soap, const char *tag, int id, ns1__ACDMultiRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ACDMultiRequestType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ACDMultiRequestType ? type : NULL);
}

SOAP_FMAC3 ns1__ACDMultiRequestType ** SOAP_FMAC4 soap_in_PointerTons1__ACDMultiRequestType(struct soap *soap, const char *tag, ns1__ACDMultiRequestType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ACDMultiRequestType **)soap_malloc(soap, sizeof(ns1__ACDMultiRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ACDMultiRequestType *)soap_instantiate_ns1__ACDMultiRequestType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ACDMultiRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ACDMultiRequestType, sizeof(ns1__ACDMultiRequestType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ACDMultiRequestType(struct soap *soap, ns1__ACDMultiRequestType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ACDMultiRequestType(soap, tag ? tag : "ns1:ACDMultiRequestType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ACDMultiRequestType ** SOAP_FMAC4 soap_get_PointerTons1__ACDMultiRequestType(struct soap *soap, ns1__ACDMultiRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ACDMultiRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ReportListDataRequestType(struct soap *soap, ns1__ReportListDataRequestType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ReportListDataRequestType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ReportListDataRequestType(struct soap *soap, const char *tag, int id, ns1__ReportListDataRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ReportListDataRequestType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ReportListDataRequestType ? type : NULL);
}

SOAP_FMAC3 ns1__ReportListDataRequestType ** SOAP_FMAC4 soap_in_PointerTons1__ReportListDataRequestType(struct soap *soap, const char *tag, ns1__ReportListDataRequestType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ReportListDataRequestType **)soap_malloc(soap, sizeof(ns1__ReportListDataRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ReportListDataRequestType *)soap_instantiate_ns1__ReportListDataRequestType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ReportListDataRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ReportListDataRequestType, sizeof(ns1__ReportListDataRequestType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ReportListDataRequestType(struct soap *soap, ns1__ReportListDataRequestType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ReportListDataRequestType(soap, tag ? tag : "ns1:ReportListDataRequestType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ReportListDataRequestType ** SOAP_FMAC4 soap_get_PointerTons1__ReportListDataRequestType(struct soap *soap, ns1__ReportListDataRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ReportListDataRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DefaultWorkspaceRequestType(struct soap *soap, ns1__DefaultWorkspaceRequestType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DefaultWorkspaceRequestType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DefaultWorkspaceRequestType(struct soap *soap, const char *tag, int id, ns1__DefaultWorkspaceRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DefaultWorkspaceRequestType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__DefaultWorkspaceRequestType ? type : NULL);
}

SOAP_FMAC3 ns1__DefaultWorkspaceRequestType ** SOAP_FMAC4 soap_in_PointerTons1__DefaultWorkspaceRequestType(struct soap *soap, const char *tag, ns1__DefaultWorkspaceRequestType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DefaultWorkspaceRequestType **)soap_malloc(soap, sizeof(ns1__DefaultWorkspaceRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DefaultWorkspaceRequestType *)soap_instantiate_ns1__DefaultWorkspaceRequestType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__DefaultWorkspaceRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DefaultWorkspaceRequestType, sizeof(ns1__DefaultWorkspaceRequestType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DefaultWorkspaceRequestType(struct soap *soap, ns1__DefaultWorkspaceRequestType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DefaultWorkspaceRequestType(soap, tag ? tag : "ns1:DefaultWorkspaceRequestType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DefaultWorkspaceRequestType ** SOAP_FMAC4 soap_get_PointerTons1__DefaultWorkspaceRequestType(struct soap *soap, ns1__DefaultWorkspaceRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DefaultWorkspaceRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BriefInfoRequestType(struct soap *soap, ns1__BriefInfoRequestType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__BriefInfoRequestType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BriefInfoRequestType(struct soap *soap, const char *tag, int id, ns1__BriefInfoRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BriefInfoRequestType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__BriefInfoRequestType ? type : NULL);
}

SOAP_FMAC3 ns1__BriefInfoRequestType ** SOAP_FMAC4 soap_in_PointerTons1__BriefInfoRequestType(struct soap *soap, const char *tag, ns1__BriefInfoRequestType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__BriefInfoRequestType **)soap_malloc(soap, sizeof(ns1__BriefInfoRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__BriefInfoRequestType *)soap_instantiate_ns1__BriefInfoRequestType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__BriefInfoRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BriefInfoRequestType, sizeof(ns1__BriefInfoRequestType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BriefInfoRequestType(struct soap *soap, ns1__BriefInfoRequestType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__BriefInfoRequestType(soap, tag ? tag : "ns1:BriefInfoRequestType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__BriefInfoRequestType ** SOAP_FMAC4 soap_get_PointerTons1__BriefInfoRequestType(struct soap *soap, ns1__BriefInfoRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BriefInfoRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__LoginRequestType(struct soap *soap, ns1__LoginRequestType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__LoginRequestType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__LoginRequestType(struct soap *soap, const char *tag, int id, ns1__LoginRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__LoginRequestType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__LoginRequestType ? type : NULL);
}

SOAP_FMAC3 ns1__LoginRequestType ** SOAP_FMAC4 soap_in_PointerTons1__LoginRequestType(struct soap *soap, const char *tag, ns1__LoginRequestType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__LoginRequestType **)soap_malloc(soap, sizeof(ns1__LoginRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__LoginRequestType *)soap_instantiate_ns1__LoginRequestType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__LoginRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__LoginRequestType, sizeof(ns1__LoginRequestType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__LoginRequestType(struct soap *soap, ns1__LoginRequestType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__LoginRequestType(soap, tag ? tag : "ns1:LoginRequestType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__LoginRequestType ** SOAP_FMAC4 soap_get_PointerTons1__LoginRequestType(struct soap *soap, ns1__LoginRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__LoginRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GenRequestType(struct soap *soap, ns1__GenRequestType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GenRequestType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GenRequestType(struct soap *soap, const char *tag, int id, ns1__GenRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GenRequestType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__GenRequestType ? type : NULL);
}

SOAP_FMAC3 ns1__GenRequestType ** SOAP_FMAC4 soap_in_PointerTons1__GenRequestType(struct soap *soap, const char *tag, ns1__GenRequestType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GenRequestType **)soap_malloc(soap, sizeof(ns1__GenRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GenRequestType *)soap_instantiate_ns1__GenRequestType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__GenRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GenRequestType, sizeof(ns1__GenRequestType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GenRequestType(struct soap *soap, ns1__GenRequestType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GenRequestType(soap, tag ? tag : "ns1:GenRequestType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GenRequestType ** SOAP_FMAC4 soap_get_PointerTons1__GenRequestType(struct soap *soap, ns1__GenRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GenRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GenInfoRequestType(struct soap *soap, ns1__GenInfoRequestType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GenInfoRequestType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GenInfoRequestType(struct soap *soap, const char *tag, int id, ns1__GenInfoRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GenInfoRequestType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__GenInfoRequestType ? type : NULL);
}

SOAP_FMAC3 ns1__GenInfoRequestType ** SOAP_FMAC4 soap_in_PointerTons1__GenInfoRequestType(struct soap *soap, const char *tag, ns1__GenInfoRequestType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GenInfoRequestType **)soap_malloc(soap, sizeof(ns1__GenInfoRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GenInfoRequestType *)soap_instantiate_ns1__GenInfoRequestType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__GenInfoRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GenInfoRequestType, sizeof(ns1__GenInfoRequestType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GenInfoRequestType(struct soap *soap, ns1__GenInfoRequestType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GenInfoRequestType(soap, tag ? tag : "ns1:GenInfoRequestType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GenInfoRequestType ** SOAP_FMAC4 soap_get_PointerTons1__GenInfoRequestType(struct soap *soap, ns1__GenInfoRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GenInfoRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__StatItemType(struct soap *soap, ns1__StatItemType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__StatItemType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__StatItemType(struct soap *soap, const char *tag, int id, ns1__StatItemType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__StatItemType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__StatItemType ? type : NULL);
}

SOAP_FMAC3 ns1__StatItemType ** SOAP_FMAC4 soap_in_PointerTons1__StatItemType(struct soap *soap, const char *tag, ns1__StatItemType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__StatItemType **)soap_malloc(soap, sizeof(ns1__StatItemType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__StatItemType *)soap_instantiate_ns1__StatItemType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__StatItemType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__StatItemType, sizeof(ns1__StatItemType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__StatItemType(struct soap *soap, ns1__StatItemType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__StatItemType(soap, tag ? tag : "ns1:StatItemType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__StatItemType ** SOAP_FMAC4 soap_get_PointerTons1__StatItemType(struct soap *soap, ns1__StatItemType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__StatItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SuperGroupListDataItemType(struct soap *soap, ns1__SuperGroupListDataItemType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SuperGroupListDataItemType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SuperGroupListDataItemType(struct soap *soap, const char *tag, int id, ns1__SuperGroupListDataItemType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SuperGroupListDataItemType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__SuperGroupListDataItemType ? type : NULL);
}

SOAP_FMAC3 ns1__SuperGroupListDataItemType ** SOAP_FMAC4 soap_in_PointerTons1__SuperGroupListDataItemType(struct soap *soap, const char *tag, ns1__SuperGroupListDataItemType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SuperGroupListDataItemType **)soap_malloc(soap, sizeof(ns1__SuperGroupListDataItemType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SuperGroupListDataItemType *)soap_instantiate_ns1__SuperGroupListDataItemType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SuperGroupListDataItemType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SuperGroupListDataItemType, sizeof(ns1__SuperGroupListDataItemType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SuperGroupListDataItemType(struct soap *soap, ns1__SuperGroupListDataItemType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SuperGroupListDataItemType(soap, tag ? tag : "ns1:SuperGroupListDataItemType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SuperGroupListDataItemType ** SOAP_FMAC4 soap_get_PointerTons1__SuperGroupListDataItemType(struct soap *soap, ns1__SuperGroupListDataItemType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SuperGroupListDataItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DNISListDataItemType(struct soap *soap, ns1__DNISListDataItemType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DNISListDataItemType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DNISListDataItemType(struct soap *soap, const char *tag, int id, ns1__DNISListDataItemType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DNISListDataItemType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__DNISListDataItemType ? type : NULL);
}

SOAP_FMAC3 ns1__DNISListDataItemType ** SOAP_FMAC4 soap_in_PointerTons1__DNISListDataItemType(struct soap *soap, const char *tag, ns1__DNISListDataItemType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DNISListDataItemType **)soap_malloc(soap, sizeof(ns1__DNISListDataItemType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DNISListDataItemType *)soap_instantiate_ns1__DNISListDataItemType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__DNISListDataItemType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DNISListDataItemType, sizeof(ns1__DNISListDataItemType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DNISListDataItemType(struct soap *soap, ns1__DNISListDataItemType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DNISListDataItemType(soap, tag ? tag : "ns1:DNISListDataItemType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DNISListDataItemType ** SOAP_FMAC4 soap_get_PointerTons1__DNISListDataItemType(struct soap *soap, ns1__DNISListDataItemType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DNISListDataItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ReportListDataItemType(struct soap *soap, ns1__ReportListDataItemType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ReportListDataItemType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ReportListDataItemType(struct soap *soap, const char *tag, int id, ns1__ReportListDataItemType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ReportListDataItemType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ReportListDataItemType ? type : NULL);
}

SOAP_FMAC3 ns1__ReportListDataItemType ** SOAP_FMAC4 soap_in_PointerTons1__ReportListDataItemType(struct soap *soap, const char *tag, ns1__ReportListDataItemType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ReportListDataItemType **)soap_malloc(soap, sizeof(ns1__ReportListDataItemType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ReportListDataItemType *)soap_instantiate_ns1__ReportListDataItemType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ReportListDataItemType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ReportListDataItemType, sizeof(ns1__ReportListDataItemType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ReportListDataItemType(struct soap *soap, ns1__ReportListDataItemType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ReportListDataItemType(soap, tag ? tag : "ns1:ReportListDataItemType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ReportListDataItemType ** SOAP_FMAC4 soap_get_PointerTons1__ReportListDataItemType(struct soap *soap, ns1__ReportListDataItemType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ReportListDataItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DefaultWorkspaceItemType(struct soap *soap, ns1__DefaultWorkspaceItemType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DefaultWorkspaceItemType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DefaultWorkspaceItemType(struct soap *soap, const char *tag, int id, ns1__DefaultWorkspaceItemType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DefaultWorkspaceItemType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__DefaultWorkspaceItemType ? type : NULL);
}

SOAP_FMAC3 ns1__DefaultWorkspaceItemType ** SOAP_FMAC4 soap_in_PointerTons1__DefaultWorkspaceItemType(struct soap *soap, const char *tag, ns1__DefaultWorkspaceItemType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DefaultWorkspaceItemType **)soap_malloc(soap, sizeof(ns1__DefaultWorkspaceItemType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DefaultWorkspaceItemType *)soap_instantiate_ns1__DefaultWorkspaceItemType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__DefaultWorkspaceItemType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DefaultWorkspaceItemType, sizeof(ns1__DefaultWorkspaceItemType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DefaultWorkspaceItemType(struct soap *soap, ns1__DefaultWorkspaceItemType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DefaultWorkspaceItemType(soap, tag ? tag : "ns1:DefaultWorkspaceItemType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DefaultWorkspaceItemType ** SOAP_FMAC4 soap_get_PointerTons1__DefaultWorkspaceItemType(struct soap *soap, ns1__DefaultWorkspaceItemType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DefaultWorkspaceItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AgentsListDataItemType(struct soap *soap, ns1__AgentsListDataItemType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AgentsListDataItemType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AgentsListDataItemType(struct soap *soap, const char *tag, int id, ns1__AgentsListDataItemType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AgentsListDataItemType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__AgentsListDataItemType ? type : NULL);
}

SOAP_FMAC3 ns1__AgentsListDataItemType ** SOAP_FMAC4 soap_in_PointerTons1__AgentsListDataItemType(struct soap *soap, const char *tag, ns1__AgentsListDataItemType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AgentsListDataItemType **)soap_malloc(soap, sizeof(ns1__AgentsListDataItemType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AgentsListDataItemType *)soap_instantiate_ns1__AgentsListDataItemType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__AgentsListDataItemType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AgentsListDataItemType, sizeof(ns1__AgentsListDataItemType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AgentsListDataItemType(struct soap *soap, ns1__AgentsListDataItemType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__AgentsListDataItemType(soap, tag ? tag : "ns1:AgentsListDataItemType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AgentsListDataItemType ** SOAP_FMAC4 soap_get_PointerTons1__AgentsListDataItemType(struct soap *soap, ns1__AgentsListDataItemType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AgentsListDataItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GenListDataItemType(struct soap *soap, ns1__GenListDataItemType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GenListDataItemType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GenListDataItemType(struct soap *soap, const char *tag, int id, ns1__GenListDataItemType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GenListDataItemType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__GenListDataItemType ? type : NULL);
}

SOAP_FMAC3 ns1__GenListDataItemType ** SOAP_FMAC4 soap_in_PointerTons1__GenListDataItemType(struct soap *soap, const char *tag, ns1__GenListDataItemType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GenListDataItemType **)soap_malloc(soap, sizeof(ns1__GenListDataItemType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GenListDataItemType *)soap_instantiate_ns1__GenListDataItemType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__GenListDataItemType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GenListDataItemType, sizeof(ns1__GenListDataItemType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GenListDataItemType(struct soap *soap, ns1__GenListDataItemType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GenListDataItemType(soap, tag ? tag : "ns1:GenListDataItemType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GenListDataItemType ** SOAP_FMAC4 soap_get_PointerTons1__GenListDataItemType(struct soap *soap, ns1__GenListDataItemType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GenListDataItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GroupListDataItemType(struct soap *soap, ns1__GroupListDataItemType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GroupListDataItemType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GroupListDataItemType(struct soap *soap, const char *tag, int id, ns1__GroupListDataItemType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GroupListDataItemType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__GroupListDataItemType ? type : NULL);
}

SOAP_FMAC3 ns1__GroupListDataItemType ** SOAP_FMAC4 soap_in_PointerTons1__GroupListDataItemType(struct soap *soap, const char *tag, ns1__GroupListDataItemType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GroupListDataItemType **)soap_malloc(soap, sizeof(ns1__GroupListDataItemType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GroupListDataItemType *)soap_instantiate_ns1__GroupListDataItemType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__GroupListDataItemType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GroupListDataItemType, sizeof(ns1__GroupListDataItemType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GroupListDataItemType(struct soap *soap, ns1__GroupListDataItemType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GroupListDataItemType(soap, tag ? tag : "ns1:GroupListDataItemType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GroupListDataItemType ** SOAP_FMAC4 soap_get_PointerTons1__GroupListDataItemType(struct soap *soap, ns1__GroupListDataItemType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GroupListDataItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__returnDataRowsPerSuperGroup(struct soap *soap, ns1__returnDataRowsPerSuperGroup *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__returnDataRowsPerSuperGroup))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__returnDataRowsPerSuperGroup(struct soap *soap, const char *tag, int id, ns1__returnDataRowsPerSuperGroup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__returnDataRowsPerSuperGroup, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__returnDataRowsPerSuperGroup ? type : NULL);
}

SOAP_FMAC3 ns1__returnDataRowsPerSuperGroup ** SOAP_FMAC4 soap_in_PointerTons1__returnDataRowsPerSuperGroup(struct soap *soap, const char *tag, ns1__returnDataRowsPerSuperGroup **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__returnDataRowsPerSuperGroup **)soap_malloc(soap, sizeof(ns1__returnDataRowsPerSuperGroup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__returnDataRowsPerSuperGroup *)soap_instantiate_ns1__returnDataRowsPerSuperGroup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__returnDataRowsPerSuperGroup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__returnDataRowsPerSuperGroup, sizeof(ns1__returnDataRowsPerSuperGroup), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__returnDataRowsPerSuperGroup(struct soap *soap, ns1__returnDataRowsPerSuperGroup *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__returnDataRowsPerSuperGroup(soap, tag ? tag : "ns1:returnDataRowsPerSuperGroup", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__returnDataRowsPerSuperGroup ** SOAP_FMAC4 soap_get_PointerTons1__returnDataRowsPerSuperGroup(struct soap *soap, ns1__returnDataRowsPerSuperGroup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__returnDataRowsPerSuperGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__returnDataRowsPerGroup(struct soap *soap, ns1__returnDataRowsPerGroup *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__returnDataRowsPerGroup))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__returnDataRowsPerGroup(struct soap *soap, const char *tag, int id, ns1__returnDataRowsPerGroup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__returnDataRowsPerGroup, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__returnDataRowsPerGroup ? type : NULL);
}

SOAP_FMAC3 ns1__returnDataRowsPerGroup ** SOAP_FMAC4 soap_in_PointerTons1__returnDataRowsPerGroup(struct soap *soap, const char *tag, ns1__returnDataRowsPerGroup **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__returnDataRowsPerGroup **)soap_malloc(soap, sizeof(ns1__returnDataRowsPerGroup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__returnDataRowsPerGroup *)soap_instantiate_ns1__returnDataRowsPerGroup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__returnDataRowsPerGroup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__returnDataRowsPerGroup, sizeof(ns1__returnDataRowsPerGroup), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__returnDataRowsPerGroup(struct soap *soap, ns1__returnDataRowsPerGroup *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__returnDataRowsPerGroup(soap, tag ? tag : "ns1:returnDataRowsPerGroup", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__returnDataRowsPerGroup ** SOAP_FMAC4 soap_get_PointerTons1__returnDataRowsPerGroup(struct soap *soap, ns1__returnDataRowsPerGroup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__returnDataRowsPerGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DataItemRow(struct soap *soap, ns1__DataItemRow *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DataItemRow))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DataItemRow(struct soap *soap, const char *tag, int id, ns1__DataItemRow *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DataItemRow, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__DataItemRow ? type : NULL);
}

SOAP_FMAC3 ns1__DataItemRow ** SOAP_FMAC4 soap_in_PointerTons1__DataItemRow(struct soap *soap, const char *tag, ns1__DataItemRow **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DataItemRow **)soap_malloc(soap, sizeof(ns1__DataItemRow *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DataItemRow *)soap_instantiate_ns1__DataItemRow(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__DataItemRow **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DataItemRow, sizeof(ns1__DataItemRow), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DataItemRow(struct soap *soap, ns1__DataItemRow *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DataItemRow(soap, tag ? tag : "ns1:DataItemRow", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DataItemRow ** SOAP_FMAC4 soap_get_PointerTons1__DataItemRow(struct soap *soap, ns1__DataItemRow **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DataItemRow(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BlockItemType(struct soap *soap, ns1__BlockItemType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__BlockItemType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BlockItemType(struct soap *soap, const char *tag, int id, ns1__BlockItemType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BlockItemType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__BlockItemType ? type : NULL);
}

SOAP_FMAC3 ns1__BlockItemType ** SOAP_FMAC4 soap_in_PointerTons1__BlockItemType(struct soap *soap, const char *tag, ns1__BlockItemType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__BlockItemType **)soap_malloc(soap, sizeof(ns1__BlockItemType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__BlockItemType *)soap_instantiate_ns1__BlockItemType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__BlockItemType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BlockItemType, sizeof(ns1__BlockItemType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BlockItemType(struct soap *soap, ns1__BlockItemType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__BlockItemType(soap, tag ? tag : "ns1:BlockItemType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__BlockItemType ** SOAP_FMAC4 soap_get_PointerTons1__BlockItemType(struct soap *soap, ns1__BlockItemType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BlockItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ResponseInfoHeaderType(struct soap *soap, ns1__ResponseInfoHeaderType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ResponseInfoHeaderType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ResponseInfoHeaderType(struct soap *soap, const char *tag, int id, ns1__ResponseInfoHeaderType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ResponseInfoHeaderType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ResponseInfoHeaderType ? type : NULL);
}

SOAP_FMAC3 ns1__ResponseInfoHeaderType ** SOAP_FMAC4 soap_in_PointerTons1__ResponseInfoHeaderType(struct soap *soap, const char *tag, ns1__ResponseInfoHeaderType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ResponseInfoHeaderType **)soap_malloc(soap, sizeof(ns1__ResponseInfoHeaderType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ResponseInfoHeaderType *)soap_instantiate_ns1__ResponseInfoHeaderType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ResponseInfoHeaderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ResponseInfoHeaderType, sizeof(ns1__ResponseInfoHeaderType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ResponseInfoHeaderType(struct soap *soap, ns1__ResponseInfoHeaderType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ResponseInfoHeaderType(soap, tag ? tag : "ns1:ResponseInfoHeaderType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ResponseInfoHeaderType ** SOAP_FMAC4 soap_get_PointerTons1__ResponseInfoHeaderType(struct soap *soap, ns1__ResponseInfoHeaderType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ResponseInfoHeaderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DataItemType(struct soap *soap, ns1__DataItemType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DataItemType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DataItemType(struct soap *soap, const char *tag, int id, ns1__DataItemType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DataItemType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__DataItemType ? type : NULL);
}

SOAP_FMAC3 ns1__DataItemType ** SOAP_FMAC4 soap_in_PointerTons1__DataItemType(struct soap *soap, const char *tag, ns1__DataItemType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DataItemType **)soap_malloc(soap, sizeof(ns1__DataItemType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DataItemType *)soap_instantiate_ns1__DataItemType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__DataItemType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DataItemType, sizeof(ns1__DataItemType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DataItemType(struct soap *soap, ns1__DataItemType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DataItemType(soap, tag ? tag : "ns1:DataItemType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DataItemType ** SOAP_FMAC4 soap_get_PointerTons1__DataItemType(struct soap *soap, ns1__DataItemType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DataItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedInt(struct soap *soap, unsigned int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedInt(struct soap *soap, const char *tag, int id, unsigned int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedInt, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedInt(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_in_PointerTounsignedInt(struct soap *soap, const char *tag, unsigned int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned int **)soap_malloc(soap, sizeof(unsigned int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedInt(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedInt, sizeof(unsigned int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedInt(struct soap *soap, unsigned int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTounsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_get_PointerTounsignedInt(struct soap *soap, unsigned int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RequestInfoHeaderType(struct soap *soap, ns1__RequestInfoHeaderType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RequestInfoHeaderType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RequestInfoHeaderType(struct soap *soap, const char *tag, int id, ns1__RequestInfoHeaderType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RequestInfoHeaderType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__RequestInfoHeaderType ? type : NULL);
}

SOAP_FMAC3 ns1__RequestInfoHeaderType ** SOAP_FMAC4 soap_in_PointerTons1__RequestInfoHeaderType(struct soap *soap, const char *tag, ns1__RequestInfoHeaderType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RequestInfoHeaderType **)soap_malloc(soap, sizeof(ns1__RequestInfoHeaderType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RequestInfoHeaderType *)soap_instantiate_ns1__RequestInfoHeaderType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RequestInfoHeaderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RequestInfoHeaderType, sizeof(ns1__RequestInfoHeaderType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RequestInfoHeaderType(struct soap *soap, ns1__RequestInfoHeaderType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RequestInfoHeaderType(soap, tag ? tag : "ns1:RequestInfoHeaderType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RequestInfoHeaderType ** SOAP_FMAC4 soap_get_PointerTons1__RequestInfoHeaderType(struct soap *soap, ns1__RequestInfoHeaderType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RequestInfoHeaderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__StatItemType(struct soap *soap, std::vector<ns1__StatItemType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__StatItemType(struct soap *soap, const std::vector<ns1__StatItemType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__StatItemType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__StatItemType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__StatItemType(struct soap *soap, const char *tag, int id, const std::vector<ns1__StatItemType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__StatItemType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__StatItemType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__StatItemType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__StatItemType(struct soap *soap, const char *tag, std::vector<ns1__StatItemType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__StatItemType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__StatItemType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__StatItemType, SOAP_TYPE_std__vectorTemplateOfPointerTons1__StatItemType, sizeof(ns1__StatItemType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__StatItemType(soap, tag, NULL, "ns1:StatItemType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__StatItemType(soap, tag, &n, "ns1:StatItemType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__StatItemType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__StatItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__StatItemType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__StatItemType *> *p;
	size_t k = sizeof(std::vector<ns1__StatItemType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__StatItemType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__StatItemType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__StatItemType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons1__StatItemType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SuperGroupListDataItemType(struct soap *soap, std::vector<ns1__SuperGroupListDataItemType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SuperGroupListDataItemType(struct soap *soap, const std::vector<ns1__SuperGroupListDataItemType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__SuperGroupListDataItemType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__SuperGroupListDataItemType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SuperGroupListDataItemType(struct soap *soap, const char *tag, int id, const std::vector<ns1__SuperGroupListDataItemType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__SuperGroupListDataItemType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__SuperGroupListDataItemType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__SuperGroupListDataItemType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SuperGroupListDataItemType(struct soap *soap, const char *tag, std::vector<ns1__SuperGroupListDataItemType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__SuperGroupListDataItemType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__SuperGroupListDataItemType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__SuperGroupListDataItemType, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SuperGroupListDataItemType, sizeof(ns1__SuperGroupListDataItemType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__SuperGroupListDataItemType(soap, tag, NULL, "ns1:SuperGroupListDataItemType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__SuperGroupListDataItemType(soap, tag, &n, "ns1:SuperGroupListDataItemType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__SuperGroupListDataItemType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__SuperGroupListDataItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__SuperGroupListDataItemType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__SuperGroupListDataItemType *> *p;
	size_t k = sizeof(std::vector<ns1__SuperGroupListDataItemType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__SuperGroupListDataItemType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__SuperGroupListDataItemType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__SuperGroupListDataItemType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SuperGroupListDataItemType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__DNISListDataItemType(struct soap *soap, std::vector<ns1__DNISListDataItemType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__DNISListDataItemType(struct soap *soap, const std::vector<ns1__DNISListDataItemType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__DNISListDataItemType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__DNISListDataItemType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__DNISListDataItemType(struct soap *soap, const char *tag, int id, const std::vector<ns1__DNISListDataItemType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__DNISListDataItemType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__DNISListDataItemType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__DNISListDataItemType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__DNISListDataItemType(struct soap *soap, const char *tag, std::vector<ns1__DNISListDataItemType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__DNISListDataItemType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__DNISListDataItemType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__DNISListDataItemType, SOAP_TYPE_std__vectorTemplateOfPointerTons1__DNISListDataItemType, sizeof(ns1__DNISListDataItemType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__DNISListDataItemType(soap, tag, NULL, "ns1:DNISListDataItemType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__DNISListDataItemType(soap, tag, &n, "ns1:DNISListDataItemType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__DNISListDataItemType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__DNISListDataItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__DNISListDataItemType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__DNISListDataItemType *> *p;
	size_t k = sizeof(std::vector<ns1__DNISListDataItemType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__DNISListDataItemType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__DNISListDataItemType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__DNISListDataItemType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons1__DNISListDataItemType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ReportListDataItemType(struct soap *soap, std::vector<ns1__ReportListDataItemType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ReportListDataItemType(struct soap *soap, const std::vector<ns1__ReportListDataItemType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__ReportListDataItemType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__ReportListDataItemType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ReportListDataItemType(struct soap *soap, const char *tag, int id, const std::vector<ns1__ReportListDataItemType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__ReportListDataItemType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__ReportListDataItemType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ReportListDataItemType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ReportListDataItemType(struct soap *soap, const char *tag, std::vector<ns1__ReportListDataItemType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__ReportListDataItemType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__ReportListDataItemType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__ReportListDataItemType, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ReportListDataItemType, sizeof(ns1__ReportListDataItemType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__ReportListDataItemType(soap, tag, NULL, "ns1:ReportListDataItemType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__ReportListDataItemType(soap, tag, &n, "ns1:ReportListDataItemType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__ReportListDataItemType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__ReportListDataItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ReportListDataItemType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__ReportListDataItemType *> *p;
	size_t k = sizeof(std::vector<ns1__ReportListDataItemType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__ReportListDataItemType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__ReportListDataItemType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__ReportListDataItemType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ReportListDataItemType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__DefaultWorkspaceItemType(struct soap *soap, std::vector<ns1__DefaultWorkspaceItemType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__DefaultWorkspaceItemType(struct soap *soap, const std::vector<ns1__DefaultWorkspaceItemType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__DefaultWorkspaceItemType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__DefaultWorkspaceItemType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__DefaultWorkspaceItemType(struct soap *soap, const char *tag, int id, const std::vector<ns1__DefaultWorkspaceItemType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__DefaultWorkspaceItemType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__DefaultWorkspaceItemType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__DefaultWorkspaceItemType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__DefaultWorkspaceItemType(struct soap *soap, const char *tag, std::vector<ns1__DefaultWorkspaceItemType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__DefaultWorkspaceItemType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__DefaultWorkspaceItemType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__DefaultWorkspaceItemType, SOAP_TYPE_std__vectorTemplateOfPointerTons1__DefaultWorkspaceItemType, sizeof(ns1__DefaultWorkspaceItemType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__DefaultWorkspaceItemType(soap, tag, NULL, "ns1:DefaultWorkspaceItemType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__DefaultWorkspaceItemType(soap, tag, &n, "ns1:DefaultWorkspaceItemType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__DefaultWorkspaceItemType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__DefaultWorkspaceItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__DefaultWorkspaceItemType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__DefaultWorkspaceItemType *> *p;
	size_t k = sizeof(std::vector<ns1__DefaultWorkspaceItemType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__DefaultWorkspaceItemType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__DefaultWorkspaceItemType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__DefaultWorkspaceItemType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons1__DefaultWorkspaceItemType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__AgentsListDataItemType(struct soap *soap, std::vector<ns1__AgentsListDataItemType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__AgentsListDataItemType(struct soap *soap, const std::vector<ns1__AgentsListDataItemType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__AgentsListDataItemType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__AgentsListDataItemType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__AgentsListDataItemType(struct soap *soap, const char *tag, int id, const std::vector<ns1__AgentsListDataItemType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__AgentsListDataItemType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__AgentsListDataItemType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__AgentsListDataItemType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__AgentsListDataItemType(struct soap *soap, const char *tag, std::vector<ns1__AgentsListDataItemType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__AgentsListDataItemType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__AgentsListDataItemType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__AgentsListDataItemType, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AgentsListDataItemType, sizeof(ns1__AgentsListDataItemType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__AgentsListDataItemType(soap, tag, NULL, "ns1:AgentsListDataItemType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__AgentsListDataItemType(soap, tag, &n, "ns1:AgentsListDataItemType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__AgentsListDataItemType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__AgentsListDataItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__AgentsListDataItemType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__AgentsListDataItemType *> *p;
	size_t k = sizeof(std::vector<ns1__AgentsListDataItemType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__AgentsListDataItemType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__AgentsListDataItemType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__AgentsListDataItemType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AgentsListDataItemType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__GenListDataItemType(struct soap *soap, std::vector<ns1__GenListDataItemType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__GenListDataItemType(struct soap *soap, const std::vector<ns1__GenListDataItemType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__GenListDataItemType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__GenListDataItemType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__GenListDataItemType(struct soap *soap, const char *tag, int id, const std::vector<ns1__GenListDataItemType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__GenListDataItemType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__GenListDataItemType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__GenListDataItemType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__GenListDataItemType(struct soap *soap, const char *tag, std::vector<ns1__GenListDataItemType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__GenListDataItemType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__GenListDataItemType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__GenListDataItemType, SOAP_TYPE_std__vectorTemplateOfPointerTons1__GenListDataItemType, sizeof(ns1__GenListDataItemType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__GenListDataItemType(soap, tag, NULL, "ns1:GenListDataItemType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__GenListDataItemType(soap, tag, &n, "ns1:GenListDataItemType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__GenListDataItemType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__GenListDataItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__GenListDataItemType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__GenListDataItemType *> *p;
	size_t k = sizeof(std::vector<ns1__GenListDataItemType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__GenListDataItemType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__GenListDataItemType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__GenListDataItemType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons1__GenListDataItemType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__GroupListDataItemType(struct soap *soap, std::vector<ns1__GroupListDataItemType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__GroupListDataItemType(struct soap *soap, const std::vector<ns1__GroupListDataItemType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__GroupListDataItemType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__GroupListDataItemType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__GroupListDataItemType(struct soap *soap, const char *tag, int id, const std::vector<ns1__GroupListDataItemType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__GroupListDataItemType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__GroupListDataItemType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__GroupListDataItemType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__GroupListDataItemType(struct soap *soap, const char *tag, std::vector<ns1__GroupListDataItemType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__GroupListDataItemType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__GroupListDataItemType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__GroupListDataItemType, SOAP_TYPE_std__vectorTemplateOfPointerTons1__GroupListDataItemType, sizeof(ns1__GroupListDataItemType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__GroupListDataItemType(soap, tag, NULL, "ns1:GroupListDataItemType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__GroupListDataItemType(soap, tag, &n, "ns1:GroupListDataItemType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__GroupListDataItemType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__GroupListDataItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__GroupListDataItemType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__GroupListDataItemType *> *p;
	size_t k = sizeof(std::vector<ns1__GroupListDataItemType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__GroupListDataItemType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__GroupListDataItemType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__GroupListDataItemType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons1__GroupListDataItemType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__returnDataRowsPerSuperGroup(struct soap *soap, std::vector<ns1__returnDataRowsPerSuperGroup *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__returnDataRowsPerSuperGroup(struct soap *soap, const std::vector<ns1__returnDataRowsPerSuperGroup *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__returnDataRowsPerSuperGroup *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__returnDataRowsPerSuperGroup(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__returnDataRowsPerSuperGroup(struct soap *soap, const char *tag, int id, const std::vector<ns1__returnDataRowsPerSuperGroup *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__returnDataRowsPerSuperGroup *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__returnDataRowsPerSuperGroup(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__returnDataRowsPerSuperGroup *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__returnDataRowsPerSuperGroup(struct soap *soap, const char *tag, std::vector<ns1__returnDataRowsPerSuperGroup *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__returnDataRowsPerSuperGroup(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__returnDataRowsPerSuperGroup *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__returnDataRowsPerSuperGroup, SOAP_TYPE_std__vectorTemplateOfPointerTons1__returnDataRowsPerSuperGroup, sizeof(ns1__returnDataRowsPerSuperGroup), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__returnDataRowsPerSuperGroup(soap, tag, NULL, "ns1:returnDataRowsPerSuperGroup"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__returnDataRowsPerSuperGroup(soap, tag, &n, "ns1:returnDataRowsPerSuperGroup"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__returnDataRowsPerSuperGroup *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__returnDataRowsPerSuperGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__returnDataRowsPerSuperGroup(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__returnDataRowsPerSuperGroup *> *p;
	size_t k = sizeof(std::vector<ns1__returnDataRowsPerSuperGroup *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__returnDataRowsPerSuperGroup *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__returnDataRowsPerSuperGroup *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__returnDataRowsPerSuperGroup *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons1__returnDataRowsPerSuperGroup, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__returnDataRowsPerGroup(struct soap *soap, std::vector<ns1__returnDataRowsPerGroup *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__returnDataRowsPerGroup(struct soap *soap, const std::vector<ns1__returnDataRowsPerGroup *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__returnDataRowsPerGroup *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__returnDataRowsPerGroup(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__returnDataRowsPerGroup(struct soap *soap, const char *tag, int id, const std::vector<ns1__returnDataRowsPerGroup *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__returnDataRowsPerGroup *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__returnDataRowsPerGroup(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__returnDataRowsPerGroup *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__returnDataRowsPerGroup(struct soap *soap, const char *tag, std::vector<ns1__returnDataRowsPerGroup *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__returnDataRowsPerGroup(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__returnDataRowsPerGroup *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__returnDataRowsPerGroup, SOAP_TYPE_std__vectorTemplateOfPointerTons1__returnDataRowsPerGroup, sizeof(ns1__returnDataRowsPerGroup), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__returnDataRowsPerGroup(soap, tag, NULL, "ns1:returnDataRowsPerGroup"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__returnDataRowsPerGroup(soap, tag, &n, "ns1:returnDataRowsPerGroup"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__returnDataRowsPerGroup *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__returnDataRowsPerGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__returnDataRowsPerGroup(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__returnDataRowsPerGroup *> *p;
	size_t k = sizeof(std::vector<ns1__returnDataRowsPerGroup *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__returnDataRowsPerGroup *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__returnDataRowsPerGroup *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__returnDataRowsPerGroup *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons1__returnDataRowsPerGroup, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__DataItemRow(struct soap *soap, std::vector<ns1__DataItemRow *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__DataItemRow(struct soap *soap, const std::vector<ns1__DataItemRow *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__DataItemRow *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__DataItemRow(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__DataItemRow(struct soap *soap, const char *tag, int id, const std::vector<ns1__DataItemRow *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__DataItemRow *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__DataItemRow(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__DataItemRow *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__DataItemRow(struct soap *soap, const char *tag, std::vector<ns1__DataItemRow *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__DataItemRow(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__DataItemRow *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__DataItemRow, SOAP_TYPE_std__vectorTemplateOfPointerTons1__DataItemRow, sizeof(ns1__DataItemRow), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__DataItemRow(soap, tag, NULL, "ns1:DataItemRow"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__DataItemRow(soap, tag, &n, "ns1:DataItemRow"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__DataItemRow *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__DataItemRow(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__DataItemRow(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__DataItemRow *> *p;
	size_t k = sizeof(std::vector<ns1__DataItemRow *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__DataItemRow *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__DataItemRow *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__DataItemRow *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons1__DataItemRow, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__BlockItemType(struct soap *soap, std::vector<ns1__BlockItemType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__BlockItemType(struct soap *soap, const std::vector<ns1__BlockItemType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__BlockItemType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__BlockItemType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__BlockItemType(struct soap *soap, const char *tag, int id, const std::vector<ns1__BlockItemType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__BlockItemType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__BlockItemType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__BlockItemType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__BlockItemType(struct soap *soap, const char *tag, std::vector<ns1__BlockItemType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__BlockItemType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__BlockItemType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__BlockItemType, SOAP_TYPE_std__vectorTemplateOfPointerTons1__BlockItemType, sizeof(ns1__BlockItemType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__BlockItemType(soap, tag, NULL, "ns1:BlockItemType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__BlockItemType(soap, tag, &n, "ns1:BlockItemType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__BlockItemType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__BlockItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__BlockItemType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__BlockItemType *> *p;
	size_t k = sizeof(std::vector<ns1__BlockItemType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__BlockItemType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__BlockItemType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__BlockItemType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons1__BlockItemType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__DataItemType(struct soap *soap, std::vector<ns1__DataItemType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__DataItemType(struct soap *soap, const std::vector<ns1__DataItemType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__DataItemType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__DataItemType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__DataItemType(struct soap *soap, const char *tag, int id, const std::vector<ns1__DataItemType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__DataItemType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__DataItemType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__DataItemType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__DataItemType(struct soap *soap, const char *tag, std::vector<ns1__DataItemType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__DataItemType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__DataItemType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__DataItemType, SOAP_TYPE_std__vectorTemplateOfPointerTons1__DataItemType, sizeof(ns1__DataItemType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__DataItemType(soap, tag, NULL, "ns1:DataItemType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__DataItemType(soap, tag, &n, "ns1:DataItemType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__DataItemType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__DataItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__DataItemType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__DataItemType *> *p;
	size_t k = sizeof(std::vector<ns1__DataItemType *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__DataItemType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__DataItemType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__DataItemType *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons1__DataItemType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfunsignedInt(struct soap *soap, std::vector<unsigned int> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfunsignedInt(struct soap *soap, const std::vector<unsigned int> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfunsignedInt(struct soap *soap, const char *tag, int id, const std::vector<unsigned int> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<unsigned int> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_unsignedInt(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<unsigned int> * SOAP_FMAC4 soap_in_std__vectorTemplateOfunsignedInt(struct soap *soap, const char *tag, std::vector<unsigned int> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfunsignedInt(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		unsigned int n;
		soap_default_unsignedInt(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_unsignedInt, SOAP_TYPE_std__vectorTemplateOfunsignedInt, sizeof(unsigned int), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_unsignedInt(soap, tag, NULL, "xsd:unsignedInt"))
				break;
		}
		else
		{	if (!soap_in_unsignedInt(soap, tag, &n, "xsd:unsignedInt"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<unsigned int>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfunsignedInt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfunsignedInt(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<unsigned int> *p;
	size_t k = sizeof(std::vector<unsigned int> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<unsigned int> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<unsigned int> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<unsigned int>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfunsignedInt, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
